{
  "url": "http://www.techtimes.com/articles/311579/20250811/web-account-manager-foundational-enabler-single-sign-windows-applications-within-microsoft.htm",
  "authorsByline": "",
  "articleId": "a32077d958414db2a2140c743ab0cd91",
  "source": {
    "domain": "techtimes.com",
    "location": {
      "country": "us",
      "state": "NY",
      "city": "New York",
      "coordinates": {
        "lat": 40.7127281,
        "lon": -74.0060152
      }
    }
  },
  "imageUrl": "https://d.techtimes.com/en/full/458769/web-account-manager.png",
  "country": "us",
  "language": "en",
  "pubDate": "2025-08-11T21:16:28-04:00",
  "addDate": "2025-08-12T01:23:37.547520+00:00",
  "refreshDate": "2025-08-12T01:23:37.547522+00:00",
  "score": 1.0,
  "title": "Web Account Manager: The Foundational Enabler of Single Sign-On for Windows Applications within the Microsoft Identity Ecosystem",
  "description": "This article examines the operational principles of WAM, its multifaceted benefits for users, developers, and organizations, and its critical role as an enabler of Zero Trust security and modern identity and access management within the Microsoft ecosystem.",
  "content": "In today's rapidly evolving identity landscape, organizations are accelerating their adoption of cloud-first strategies (specifically by modernizing identity infrastructure through the adoption of cloud-based Microsoft identity providers) and implementing Zero Trust Architecture at an unprecedented pace. As these transformations unfold, the demand for user-friendly authentication and seamless, secure access to resources managed by Microsoft identity providers on Windows has intensified. Microsoft's Web Account Manager (WAM) has quietly emerged as a foundational pillar for secure access across Windows platforms, meeting these demands with robust efficiency. Originally introduced with Windows 10, WAM (either directly or through MSAL integration with WAM) now powers single sign-on (SSO) experiences for millions of users across flagship applications such as Microsoft 365 Copilot, Microsoft Office 365, Microsoft Teams, OneDrive, and a wide range of other Windows applications. By contrast, traditional authentication methods often resulted in fragmented user experiences, increased developer overhead, and potential security vulnerabilities. WAM addresses these challenges by centralizing identity management and token handling, thereby enabling application developers to deliver consistent, secure, and frictionless authentication for end users. This article examines the operational principles of WAM, its multifaceted benefits for users, developers, and organizations, and its critical role as an enabler of Zero Trust security and modern identity and access management within the Microsoft ecosystem.\n\nThe Fragmentation Problem: The Case for WAM\n\nWindows applications integrating with Microsoft identity providers without using any of the Microsoft-owned authentication libraries will be characterized by architectural and operational fragmentation that imposes costs on developers, introduces security variability, and degrades user experience. Applications implementing their own OAuth 2.0 and OpenID Connect (OIDC) protocol flows, managing token caches independently, and designing idiosyncratic sign-in interfaces produce several interrelated challenges:\n\u2022 Protocol and integration complexity\n\u2022 Each application must independently master the intricacies of OAuth 2.0/OIDC endpoints exposed by Microsoft Identity Providers, the different grant types, token acquisition patterns, refresh semantics, and robust error handling.\n\u2022 Ongoing protocol evolution and Microsoft identity provider-specific nuances necessitate a dedicated identity engineering capability to track changes and retrofit implementations across app portfolios.\n\u2022 Token caching and lifecycle management\n\u2022 Applications rolling their own token caches and lifecycle logic (expiry, revocation) lead to divergent behaviors and reliability issues.\n\u2022 Variability in storage and protection practices for tokens increases the risk surface for credential exposure.\n\u2022 Security and compliance risks\n\u2022 Inconsistent token lifecycle management complicates incident response and reduces the auditability and traceability necessary for compliance programs.\n\u2022 User friction and inconsistent experience\n\u2022 Users encounter repeated and unnecessary sign-ins across apps and services due to the absence of Single Sign-On, thereby degrading user productivity.\n\u2022 Varied prompts, consent flows, and UI patterns across applications create cognitive load, erode user trust, and increase support burden.\n\u2022 Operational overhead and scalability constraints\n\u2022 Teams bear ongoing maintenance costs to keep pace with identity protocol updates, diverting resources from core product features.\n\u2022 Duplicating identity logic across multiple applications erodes economies of scale and amplifies support overhead. Each application must maintain specialized expertise in its bespoke identity stack, resulting in fragmented support structures and significantly higher operational costs for the organization.\n\u2022 Fragmentation hinders centralized governance, prevents uniform enforcement of security and compliance policies, and slows the deployment of identity-related enhancements.\n\nForegoing a Microsoft-authored authentication library externalizes protocol complexity to every application, propagates security variability through bespoke token handling, and fragments the end-user experience. These outcomes collectively motivate a system-level approach that centralizes account and token management, standardizes user experience, and enables seamless SSO; objectives that authentication libraries such as WAM are designed to address.\n\nWAM is a core component of the Windows platform. It serves as an authentication library that enables seamless Single Sign-On (SSO) by brokering token acquisition (and all aspects of it) between Windows applications and Microsoft cloud identity providers such as Microsoft Entra ID (formerly Azure Active Directory) and Microsoft Account, using modern identity and access management protocols.\n\u2022 Seamless Single Sign-On (SSO): WAM is deeply integrated with Windows, using the user's current session and SSO artifacts (like Primary Refresh Tokens and Device Credentials) to deliver effortless SSO across applications. This streamlines access and boosts productivity.\n\u2022 Consistent Identity Experience: Users enjoy a unified authentication and authorization process across all Windows apps, resulting in a smoother and more predictable experience.\n\u2022 Simplified Integration: WAM abstracts the complexities of implementing OAuth 2.0 and OpenID Connect flows with Microsoft identity providers, simplifying integration for application developers. This allows developers to focus on core application functionality rather than identity management.\n\u2022 Centralized Token Management and Protection: WAM handles token acquisition, caching, and lifecycle management, significantly reducing developer effort and minimizing security risks associated with inconsistent or insecure token storage.\n\u2022 Built-In Security & Future Readiness: Security and reliability are handled by WAM, so developers don't need deep protocol expertise. As new security and identity features are released, they're delivered automatically to the applications, minimizing maintenance and ensuring applications stay protected and compliant.\n\u2022 Modern Identity and Access Management Standards Support: WAM supports advanced security features like Token Binding, Proof of Possession (PoP) tokens, and phishing-resistant credentials (e.g., Windows Hello, FIDO2). By working with Microsoft Entra ID, WAM ensures refresh tokens are device-bound and protected, preventing misuse even if credentials are compromised.\n\u2022 Zero Trust and Compliance: WAM enables device registration and mobile device management (MDM) enrollment, empowering organizations to manage devices and enforce compliance via MDM providers like Microsoft Intune. It also supports Conditional Access policies through Microsoft Entra ID, ensuring only trusted users from compliant devices can access resources. This makes WAM a cornerstone for Zero Trust security and enterprise-grade compliance.\n\u2022 Comprehensive Feature Support: Applications using WAM can natively leverage enhanced security features like Windows Hello, Conditional Access, and FIDO keys, ensuring that organizational policies are consistently applied and enforced across all client applications.\n\nWAM provides two main WinRT APIs for token acquisition:\n\u2022 GetTokenSilently \u2013 Attempts silent token retrieval without user interaction. If it fails, it does not fall back to interactive methods.\n\u2022 RequestToken \u2013 Tries silent retrieval first; if it fails with an interaction_required error, it initiates an interactive flow.\n\nThese APIs support integration across languages like C#, C++, and VB.\n\n1. Identify the WebAccountProvider: Applications must first specify the identity provider:\n\nThis step ensures WAM routes the request to the correct plugin (AAD or MSA).\n\nUse the provider from the first step and create a WebTokenRequest: WebTokenRequest(provider, scope, clientId)\n\nEssential Security Artifacts to Understand Before Exploring the WAM Token Request API\n\n1. Session Key: A symmetric key bound to the device, used for:\n\u2022 Token Encryption: Acts as the Content Encryption Key (CEK) in JWE responses from Microsoft Entra ID.\n\n2. Device Transport Key: An asymmetric key pair registered with Microsoft Entra ID. The public key encrypts the session key before it's sent to the client.\n\n3. Primary Refresh Token (PRT): A device-bound opaque token issued post-authentication. It contains the session key and enables SSO. PRTs are validated by proving possession of the embedded session key.\n\nThe GetTokenSilentlyAsync API in WAM enables secure, silent token acquisition on Windows devices. This deep dive explores the different device states that govern its behavior and the security underpinnings.\n\nWhen a device is Microsoft Entra Joined and a user successfully signs in with Entra ID credentials, Microsoft Entra ID issues a Primary Refresh Token (PRT) along with a Session Key. This information is securely stored by LSASS (Local Security Authority Subsystem Service).\n\nWAM first attempts to acquire a token using the Refresh Token. If that fails, it falls back to using the PRT.\n\nSimilar to Microsoft Entra Joined, but adds fallback to Windows Integrated Authentication (WIA) if requesting a token using both RT and PRT fails.\n\nNo PRT is available. WAM attempts WIA directly unless a WebAccount is provided associated with a cached RT.\n\nPRT is bound to the device using the session key, and WAM must show Proof-Of-Possession by signing the grant with the same session key as the one within the PRT. Entra ID will validate the signature by verifying if the grant is signed using the same session key as the one in the PRT. Once Entra ID is done verifying the signature, it will authenticate the user and the device using the information from the PRT and then issue an Access Token and a new PRT.\n\nSimilar to PRT flow. RT is also device-bound and signed with the session key. Entra ID returns a new Access Token and RT, which is stored securely using DPAPI.\n\nWhen applications request tokens using the WAM API, they may occasionally trigger interactive authentication prompts from Microsoft Entra ID. This typically occurs when:\n\u2022 The silent token request uses an SSO artifact (e.g., RT, PRT, SAML assertion) that lacks an MFA claim.\n\u2022 A Conditional Access (CA) policy enforces periodic MFA (e.g., every 24 hours or once every week).\n\nIf silent acquisition fails, RequestTokenAsync follows the OAuth 2.0 Authorization Code flow (RFC 6749, section 4.1).\n\n1. Token Request Initiation: The application requests an access token via WAM.\n\n2. Auth Code Request: WAM constructs and sends an auth code request using WebView1 (embedded browser).\n\n3. Cloud Verification: UrlMon intercepts the request, extracts the host, and verifies if it matches the Microsoft Cloud the device is joined to.\n\n5. Validation: MicrosoftAccountTokenProvider ensures the request originates from WAM, Edge, or a Medium-IL app.\n\u2022 If cached and valid, reuse it.\n\u2022 Otherwise, generate a new JWT payload with the PRT and sign it with the session key (HMAC-SHA256).\n\u2022 If cached and valid, reuse it.\n\u2022 Otherwise, generate a new JWT payload and sign it with the device certificate (RSA-SHA256).\n\n13. SSO Headers Attachment: UrlMon attaches the PRT and Device SSO cookies as headers to the auth code request being sent to the authorize endpoint.\n\n14. Authentication: Entra ID authenticates the user and device using the SSO headers.\n\n15. Auth Code Issuance: Upon successful authentication, Entra ID returns an auth code to WAM.\n\n16. Token Exchange: WAM uses the auth code to request an access token and a refresh token from Entra ID.\n\n19. Token Delivery: WAM returns the access token and a WebAccount to the application.\n\nThis flow ensures secure, seamless token acquisition while respecting conditional access policies and device trust states.\n\u2022 Enhancing the Token Binding Strategy: Existing token protection strategies, such as Access Token Proof of Possession (AT PoP) and Refresh Token Proof of Possession (RT PoP), are insufficient to defend against zero-day attacks, where a highly privileged attacker could exploit vulnerabilities. For instance, an attacker might steal a token from cache if the binding key is stored in software or obtain a new token using a binding key under their control. To provide robust protection against zero-day threats, the token binding strategy must be enhanced to ensure that token binding keys (and, by extension, the tokens themselves) are securely tied to the device and cannot be misused elsewhere.\n\nIn summary, the Web Account Manager (WAM) stands as a pivotal innovation within Microsoft's identity platform, fundamentally transforming how authentication and access are managed across the Windows ecosystem. By abstracting the intricate details of OAuth 2.0 and OpenID Connect protocols, WAM not only streamlines the integration process for developers but also ensures that security and compliance are maintained at an organizational level. Its architectural design (centered on centralized token and account management, device-bound credentials, and Proof-of-Possession mechanisms) embodies the principles of Zero Trust, thereby mitigating risks associated with fragmented identity solutions and inconsistent security practices.\n\nWAM's seamless support for both silent and interactive token acquisition, coupled with its deep integration with Windows and Microsoft Entra ID, enables organizations to deliver consistent Single Sign-On (SSO) experiences while enforcing advanced security policies such as Conditional Access. This dual focus on usability and security positions WAM as an essential enabler for organizations pursuing cloud-first, secure-by-design strategies in an increasingly complex identity landscape.\n\nAs the demands on identity infrastructure continue to evolve, driven by the proliferation of devices and the escalating sophistication of cyber threats, WAM's adaptability and extensibility ensure that it remains a future-proof solution. Ultimately, WAM not only addresses the immediate challenges of modern authentication but also lays a resilient foundation for the next generation of secure, user-, developer- and organization-centric identity and access management.\n\u2022 N. Sakimura, J. Bradley, M. Jones, B. de Medeiros, and C. Mortimore, OpenID Foundation, Nov. 2014. [Online]. Available:",
  "medium": "Article",
  "links": [
    "https://openid.net/specs/openid-connect-core-1_0.html",
    "https://datatracker.ietf.org/doc/html/rfc7800",
    "https://www.rfc-editor.org/rfc/rfc6749",
    "https://doi.org/10.6028/NIST.SP.800-207",
    "https://learn.microsoft.com/en-us/uwp/api/windows.security.authentication.web.core.webauthenticationcoremanager?view=winrt-26100"
  ],
  "labels": [],
  "claim": "",
  "verdict": "",
  "keywords": [
    {
      "name": "Microsoft identity providers",
      "weight": 0.08081386
    },
    {
      "name": "token binding keys",
      "weight": 0.07940424
    },
    {
      "name": "Microsoft cloud identity providers",
      "weight": 0.07803927
    },
    {
      "name": "token acquisition",
      "weight": 0.07747344
    },
    {
      "name": "Inconsistent token lifecycle management",
      "weight": 0.074278146
    },
    {
      "name": "refresh tokens",
      "weight": 0.07388284
    },
    {
      "name": "token acquisition patterns",
      "weight": 0.07351428
    },
    {
      "name": "tokens",
      "weight": 0.073386446
    },
    {
      "name": "token caches",
      "weight": 0.07315013
    },
    {
      "name": "token handling",
      "weight": 0.07236481
    }
  ],
  "topics": [
    {
      "name": "ESG"
    }
  ],
  "categories": [
    {
      "name": "Tech"
    }
  ],
  "taxonomies": [
    {
      "name": "/Computers & Electronics/Computer Security/Network Security",
      "score": 0.736328125
    },
    {
      "name": "/News/Technology News",
      "score": 0.387939453125
    },
    {
      "name": "/Computers & Electronics/Software/Business & Productivity Software",
      "score": 0.378662109375
    }
  ],
  "sentiment": {
    "positive": 0.3306142,
    "negative": 0.17657661,
    "neutral": 0.4928092
  },
  "summary": "Microsoft's Web Account Manager (WAM) has emerged as a key player in the Microsoft Identity Ecosystem, providing secure access across Windows platforms. Originally introduced with Windows 10, WAM powers single sign-on (SSO) experiences for millions of users across flagship applications such as Microsoft 365 Copilot, Microsoft Office 365, Microsoft Teams, OneDrive, and a wide range of other Windows applications. WAM centralizes identity management and token handling, enabling application developers to deliver consistent, secure authentication for end users. This article discusses the benefits of WAM and its critical role as an enabler of Zero Trust security and modern identity and access management within the Microsoft ecosystem. It also discusses the Fragmentation Problem for Windows applications without using any Microsoft-owned authentication libraries, highlighting challenges faced by each application individually including OAuth 2.0/OIDC endpoints exposed by Microsoft Identity Providers.",
  "shortSummary": "Microsoft's Web Account Manager (WAM) enhances user experience and security with centralization of authentication and token handling for Windows applications by providing seamless, secure access to Microsoft identity providers.",
  "translation": "",
  "translatedTitle": "",
  "translatedDescription": "",
  "translatedSummary": "",
  "reprint": false,
  "reprintGroupId": "105cfef845794b89bfff0bda0dfd04ec",
  "places": [],
  "scraped_sources": [
    {
      "url": "https://datatracker.ietf.org/doc/html/rfc7800",
      "text": "Internet Engineering Task Force (IETF) M. Jones Request for Comments: 7800 Microsoft Category: Standards Track J. Bradley ISSN: 2070-1721 Ping Identity H. Tschofenig ARM Limited April 2016 Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs) Abstract This specification describes how to declare in a JSON Web Token (JWT) that the presenter of the JWT possesses a particular proof-of- possession key and how the recipient can cryptographically confirm proof of possession of the key by the presenter. Being able to prove possession of a key is also sometimes described as the presenter being a holder-of-key. Status of This Memo This is an Internet Standards Track document. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741. Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7800. Copyright Notice Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved. This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License. Jones, et al. Standards Track [Page 1]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 Table of Contents 1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . 2 1.1. Notational Conventions . . . . . . . . . . . . . . . . . 5 2. Terminology . . . . . . . . . . . . . . . . . . . . . . . . . 5 3. Representations for Proof-of-Possession Keys . . . . . . . . 5 3.1. Confirmation Claim . . . . . . . . . . . . . . . . . . . 6 3.2. Representation of an Asymmetric Proof-of-Possession Key . 7 3.3. Representation of an Encrypted Symmetric Proof-of- Possession Key . . . . . . . . . . . . . . . . . . . . . 7 3.4. Representation of a Key ID for a Proof-of-Possession Key 8 3.5. Representation of a URL for a Proof-of-Possession Key . . 9 3.6. Specifics Intentionally Not Specified . . . . . . . . . . 10 4. Security Considerations . . . . . . . . . . . . . . . . . . . 10 5. Privacy Considerations . . . . . . . . . . . . . . . . . . . 11 6. IANA Considerations . . . . . . . . . . . . . . . . . . . . . 11 6.1. JSON Web Token Claims Registration . . . . . . . . . . . 12 6.1.1. Registry Contents . . . . . . . . . . . . . . . . . . 12 6.2. JWT Confirmation Methods Registry . . . . . . . . . . . . 12 6.2.1. Registration Template . . . . . . . . . . . . . . . . 12 6.2.2. Initial Registry Contents . . . . . . . . . . . . . . 13 7. References . . . . . . . . . . . . . . . . . . . . . . . . . 13 7.1. Normative References . . . . . . . . . . . . . . . . . . 13 7.2. Informative References . . . . . . . . . . . . . . . . . 14 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . 15 Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . 15 1. Introduction This specification describes how a JSON Web Token [JWT] can declare that the presenter of the JWT possesses a particular proof-of- possession (PoP) key and how the recipient can cryptographically confirm proof of possession of the key by the presenter. Proof of possession of a key is also sometimes described as the presenter being a holder-of-key. The [OAUTH-POP-ARCH] specification describes key confirmation, among other confirmation mechanisms. This specification defines how to communicate confirmation key information in JWTs. Envision the following two use cases. The first use case employs a symmetric proof-of-possession key and the second use case employs an asymmetric proof-of-possession key. Jones, et al. Standards Track [Page 2]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 +--------------+ | | +--------------+ | |--(3) Presentation of -->| | | | JWT w/ Encrypted | | | Presenter | PoP Key | | | | | | | |<-(4) Communication ---->| | | | Authenticated by | | +--------------+ PoP Key | | ^ ^ | | | | | | (1) Sym. (2) JWT w/ | Recipient | | PoP | Encrypted | | | Key | PoP Key | | v | | | +--------------+ | | | | | | | | | | | |<-(0) Key Exchange for ->| | | Issuer | Key Encryption Key | | | | | | | | | | | | +--------------+ +--------------+ Figure 1: Proof of Possession with a Symmetric Key In the case illustrated in Figure 1, (1) either the presenter generates a symmetric key and privately sends it to the issuer or the issuer generates a symmetric key and privately sends it to the presenter. The issuer generates a JWT with an encrypted copy of this symmetric key in the confirmation claim. This symmetric key is encrypted with a key known only to the issuer and the recipient, which was previously established in step (0). The entire JWT is integrity protected by the issuer. The JWT is then (2) sent to the presenter. Now, the presenter is in possession of the symmetric key as well as the JWT (which includes the confirmation claim). When the presenter (3) presents the JWT to the recipient, it also needs to demonstrate possession of the symmetric key; the presenter, for example, (4) uses the symmetric key in a challenge/response protocol with the recipient. The recipient is then able to verify that it is interacting with the genuine presenter by decrypting the key in the confirmation claim of the JWT. By doing this, the recipient obtains the symmetric key, which it then uses to verify cryptographically protected messages exchanged with the presenter (4). This symmetric key mechanism described above is conceptually similar to the use of Kerberos tickets. Jones, et al. Standards Track [Page 3]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 Note that for simplicity, the diagram above and associated text describe the direct use of symmetric keys without the use of derived keys. A more secure practice is to derive the symmetric keys actually used from secrets exchanged, such as the key exchanged in step (0), using a Key Derivation Function (KDF) and use the derived keys, rather than directly using the secrets exchanged. +--------------+ | | +--------------+ | |--(3) Presentation of -->| | | | JWT w/ Public | | | Presenter | PoP Key | | | | | | | |<-(4) Communication ---->| | | | Authenticated by | | +--------------+ PoP Key | | | ^ | | | | | | (1) Public (2) JWT w/ | Recipient | | PoP | Public | | | Key | PoP Key | | v | | | +--------------+ | | | | | | | | | | | | | | | Issuer | | | | | | | | | | | | | +--------------+ +--------------+ Figure 2: Proof of Possession with an Asymmetric Key In the case illustrated in Figure 2, the presenter generates a public/private key pair and (1) sends the public key to the issuer, which creates a JWT that contains the public key (or an identifier for it) in the confirmation claim. The entire JWT is integrity protected using a digital signature to protect it against modifications. The JWT is then (2) sent to the presenter. When the presenter (3) presents the JWT to the recipient, it also needs to demonstrate possession of the private key. The presenter, for example, (4) uses the private key in a Transport Layer Security (TLS) exchange with the recipient or (4) signs a nonce with the private key. The recipient is able to verify that it is interacting with the genuine presenter by extracting the public key from the confirmation claim of the JWT (after verifying the digital signature of the JWT) Jones, et al. Standards Track [Page 4]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 and utilizing it with the private key in the TLS exchange or by checking the nonce signature. In both cases, the JWT may contain other claims that are needed by the application. 1.1. Notational Conventions The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119]. Unless otherwise noted, all the protocol parameter names and values are case sensitive. 2. Terminology This specification uses terms defined in the JSON Web Token [JWT], JSON Web Key [JWK], and JSON Web Encryption [JWE] specifications. These terms are defined by this specification: Issuer Party that creates the JWT and binds the proof-of-possession key to it. Presenter Party that proves possession of a private key (for asymmetric key cryptography) or secret key (for symmetric key cryptography) to a recipient. Recipient Party that receives the JWT containing the proof-of-possession key information from the presenter. 3. Representations for Proof-of-Possession Keys By including a \"cnf\" (confirmation) claim in a JWT, the issuer of the JWT declares that the presenter possesses a particular key and that the recipient can cryptographically confirm that the presenter has possession of that key. The value of the \"cnf\" claim is a JSON object and the members of that object identify the proof-of- possession key. The presenter can be identified in one of several ways by the JWT depending upon the application requirements. If the JWT contains a \"sub\" (subject) claim [JWT], the presenter is normally the subject Jones, et al. Standards Track [Page 5]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 identified by the JWT. (In some applications, the subject identifier will be relative to the issuer identified by the \"iss\" (issuer) claim [JWT].) If the JWT contains no \"sub\" claim, the presenter is normally the issuer identified by the JWT using the \"iss\" claim. The case in which the presenter is the subject of the JWT is analogous to Security Assertion Markup Language (SAML) 2.0 [OASIS.saml-core-2.0-os] SubjectConfirmation usage. At least one of the \"sub\" and \"iss\" claims MUST be present in the JWT. Some use cases may require that both be present. Another means used by some applications to identify the presenter is an explicit claim, such as the \"azp\" (authorized party) claim defined by OpenID Connect [OpenID.Core]. Ultimately, the means of identifying the presenter is application specific, as is the means of confirming possession of the key that is communicated. 3.1. Confirmation Claim The \"cnf\" claim is used in the JWT to contain members used to identify the proof-of-possession key. Other members of the \"cnf\" object may be defined because a proof-of-possession key may not be the only means of confirming the authenticity of the token. This is analogous to the SAML 2.0 [OASIS.saml-core-2.0-os] SubjectConfirmation element in which a number of different subject confirmation methods can be included (including proof-of-possession key information). The set of confirmation members that a JWT must contain to be considered valid is context dependent and is outside the scope of this specification. Specific applications of JWTs will require implementations to understand and process some confirmation members in particular ways. However, in the absence of such requirements, all confirmation members that are not understood by implementations MUST be ignored. This specification establishes the IANA \"JWT Confirmation Methods\" registry for these members in Section 6.2 and registers the members defined by this specification. Other specifications can register other members used for confirmation, including other members for conveying proof-of-possession keys using different key representations. The \"cnf\" claim value MUST represent only a single proof-of- possession key; thus, at most one of the \"jwk\", \"jwe\", and \"jku\" (JWK Set URL) confirmation values defined below may be present. Note that if an application needs to represent multiple proof-of-possession keys in the same JWT, one way for it to achieve this is to use other claim names, in addition to \"cnf\", to hold the additional proof-of- Jones, et al. Standards Track [Page 6]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 possession key information. These claims could use the same syntax and semantics as the \"cnf\" claim. Those claims would be defined by applications or other specifications and could be registered in the IANA \"JSON Web Token Claims\" registry [IANA.JWT.Claims]. 3.2. Representation of an Asymmetric Proof-of-Possession Key When the key held by the presenter is an asymmetric private key, the \"jwk\" member is a JSON Web Key [JWK] representing the corresponding asymmetric public key. The following example demonstrates such a declaration in the JWT Claims Set of a JWT: { \"iss\": \"https://server.example.com\", \"aud\": \"https://client.example.org\", \"exp\": 1361398824, \"cnf\":{ \"jwk\":{ \"kty\": \"EC\", \"use\": \"sig\", \"crv\": \"P-256\", \"x\": \"18wHLeIgW9wVN6VD1Txgpqy2LszYkMf6J8njVAibvhM\", \"y\": \"-V4dS4UaLMgP_4fY4j8ir7cl1TXlFdAgcx55o7TkcSA\" } } } The JWK MUST contain the required key members for a JWK of that key type and MAY contain other JWK members, including the \"kid\" (Key ID) member. The \"jwk\" member MAY also be used for a JWK representing a symmetric key, provided that the JWT is encrypted so that the key is not revealed to unintended parties. The means of encrypting a JWT is explained in [JWT]. If the JWT is not encrypted, the symmetric key MUST be encrypted as described below. 3.3. Representation of an Encrypted Symmetric Proof-of-Possession Key When the key held by the presenter is a symmetric key, the \"jwe\" member is an encrypted JSON Web Key [JWK] encrypted to a key known to the recipient using the JWE Compact Serialization containing the symmetric key. The rules for encrypting a JWK are found in Section 7 of the JSON Web Key [JWK] specification. Jones, et al. Standards Track [Page 7]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 The following example illustrates a symmetric key that could subsequently be encrypted for use in the \"jwe\" member: { \"kty\": \"oct\", \"alg\": \"HS256\", \"k\": \"ZoRSOrFzN_FzUA5XKMYoVHyzff5oRJxl-IXRtztJ6uE\" } The UTF-8 [RFC3629] encoding of this JWK is used as the JWE Plaintext when encrypting the key. The following example is a JWE Header that could be used when encrypting this key: { \"alg\": \"RSA-OAEP\", \"enc\": \"A128CBC-HS256\" } The following example JWT Claims Set of a JWT illustrates the use of an encrypted symmetric key as the \"jwe\" member value: { \"iss\": \"https://server.example.com\", \"sub\": \"24400320\", \"aud\": \"s6BhdRkqt3\", \"nonce\": \"n-0S6_WzA2Mj\", \"exp\": 1311281970, \"iat\": 1311280970, \"cnf\":{ \"jwe\": \"eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkExMjhDQkMtSFMyNTYifQ. (remainder of JWE omitted for brevity)\" } } 3.4. Representation of a Key ID for a Proof-of-Possession Key The proof-of-possession key can also be identified by the use of a Key ID instead of communicating the actual key, provided the recipient is able to obtain the identified key using the Key ID. In this case, the issuer of a JWT declares that the presenter possesses a particular key and that the recipient can cryptographically confirm proof of possession of the key by the presenter by including a \"cnf\" claim in the JWT whose value is a JSON object with the JSON object containing a \"kid\" member identifying the key. Jones, et al. Standards Track [Page 8]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 The following example demonstrates such a declaration in the JWT Claims Set of a JWT: { \"iss\": \"https://server.example.com\", \"aud\": \"https://client.example.org\", \"exp\": 1361398824, \"cnf\":{ \"kid\": \"dfd1aa97-6d8d-4575-a0fe-34b96de2bfad\" } } The content of the \"kid\" value is application specific. For instance, some applications may choose to use a JWK Thumbprint [JWK.Thumbprint] value as the \"kid\" value. 3.5. Representation of a URL for a Proof-of-Possession Key The proof-of-possession key can be passed by reference instead of being passed by value. This is done using the \"jku\" member. Its value is a URI [RFC3986] that refers to a resource for a set of JSON- encoded public keys represented as a JWK Set [JWK], one of which is the proof-of-possession key. If there are multiple keys in the referenced JWK Set document, a \"kid\" member MUST also be included with the referenced key's JWK also containing the same \"kid\" value. The protocol used to acquire the resource MUST provide integrity protection. An HTTP GET request to retrieve the JWK Set MUST use TLS [RFC5246] and the identity of the server MUST be validated, as per Section 6 of RFC 6125 [RFC6125]. The following example demonstrates such a declaration in the JWT Claims Set of a JWT: { \"iss\": \"https://server.example.com\", \"sub\": \"17760704\", \"aud\": \"https://client.example.org\", \"exp\": 1440804813, \"cnf\":{ \"jku\": \"https://keys.example.net/pop-keys.json\", \"kid\": \"2015-08-28\" } } Jones, et al. Standards Track [Page 9]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 3.6. Specifics Intentionally Not Specified Proof of possession is typically demonstrated by having the presenter sign a value determined by the recipient using the key possessed by the presenter. This value is sometimes called a \"nonce\" or a \"challenge\". The means of communicating the nonce and the nature of its contents are intentionally not described in this specification, as different protocols will communicate this information in different ways. Likewise, the means of communicating the signed nonce is also not specified, as this is also protocol specific. Note that another means of proving possession of the key when it is a symmetric key is to encrypt the key to the recipient. The means of obtaining a key for the recipient is likewise protocol specific. For examples using the mechanisms defined in this specification, see [OAUTH-POP-ARCH]. 4. Security Considerations All of the security considerations that are discussed in [JWT] also apply here. In addition, proof of possession introduces its own unique security issues. Possessing a key is only valuable if it is kept secret. Appropriate means must be used to ensure that unintended parties do not learn private key or symmetric key values. Applications utilizing proof of possession should also utilize audience restriction, as described in Section 4.1.3 of [JWT], as it provides different protections. Proof of possession can be used by recipients to reject messages from unauthorized senders. Audience restriction can be used by recipients to reject messages intended for different recipients. A recipient might not understand the \"cnf\" claim. Applications that require the proof-of-possession keys communicated with it to be understood and processed must ensure that the parts of this specification that they use are implemented. Proof of possession via encrypted symmetric secrets is subject to replay attacks. This attack can, for example, be avoided when a signed nonce or challenge is used since the recipient can use a distinct nonce or challenge for each interaction. Replay can also be avoided if a sub-key is derived from a shared secret that is specific to the instance of the PoP demonstration. Jones, et al. Standards Track [Page 10]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 As is the case with other information included in a JWT, it is necessary to apply data origin authentication and integrity protection (via a keyed message digest or a digital signature). Data origin authentication ensures that the recipient of the JWT learns about the entity that created the JWT since this will be important for any policy decisions. Integrity protection prevents an adversary from changing any elements conveyed within the JWT payload. Special care has to be applied when carrying symmetric keys inside the JWT since those not only require integrity protection but also confidentiality protection. 5. Privacy Considerations A proof-of-possession key can be used as a correlation handle if the same key is used with multiple parties. Thus, for privacy reasons, it is recommended that different proof-of-possession keys be used when interacting with different parties. 6. IANA Considerations The following registration procedure is used for all the registries established by this specification. Values are registered on a Specification Required [RFC5226] basis after a three-week review period on the jwt-reg-review@ietf.org mailing list, on the advice of one or more Designated Experts. However, to allow for the allocation of values prior to publication, the Designated Experts may approve registration once they are satisfied that such a specification will be published. Registration requests sent to the mailing list for review should use an appropriate subject (e.g., \"Request to Register JWT Confirmation Method: example\"). Registration requests that are undetermined for a period longer than 21 days can be brought to the IESG's attention (using the iesg@ietf.org mailing list) for resolution. Criteria that should be applied by the Designated Experts include determining whether the proposed registration duplicates existing functionality, determining whether it is likely to be of general applicability or whether it is useful only for a single application, and evaluating the security properties of the item being registered and whether the registration makes sense. It is suggested that multiple Designated Experts be appointed who are able to represent the perspectives of different applications using this specification in order to enable broadly informed review of registration decisions. In cases where a registration decision could be perceived as creating a conflict of interest for a particular Jones, et al. Standards Track [Page 11]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 Expert, that Expert should defer to the judgment of the other Experts. 6.1. JSON Web Token Claims Registration This specification registers the \"cnf\" claim in the IANA \"JSON Web Token Claims\" registry [IANA.JWT.Claims] established by [JWT]. 6.1.1. Registry Contents o Claim Name: \"cnf\" o Claim Description: Confirmation o Change Controller: IESG o Specification Document(s): Section 3.1 of [RFC7800] 6.2. JWT Confirmation Methods Registry This specification establishes the IANA \"JWT Confirmation Methods\" registry for JWT \"cnf\" member values. The registry records the confirmation method member and a reference to the specification that defines it. 6.2.1. Registration Template Confirmation Method Value: The name requested (e.g., \"kid\"). Because a core goal of this specification is for the resulting representations to be compact, it is RECOMMENDED that the name be short -- not to exceed eight characters without a compelling reason to do so. This name is case sensitive. Names may not match other registered names in a case-insensitive manner unless the Designated Experts state that there is a compelling reason to allow an exception. Confirmation Method Description: Brief description of the confirmation method (e.g., \"Key Identifier\"). Change Controller: For Standards Track RFCs, list the \"IESG\". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included. Specification Document(s): Reference to the document or documents that specify the parameter, preferably including URIs that can be used to retrieve copies of the documents. An indication of the relevant sections may also be included but is not required. Jones, et al. Standards Track [Page 12]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 6.2.2. Initial Registry Contents o Confirmation Method Value: \"jwk\" o Confirmation Method Description: JSON Web Key Representing Public Key o Change Controller: IESG o Specification Document(s): Section 3.2 of [RFC7800] o Confirmation Method Value: \"jwe\" o Confirmation Method Description: Encrypted JSON Web Key o Change Controller: IESG o Specification Document(s): Section 3.3 of [RFC7800] o Confirmation Method Value: \"kid\" o Confirmation Method Description: Key Identifier o Change Controller: IESG o Specification Document(s): Section 3.4 of [RFC7800] o Confirmation Method Value: \"jku\" o Confirmation Method Description: JWK Set URL o Change Controller: IESG o Specification Document(s): Section 3.5 of [RFC7800] 7. References 7.1. Normative References [IANA.JWT.Claims] IANA, \"JSON Web Token Claims\", <http://www.iana.org/assignments/jwt>. [JWE] Jones, M. and J. Hildebrand, \"JSON Web Encryption (JWE)\", RFC 7516, DOI 10.17487/RFC7156, May 2015, <http://www.rfc-editor.org/info/rfc7516>. [JWK] Jones, M., \"JSON Web Key (JWK)\", RFC 7517, DOI 10.17487/RFC7157, May 2015, <http://www.rfc-editor.org/info/rfc7517>. [JWT] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token (JWT)\", RFC 7519, DOI 10.17487/RFC7159, May 2015, <http://www.rfc-editor.org/info/rfc7519>. [RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>. Jones, et al. Standards Track [Page 13]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 [RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>. [RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>. [RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>. [RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>. [RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <http://www.rfc-editor.org/info/rfc6125>. 7.2. Informative References [JWK.Thumbprint] Jones, M. and N. Sakimura, \"JSON Web Key (JWK) Thumbprint\", RFC 7638, DOI 10.17487/RFC7638, September 2015, <http://www.rfc-editor.org/info/rfc7638>. [OASIS.saml-core-2.0-os] Cantor, S., Kemp, J., Philpott, R., and E. Maler, \"Assertions and Protocol for the OASIS Security Assertion Markup Language (SAML) V2.0\", OASIS Standard saml-core- 2.0-os, March 2005, <http://docs.oasis-open.org/security/saml/v2.0/>. [OAUTH-POP-ARCH] Hunt, P., Ed, Richer, J., Mills, W., Mishra, P., and H. Tschofenig, \"OAuth 2.0 Proof-of-Possession (PoP) Security Architecture\", Work in Progress, draft-ietf-oauth-pop- architecture-07, December 2015. Jones, et al. Standards Track [Page 14]\nRFC 7800 Proof-of-Possession Key for JWTs April 2016 [OpenID.Core] Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, \"OpenID Connect Core 1.0\", November 2014, <http://openid.net/specs/openid-connect-core-1_0.html>. Acknowledgements The authors wish to thank Brian Campbell, Stephen Farrell, Barry Leiba, Kepeng Li, Chris Lonvick, James Manger, Kathleen Moriarty, Justin Richer, and Nat Sakimura for their reviews of the specification. Authors' Addresses Michael B. Jones Microsoft Email: mbj@microsoft.com URI: http://self-issued.info/ John Bradley Ping Identity Email: ve7jtb@ve7jtb.com URI: http://www.thread-safe.com/ Hannes Tschofenig ARM Limited Austria Email: Hannes.Tschofenig@gmx.net URI: http://www.tschofenig.priv.at Jones, et al. Standards Track [Page 15]"
    },
    {
      "url": "https://www.rfc-editor.org/rfc/rfc6749",
      "text": "[RFC Home] [TEXT|PDF|HTML] [Tracker] [IPR] [Errata] [Info page]\nPROPOSED STANDARD\nUpdated by: 8252, 8996, 9700 Errata ExistInternet Engineering Task Force (IETF) D. Hardt, Ed.\nRequest for Comments: 6749 Microsoft\nObsoletes: 5849 October 2012\nCategory: Standards Track\nISSN: 2070-1721\nThe OAuth 2.0 Authorization Framework\nAbstract\nThe OAuth 2.0 authorization framework enables a third-party\napplication to obtain limited access to an HTTP service, either on\nbehalf of a resource owner by orchestrating an approval interaction\nbetween the resource owner and the HTTP service, or by allowing the\nthird-party application to obtain access on its own behalf. This\nspecification replaces and obsoletes the OAuth 1.0 protocol described\nin RFC 5849.\nStatus of This Memo\nThis is an Internet Standards Track document.\nThis document is a product of the Internet Engineering Task Force\n(IETF). It represents the consensus of the IETF community. It has\nreceived public review and has been approved for publication by the\nInternet Engineering Steering Group (IESG). Further information on\nInternet Standards is available in Section 2 of RFC 5741.\nInformation about the current status of this document, any errata,\nand how to provide feedback on it may be obtained at\nhttp://www.rfc-editor.org/info/rfc6749.\nCopyright Notice\nCopyright (c) 2012 IETF Trust and the persons identified as the\ndocument authors. All rights reserved.\nThis document is subject to BCP 78 and the IETF Trust's Legal\nProvisions Relating to IETF Documents\n(http://trustee.ietf.org/license-info) in effect on the date of\npublication of this document. Please review these documents\ncarefully, as they describe your rights and restrictions with respect\nto this document. Code Components extracted from this document must\ninclude Simplified BSD License text as described in Section 4.e of\nthe Trust Legal Provisions and are provided without warranty as\ndescribed in the Simplified BSD License.\nHardt Standards Track [Page 1]\nRFC 6749 OAuth 2.0 October 2012\nTable of Contents\n1. Introduction ....................................................4\n1.1. Roles ......................................................6\n1.2. Protocol Flow ..............................................7\n1.3. Authorization Grant ........................................8\n1.3.1. Authorization Code ..................................8\n1.3.2. Implicit ............................................8\n1.3.3. Resource Owner Password Credentials .................9\n1.3.4. Client Credentials ..................................9\n1.4. Access Token ..............................................10\n1.5. Refresh Token .............................................10\n1.6. TLS Version ...............................................12\n1.7. HTTP Redirections .........................................12\n1.8. Interoperability ..........................................12\n1.9. Notational Conventions ....................................13\n2. Client Registration ............................................13\n2.1. Client Types ..............................................14\n2.2. Client Identifier .........................................15\n2.3. Client Authentication .....................................16\n2.3.1. Client Password ....................................16\n2.3.2. Other Authentication Methods .......................17\n2.4. Unregistered Clients ......................................17\n3. Protocol Endpoints .............................................18\n3.1. Authorization Endpoint ....................................18\n3.1.1. Response Type ......................................19\n3.1.2. Redirection Endpoint ...............................19\n3.2. Token Endpoint ............................................21\n3.2.1. Client Authentication ..............................22\n3.3. Access Token Scope ........................................23\n4. Obtaining Authorization ........................................23\n4.1. Authorization Code Grant ..................................24\n4.1.1. Authorization Request ..............................25\n4.1.2. Authorization Response .............................26\n4.1.3. Access Token Request ...............................29\n4.1.4. Access Token Response ..............................30\n4.2. Implicit Grant ............................................31\n4.2.1. Authorization Request ..............................33\n4.2.2. Access Token Response ..............................35\n4.3. Resource Owner Password Credentials Grant .................37\n4.3.1. Authorization Request and Response .................39\n4.3.2. Access Token Request ...............................39\n4.3.3. Access Token Response ..............................40\n4.4. Client Credentials Grant ..................................40\n4.4.1. Authorization Request and Response .................41\n4.4.2. Access Token Request ...............................41\n4.4.3. Access Token Response ..............................42\n4.5. Extension Grants ..........................................42\nHardt Standards Track [Page 2]\nRFC 6749 OAuth 2.0 October 2012\n5. Issuing an Access Token ........................................43\n5.1. Successful Response .......................................43\n5.2. Error Response ............................................45\n6. Refreshing an Access Token .....................................47\n7. Accessing Protected Resources ..................................48\n7.1. Access Token Types ........................................49\n7.2. Error Response ............................................49\n8. Extensibility ..................................................50\n8.1. Defining Access Token Types ...............................50\n8.2. Defining New Endpoint Parameters ..........................50\n8.3. Defining New Authorization Grant Types ....................51\n8.4. Defining New Authorization Endpoint Response Types ........51\n8.5. Defining Additional Error Codes ...........................51\n9. Native Applications ............................................52\n10. Security Considerations .......................................53\n10.1. Client Authentication ....................................53\n10.2. Client Impersonation .....................................54\n10.3. Access Tokens ............................................55\n10.4. Refresh Tokens ...........................................55\n10.5. Authorization Codes ......................................56\n10.6. Authorization Code Redirection URI Manipulation ..........56\n10.7. Resource Owner Password Credentials ......................57\n10.8. Request Confidentiality ..................................58\n10.9. Ensuring Endpoint Authenticity ...........................58\n10.10. Credentials-Guessing Attacks ............................58\n10.11. Phishing Attacks ........................................58\n10.12. Cross-Site Request Forgery ..............................59\n10.13. Clickjacking ............................................60\n10.14. Code Injection and Input Validation .....................60\n10.15. Open Redirectors ........................................60\n10.16. Misuse of Access Token to Impersonate Resource\nOwner in Implicit Flow ..................................61\n11. IANA Considerations ...........................................62\n11.1. OAuth Access Token Types Registry ........................62\n11.1.1. Registration Template .............................62\n11.2. OAuth Parameters Registry ................................63\n11.2.1. Registration Template .............................63\n11.2.2. Initial Registry Contents .........................64\n11.3. OAuth Authorization Endpoint Response Types Registry .....66\n11.3.1. Registration Template .............................66\n11.3.2. Initial Registry Contents .........................67\n11.4. OAuth Extensions Error Registry ..........................67\n11.4.1. Registration Template .............................68\n12. References ....................................................68\n12.1. Normative References .....................................68\n12.2. Informative References ...................................70\nHardt Standards Track [Page 3]\nRFC 6749 OAuth 2.0 October 2012\nAppendix A. Augmented Backus-Naur Form (ABNF) Syntax ..............71\nA.1. \"client_id\" Syntax ........................................71\nA.2. \"client_secret\" Syntax ....................................71\nA.3. \"response_type\" Syntax ....................................71\nA.4. \"scope\" Syntax ............................................72\nA.5. \"state\" Syntax ............................................72\nA.6. \"redirect_uri\" Syntax .....................................72\nA.7. \"error\" Syntax ............................................72\nA.8. \"error_description\" Syntax ................................72\nA.9. \"error_uri\" Syntax ........................................72\nA.10. \"grant_type\" Syntax .......................................73\nA.11. \"code\" Syntax .............................................73\nA.12. \"access_token\" Syntax .....................................73\nA.13. \"token_type\" Syntax .......................................73\nA.14. \"expires_in\" Syntax .......................................73\nA.15. \"username\" Syntax .........................................73\nA.16. \"password\" Syntax .........................................73\nA.17. \"refresh_token\" Syntax ....................................74\nA.18. Endpoint Parameter Syntax .................................74\nAppendix B. Use of application/x-www-form-urlencoded Media Type ...74\nAppendix C. Acknowledgements ......................................75\n1. Introduction\nIn the traditional client-server authentication model, the client\nrequests an access-restricted resource (protected resource) on the\nserver by authenticating with the server using the resource owner's\ncredentials. In order to provide third-party applications access to\nrestricted resources, the resource owner shares its credentials with\nthe third party. This creates several problems and limitations:\no Third-party applications are required to store the resource\nowner's credentials for future use, typically a password in\nclear-text.\no Servers are required to support password authentication, despite\nthe security weaknesses inherent in passwords.\no Third-party applications gain overly broad access to the resource\nowner's protected resources, leaving resource owners without any\nability to restrict duration or access to a limited subset of\nresources.\no Resource owners cannot revoke access to an individual third party\nwithout revoking access to all third parties, and must do so by\nchanging the third party's password.\nHardt Standards Track [Page 4]\nRFC 6749 OAuth 2.0 October 2012\no Compromise of any third-party application results in compromise of\nthe end-user's password and all of the data protected by that\npassword.\nOAuth addresses these issues by introducing an authorization layer\nand separating the role of the client from that of the resource\nowner. In OAuth, the client requests access to resources controlled\nby the resource owner and hosted by the resource server, and is\nissued a different set of credentials than those of the resource\nowner.\nInstead of using the resource owner's credentials to access protected\nresources, the client obtains an access token -- a string denoting a\nspecific scope, lifetime, and other access attributes. Access tokens\nare issued to third-party clients by an authorization server with the\napproval of the resource owner. The client uses the access token to\naccess the protected resources hosted by the resource server.\nFor example, an end-user (resource owner) can grant a printing\nservice (client) access to her protected photos stored at a photo-\nsharing service (resource server), without sharing her username and\npassword with the printing service. Instead, she authenticates\ndirectly with a server trusted by the photo-sharing service\n(authorization server), which issues the printing service delegation-\nspecific credentials (access token).\nThis specification is designed for use with HTTP ([RFC2616]). The\nuse of OAuth over any protocol other than HTTP is out of scope.\nThe OAuth 1.0 protocol ([RFC5849]), published as an informational\ndocument, was the result of a small ad hoc community effort. This\nStandards Track specification builds on the OAuth 1.0 deployment\nexperience, as well as additional use cases and extensibility\nrequirements gathered from the wider IETF community. The OAuth 2.0\nprotocol is not backward compatible with OAuth 1.0. The two versions\nmay co-exist on the network, and implementations may choose to\nsupport both. However, it is the intention of this specification\nthat new implementations support OAuth 2.0 as specified in this\ndocument and that OAuth 1.0 is used only to support existing\ndeployments. The OAuth 2.0 protocol shares very few implementation\ndetails with the OAuth 1.0 protocol. Implementers familiar with\nOAuth 1.0 should approach this document without any assumptions as to\nits structure and details.\nHardt Standards Track [Page 5]\nRFC 6749 OAuth 2.0 October 2012\n1.1. Roles\nOAuth defines four roles:\nresource owner\nAn entity capable of granting access to a protected resource.\nWhen the resource owner is a person, it is referred to as an\nend-user.\nresource server\nThe server hosting the protected resources, capable of accepting\nand responding to protected resource requests using access tokens.\nclient\nAn application making protected resource requests on behalf of the\nresource owner and with its authorization. The term \"client\" does\nnot imply any particular implementation characteristics (e.g.,\nwhether the application executes on a server, a desktop, or other\ndevices).\nauthorization server\nThe server issuing access tokens to the client after successfully\nauthenticating the resource owner and obtaining authorization.\nThe interaction between the authorization server and resource server\nis beyond the scope of this specification. The authorization server\nmay be the same server as the resource server or a separate entity.\nA single authorization server may issue access tokens accepted by\nmultiple resource servers.\nHardt Standards Track [Page 6]\nRFC 6749 OAuth 2.0 October 2012\n1.2. Protocol Flow\n+--------+ +---------------+\n| |--(A)- Authorization Request ->| Resource |\n| | | Owner |\n| |<-(B)-- Authorization Grant ---| |\n| | +---------------+\n| |\n| | +---------------+\n| |--(C)-- Authorization Grant -->| Authorization |\n| Client | | Server |\n| |<-(D)----- Access Token -------| |\n| | +---------------+\n| |\n| | +---------------+\n| |--(E)----- Access Token ------>| Resource |\n| | | Server |\n| |<-(F)--- Protected Resource ---| |\n+--------+ +---------------+\nFigure 1: Abstract Protocol Flow\nThe abstract OAuth 2.0 flow illustrated in Figure 1 describes the\ninteraction between the four roles and includes the following steps:\n(A) The client requests authorization from the resource owner. The\nauthorization request can be made directly to the resource owner\n(as shown), or preferably indirectly via the authorization\nserver as an intermediary.\n(B) The client receives an authorization grant, which is a\ncredential representing the resource owner's authorization,\nexpressed using one of four grant types defined in this\nspecification or using an extension grant type. The\nauthorization grant type depends on the method used by the\nclient to request authorization and the types supported by the\nauthorization server.\n(C) The client requests an access token by authenticating with the\nauthorization server and presenting the authorization grant.\n(D) The authorization server authenticates the client and validates\nthe authorization grant, and if valid, issues an access token.\nHardt Standards Track [Page 7]\nRFC 6749 OAuth 2.0 October 2012\n(E) The client requests the protected resource from the resource\nserver and authenticates by presenting the access token.\n(F) The resource server validates the access token, and if valid,\nserves the request.\nThe preferred method for the client to obtain an authorization grant\nfrom the resource owner (depicted in steps (A) and (B)) is to use the\nauthorization server as an intermediary, which is illustrated in\nFigure 3 in Section 4.1.\n1.3. Authorization Grant\nAn authorization grant is a credential representing the resource\nowner's authorization (to access its protected resources) used by the\nclient to obtain an access token. This specification defines four\ngrant types -- authorization code, implicit, resource owner password\ncredentials, and client credentials -- as well as an extensibility\nmechanism for defining additional types.\n1.3.1. Authorization Code\nThe authorization code is obtained by using an authorization server\nas an intermediary between the client and resource owner. Instead of\nrequesting authorization directly from the resource owner, the client\ndirects the resource owner to an authorization server (via its\nuser-agent as defined in [RFC2616]), which in turn directs the\nresource owner back to the client with the authorization code.\nBefore directing the resource owner back to the client with the\nauthorization code, the authorization server authenticates the\nresource owner and obtains authorization. Because the resource owner\nonly authenticates with the authorization server, the resource\nowner's credentials are never shared with the client.\nThe authorization code provides a few important security benefits,\nsuch as the ability to authenticate the client, as well as the\ntransmission of the access token directly to the client without\npassing it through the resource owner's user-agent and potentially\nexposing it to others, including the resource owner.\n1.3.2. Implicit\nThe implicit grant is a simplified authorization code flow optimized\nfor clients implemented in a browser using a scripting language such\nas JavaScript. In the implicit flow, instead of issuing the client\nan authorization code, the client is issued an access token directly\nHardt Standards Track [Page 8]\nRFC 6749 OAuth 2.0 October 2012\n(as the result of the resource owner authorization). The grant type\nis implicit, as no intermediate credentials (such as an authorization\ncode) are issued (and later used to obtain an access token).\nWhen issuing an access token during the implicit grant flow, the\nauthorization server does not authenticate the client. In some\ncases, the client identity can be verified via the redirection URI\nused to deliver the access token to the client. The access token may\nbe exposed to the resource owner or other applications with access to\nthe resource owner's user-agent.\nImplicit grants improve the responsiveness and efficiency of some\nclients (such as a client implemented as an in-browser application),\nsince it reduces the number of round trips required to obtain an\naccess token. However, this convenience should be weighed against\nthe security implications of using implicit grants, such as those\ndescribed in Sections 10.3 and 10.16, especially when the\nauthorization code grant type is available.\n1.3.3. Resource Owner Password Credentials\nThe resource owner password credentials (i.e., username and password)\ncan be used directly as an authorization grant to obtain an access\ntoken. The credentials should only be used when there is a high\ndegree of trust between the resource owner and the client (e.g., the\nclient is part of the device operating system or a highly privileged\napplication), and when other authorization grant types are not\navailable (such as an authorization code).\nEven though this grant type requires direct client access to the\nresource owner credentials, the resource owner credentials are used\nfor a single request and are exchanged for an access token. This\ngrant type can eliminate the need for the client to store the\nresource owner credentials for future use, by exchanging the\ncredentials with a long-lived access token or refresh token.\n1.3.4. Client Credentials\nThe client credentials (or other forms of client authentication) can\nbe used as an authorization grant when the authorization scope is\nlimited to the protected resources under the control of the client,\nor to protected resources previously arranged with the authorization\nserver. Client credentials are used as an authorization grant\ntypically when the client is acting on its own behalf (the client is\nalso the resource owner) or is requesting access to protected\nresources based on an authorization previously arranged with the\nauthorization server.\nHardt Standards Track [Page 9]\nRFC 6749 OAuth 2.0 October 2012\n1.4. Access Token\nAccess tokens are credentials used to access protected resources. An\naccess token is a string representing an authorization issued to the\nclient. The string is usually opaque to the client. Tokens\nrepresent specific scopes and durations of access, granted by the\nresource owner, and enforced by the resource server and authorization\nserver.\nThe token may denote an identifier used to retrieve the authorization\ninformation or may self-contain the authorization information in a\nverifiable manner (i.e., a token string consisting of some data and a\nsignature). Additional authentication credentials, which are beyond\nthe scope of this specification, may be required in order for the\nclient to use a token.\nThe access token provides an abstraction layer, replacing different\nauthorization constructs (e.g., username and password) with a single\ntoken understood by the resource server. This abstraction enables\nissuing access tokens more restrictive than the authorization grant\nused to obtain them, as well as removing the resource server's need\nto understand a wide range of authentication methods.\nAccess tokens can have different formats, structures, and methods of\nutilization (e.g., cryptographic properties) based on the resource\nserver security requirements. Access token attributes and the\nmethods used to access protected resources are beyond the scope of\nthis specification and are defined by companion specifications such\nas [RFC6750].\n1.5. Refresh Token\nRefresh tokens are credentials used to obtain access tokens. Refresh\ntokens are issued to the client by the authorization server and are\nused to obtain a new access token when the current access token\nbecomes invalid or expires, or to obtain additional access tokens\nwith identical or narrower scope (access tokens may have a shorter\nlifetime and fewer permissions than authorized by the resource\nowner). Issuing a refresh token is optional at the discretion of the\nauthorization server. If the authorization server issues a refresh\ntoken, it is included when issuing an access token (i.e., step (D) in\nFigure 1).\nA refresh token is a string representing the authorization granted to\nthe client by the resource owner. The string is usually opaque to\nthe client. The token denotes an identifier used to retrieve the\nHardt Standards Track [Page 10]\nRFC 6749 OAuth 2.0 October 2012\nauthorization information. Unlike access tokens, refresh tokens are\nintended for use only with authorization servers and are never sent\nto resource servers.\n+--------+ +---------------+\n| |--(A)------- Authorization Grant --------->| |\n| | | |\n| |<-(B)----------- Access Token -------------| |\n| | & Refresh Token | |\n| | | |\n| | +----------+ | |\n| |--(C)---- Access Token ---->| | | |\n| | | | | |\n| |<-(D)- Protected Resource --| Resource | | Authorization |\n| Client | | Server | | Server |\n| |--(E)---- Access Token ---->| | | |\n| | | | | |\n| |<-(F)- Invalid Token Error -| | | |\n| | +----------+ | |\n| | | |\n| |--(G)----------- Refresh Token ----------->| |\n| | | |\n| |<-(H)----------- Access Token -------------| |\n+--------+ & Optional Refresh Token +---------------+\nFigure 2: Refreshing an Expired Access Token\nThe flow illustrated in Figure 2 includes the following steps:\n(A) The client requests an access token by authenticating with the\nauthorization server and presenting an authorization grant.\n(B) The authorization server authenticates the client and validates\nthe authorization grant, and if valid, issues an access token\nand a refresh token.\n(C) The client makes a protected resource request to the resource\nserver by presenting the access token.\n(D) The resource server validates the access token, and if valid,\nserves the request.\n(E) Steps (C) and (D) repeat until the access token expires. If the\nclient knows the access token expired, it skips to step (G);\notherwise, it makes another protected resource request.\n(F) Since the access token is invalid, the resource server returns\nan invalid token error.\nHardt Standards Track [Page 11]\nRFC 6749 OAuth 2.0 October 2012\n(G) The client requests a new access token by authenticating with\nthe authorization server and presenting the refresh token. The\nclient authentication requirements are based on the client type\nand on the authorization server policies.\n(H) The authorization server authenticates the client and validates\nthe refresh token, and if valid, issues a new access token (and,\noptionally, a new refresh token).\nSteps (C), (D), (E), and (F) are outside the scope of this\nspecification, as described in Section 7.\n1.6. TLS Version\nWhenever Transport Layer Security (TLS) is used by this\nspecification, the appropriate version (or versions) of TLS will vary\nover time, based on the widespread deployment and known security\nvulnerabilities. At the time of this writing, TLS version 1.2\n[RFC5246] is the most recent version, but has a very limited\ndeployment base and might not be readily available for\nimplementation. TLS version 1.0 [RFC2246] is the most widely\ndeployed version and will provide the broadest interoperability.\nImplementations MAY also support additional transport-layer security\nmechanisms that meet their security requirements.\n1.7. HTTP Redirections\nThis specification makes extensive use of HTTP redirections, in which\nthe client or the authorization server directs the resource owner's\nuser-agent to another destination. While the examples in this\nspecification show the use of the HTTP 302 status code, any other\nmethod available via the user-agent to accomplish this redirection is\nallowed and is considered to be an implementation detail.\n1.8. Interoperability\nOAuth 2.0 provides a rich authorization framework with well-defined\nsecurity properties. However, as a rich and highly extensible\nframework with many optional components, on its own, this\nspecification is likely to produce a wide range of non-interoperable\nimplementations.\nIn addition, this specification leaves a few required components\npartially or fully undefined (e.g., client registration,\nauthorization server capabilities, endpoint discovery). Without\nHardt Standards Track [Page 12]\nRFC 6749 OAuth 2.0 October 2012\nthese components, clients must be manually and specifically\nconfigured against a specific authorization server and resource\nserver in order to interoperate.\nThis framework was designed with the clear expectation that future\nwork will define prescriptive profiles and extensions necessary to\nachieve full web-scale interoperability.\n1.9. Notational Conventions\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n\"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\nspecification are to be interpreted as described in [RFC2119].\nThis specification uses the Augmented Backus-Naur Form (ABNF)\nnotation of [RFC5234]. Additionally, the rule URI-reference is\nincluded from \"Uniform Resource Identifier (URI): Generic Syntax\"\n[RFC3986].\nCertain security-related terms are to be understood in the sense\ndefined in [RFC4949]. These terms include, but are not limited to,\n\"attack\", \"authentication\", \"authorization\", \"certificate\",\n\"confidentiality\", \"credential\", \"encryption\", \"identity\", \"sign\",\n\"signature\", \"trust\", \"validate\", and \"verify\".\nUnless otherwise noted, all the protocol parameter names and values\nare case sensitive.\n2. Client Registration\nBefore initiating the protocol, the client registers with the\nauthorization server. The means through which the client registers\nwith the authorization server are beyond the scope of this\nspecification but typically involve end-user interaction with an HTML\nregistration form.\nClient registration does not require a direct interaction between the\nclient and the authorization server. When supported by the\nauthorization server, registration can rely on other means for\nestablishing trust and obtaining the required client properties\n(e.g., redirection URI, client type). For example, registration can\nbe accomplished using a self-issued or third-party-issued assertion,\nor by the authorization server performing client discovery using a\ntrusted channel.\nHardt Standards Track [Page 13]\nRFC 6749 OAuth 2.0 October 2012\nWhen registering a client, the client developer SHALL:\no specify the client type as described in Section 2.1,\no provide its client redirection URIs as described in Section 3.1.2,\nand\no include any other information required by the authorization server\n(e.g., application name, website, description, logo image, the\nacceptance of legal terms).\n2.1. Client Types\nOAuth defines two client types, based on their ability to\nauthenticate securely with the authorization server (i.e., ability to\nmaintain the confidentiality of their client credentials):\nconfidential\nClients capable of maintaining the confidentiality of their\ncredentials (e.g., client implemented on a secure server with\nrestricted access to the client credentials), or capable of secure\nclient authentication using other means.\npublic\nClients incapable of maintaining the confidentiality of their\ncredentials (e.g., clients executing on the device used by the\nresource owner, such as an installed native application or a web\nbrowser-based application), and incapable of secure client\nauthentication via any other means.\nThe client type designation is based on the authorization server's\ndefinition of secure authentication and its acceptable exposure\nlevels of client credentials. The authorization server SHOULD NOT\nmake assumptions about the client type.\nA client may be implemented as a distributed set of components, each\nwith a different client type and security context (e.g., a\ndistributed client with both a confidential server-based component\nand a public browser-based component). If the authorization server\ndoes not provide support for such clients or does not provide\nguidance with regard to their registration, the client SHOULD\nregister each component as a separate client.\nHardt Standards Track [Page 14]\nRFC 6749 OAuth 2.0 October 2012\nThis specification has been designed around the following client\nprofiles:\nweb application\nA web application is a confidential client running on a web\nserver. Resource owners access the client via an HTML user\ninterface rendered in a user-agent on the device used by the\nresource owner. The client credentials as well as any access\ntoken issued to the client are stored on the web server and are\nnot exposed to or accessible by the resource owner.\nuser-agent-based application\nA user-agent-based application is a public client in which the\nclient code is downloaded from a web server and executes within a\nuser-agent (e.g., web browser) on the device used by the resource\nowner. Protocol data and credentials are easily accessible (and\noften visible) to the resource owner. Since such applications\nreside within the user-agent, they can make seamless use of the\nuser-agent capabilities when requesting authorization.\nnative application\nA native application is a public client installed and executed on\nthe device used by the resource owner. Protocol data and\ncredentials are accessible to the resource owner. It is assumed\nthat any client authentication credentials included in the\napplication can be extracted. On the other hand, dynamically\nissued credentials such as access tokens or refresh tokens can\nreceive an acceptable level of protection. At a minimum, these\ncredentials are protected from hostile servers with which the\napplication may interact. On some platforms, these credentials\nmight be protected from other applications residing on the same\ndevice.\n2.2. Client Identifier\nThe authorization server issues the registered client a client\nidentifier -- a unique string representing the registration\ninformation provided by the client. The client identifier is not a\nsecret; it is exposed to the resource owner and MUST NOT be used\nalone for client authentication. The client identifier is unique to\nthe authorization server.\nThe client identifier string size is left undefined by this\nspecification. The client should avoid making assumptions about the\nidentifier size. The authorization server SHOULD document the size\nof any identifier it issues.\nHardt Standards Track [Page 15]\nRFC 6749 OAuth 2.0 October 2012\n2.3. Client Authentication\nIf the client type is confidential, the client and authorization\nserver establish a client authentication method suitable for the\nsecurity requirements of the authorization server. The authorization\nserver MAY accept any form of client authentication meeting its\nsecurity requirements.\nConfidential clients are typically issued (or establish) a set of\nclient credentials used for authenticating with the authorization\nserver (e.g., password, public/private key pair).\nThe authorization server MAY establish a client authentication method\nwith public clients. However, the authorization server MUST NOT rely\non public client authentication for the purpose of identifying the\nclient.\nThe client MUST NOT use more than one authentication method in each\nrequest.\n2.3.1. Client Password\nClients in possession of a client password MAY use the HTTP Basic\nauthentication scheme as defined in [RFC2617] to authenticate with\nthe authorization server. The client identifier is encoded using the\n\"application/x-www-form-urlencoded\" encoding algorithm per\nAppendix B, and the encoded value is used as the username; the client\npassword is encoded using the same algorithm and used as the\npassword. The authorization server MUST support the HTTP Basic\nauthentication scheme for authenticating clients that were issued a\nclient password.\nFor example (with extra line breaks for display purposes only):\nAuthorization: Basic czZCaGRSa3F0Mzo3RmpmcDBaQnIxS3REUmJuZlZkbUl3\nAlternatively, the authorization server MAY support including the\nclient credentials in the request-body using the following\nparameters:\nclient_id\nREQUIRED. The client identifier issued to the client during\nthe registration process described by Section 2.2.\nclient_secret\nREQUIRED. The client secret. The client MAY omit the\nparameter if the client secret is an empty string.\nHardt Standards Track [Page 16]\nRFC 6749 OAuth 2.0 October 2012\nIncluding the client credentials in the request-body using the two\nparameters is NOT RECOMMENDED and SHOULD be limited to clients unable\nto directly utilize the HTTP Basic authentication scheme (or other\npassword-based HTTP authentication schemes). The parameters can only\nbe transmitted in the request-body and MUST NOT be included in the\nrequest URI.\nFor example, a request to refresh an access token (Section 6) using\nthe body parameters (with extra line breaks for display purposes\nonly):\nPOST /token HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\ngrant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n&client_id=s6BhdRkqt3&client_secret=7Fjfp0ZBr1KtDRbnfVdmIw\nThe authorization server MUST require the use of TLS as described in\nSection 1.6 when sending requests using password authentication.\nSince this client authentication method involves a password, the\nauthorization server MUST protect any endpoint utilizing it against\nbrute force attacks.\n2.3.2. Other Authentication Methods\nThe authorization server MAY support any suitable HTTP authentication\nscheme matching its security requirements. When using other\nauthentication methods, the authorization server MUST define a\nmapping between the client identifier (registration record) and\nauthentication scheme.\n2.4. Unregistered Clients\nThis specification does not exclude the use of unregistered clients.\nHowever, the use of such clients is beyond the scope of this\nspecification and requires additional security analysis and review of\nits interoperability impact.\nHardt Standards Track [Page 17]\nRFC 6749 OAuth 2.0 October 2012\n3. Protocol Endpoints\nThe authorization process utilizes two authorization server endpoints\n(HTTP resources):\no Authorization endpoint - used by the client to obtain\nauthorization from the resource owner via user-agent redirection.\no Token endpoint - used by the client to exchange an authorization\ngrant for an access token, typically with client authentication.\nAs well as one client endpoint:\no Redirection endpoint - used by the authorization server to return\nresponses containing authorization credentials to the client via\nthe resource owner user-agent.\nNot every authorization grant type utilizes both endpoints.\nExtension grant types MAY define additional endpoints as needed.\n3.1. Authorization Endpoint\nThe authorization endpoint is used to interact with the resource\nowner and obtain an authorization grant. The authorization server\nMUST first verify the identity of the resource owner. The way in\nwhich the authorization server authenticates the resource owner\n(e.g., username and password login, session cookies) is beyond the\nscope of this specification.\nThe means through which the client obtains the location of the\nauthorization endpoint are beyond the scope of this specification,\nbut the location is typically provided in the service documentation.\nThe endpoint URI MAY include an \"application/x-www-form-urlencoded\"\nformatted (per Appendix B) query component ([RFC3986] Section 3.4),\nwhich MUST be retained when adding additional query parameters. The\nendpoint URI MUST NOT include a fragment component.\nSince requests to the authorization endpoint result in user\nauthentication and the transmission of clear-text credentials (in the\nHTTP response), the authorization server MUST require the use of TLS\nas described in Section 1.6 when sending requests to the\nauthorization endpoint.\nThe authorization server MUST support the use of the HTTP \"GET\"\nmethod [RFC2616] for the authorization endpoint and MAY support the\nuse of the \"POST\" method as well.\nHardt Standards Track [Page 18]\nRFC 6749 OAuth 2.0 October 2012\nParameters sent without a value MUST be treated as if they were\nomitted from the request. The authorization server MUST ignore\nunrecognized request parameters. Request and response parameters\nMUST NOT be included more than once.\n3.1.1. Response Type\nThe authorization endpoint is used by the authorization code grant\ntype and implicit grant type flows. The client informs the\nauthorization server of the desired grant type using the following\nparameter:\nresponse_type\nREQUIRED. The value MUST be one of \"code\" for requesting an\nauthorization code as described by Section 4.1.1, \"token\" for\nrequesting an access token (implicit grant) as described by\nSection 4.2.1, or a registered extension value as described by\nSection 8.4.\nExtension response types MAY contain a space-delimited (%x20) list of\nvalues, where the order of values does not matter (e.g., response\ntype \"a b\" is the same as \"b a\"). The meaning of such composite\nresponse types is defined by their respective specifications.\nIf an authorization request is missing the \"response_type\" parameter,\nor if the response type is not understood, the authorization server\nMUST return an error response as described in Section 4.1.2.1.\n3.1.2. Redirection Endpoint\nAfter completing its interaction with the resource owner, the\nauthorization server directs the resource owner's user-agent back to\nthe client. The authorization server redirects the user-agent to the\nclient's redirection endpoint previously established with the\nauthorization server during the client registration process or when\nmaking the authorization request.\nThe redirection endpoint URI MUST be an absolute URI as defined by\n[RFC3986] Section 4.3. The endpoint URI MAY include an\n\"application/x-www-form-urlencoded\" formatted (per Appendix B) query\ncomponent ([RFC3986] Section 3.4), which MUST be retained when adding\nadditional query parameters. The endpoint URI MUST NOT include a\nfragment component.\nHardt Standards Track [Page 19]\nRFC 6749 OAuth 2.0 October 2012\n3.1.2.1. Endpoint Request Confidentiality\nThe redirection endpoint SHOULD require the use of TLS as described\nin Section 1.6 when the requested response type is \"code\" or \"token\",\nor when the redirection request will result in the transmission of\nsensitive credentials over an open network. This specification does\nnot mandate the use of TLS because at the time of this writing,\nrequiring clients to deploy TLS is a significant hurdle for many\nclient developers. If TLS is not available, the authorization server\nSHOULD warn the resource owner about the insecure endpoint prior to\nredirection (e.g., display a message during the authorization\nrequest).\nLack of transport-layer security can have a severe impact on the\nsecurity of the client and the protected resources it is authorized\nto access. The use of transport-layer security is particularly\ncritical when the authorization process is used as a form of\ndelegated end-user authentication by the client (e.g., third-party\nsign-in service).\n3.1.2.2. Registration Requirements\nThe authorization server MUST require the following clients to\nregister their redirection endpoint:\no Public clients.\no Confidential clients utilizing the implicit grant type.\nThe authorization server SHOULD require all clients to register their\nredirection endpoint prior to utilizing the authorization endpoint.\nThe authorization server SHOULD require the client to provide the\ncomplete redirection URI (the client MAY use the \"state\" request\nparameter to achieve per-request customization). If requiring the\nregistration of the complete redirection URI is not possible, the\nauthorization server SHOULD require the registration of the URI\nscheme, authority, and path (allowing the client to dynamically vary\nonly the query component of the redirection URI when requesting\nauthorization).\nThe authorization server MAY allow the client to register multiple\nredirection endpoints.\nLack of a redirection URI registration requirement can enable an\nattacker to use the authorization endpoint as an open redirector as\ndescribed in Section 10.15.\nHardt Standards Track [Page 20]\nRFC 6749 OAuth 2.0 October 2012\n3.1.2.3. Dynamic Configuration\nIf multiple redirection URIs have been registered, if only part of\nthe redirection URI has been registered, or if no redirection URI has\nbeen registered, the client MUST include a redirection URI with the\nauthorization request using the \"redirect_uri\" request parameter.\nWhen a redirection URI is included in an authorization request, the\nauthorization server MUST compare and match the value received\nagainst at least one of the registered redirection URIs (or URI\ncomponents) as defined in [RFC3986] Section 6, if any redirection\nURIs were registered. If the client registration included the full\nredirection URI, the authorization server MUST compare the two URIs\nusing simple string comparison as defined in [RFC3986] Section 6.2.1.\n3.1.2.4. Invalid Endpoint\nIf an authorization request fails validation due to a missing,\ninvalid, or mismatching redirection URI, the authorization server\nSHOULD inform the resource owner of the error and MUST NOT\nautomatically redirect the user-agent to the invalid redirection URI.\n3.1.2.5. Endpoint Content\nThe redirection request to the client's endpoint typically results in\nan HTML document response, processed by the user-agent. If the HTML\nresponse is served directly as the result of the redirection request,\nany script included in the HTML document will execute with full\naccess to the redirection URI and the credentials it contains.\nThe client SHOULD NOT include any third-party scripts (e.g., third-\nparty analytics, social plug-ins, ad networks) in the redirection\nendpoint response. Instead, it SHOULD extract the credentials from\nthe URI and redirect the user-agent again to another endpoint without\nexposing the credentials (in the URI or elsewhere). If third-party\nscripts are included, the client MUST ensure that its own scripts\n(used to extract and remove the credentials from the URI) will\nexecute first.\n3.2. Token Endpoint\nThe token endpoint is used by the client to obtain an access token by\npresenting its authorization grant or refresh token. The token\nendpoint is used with every authorization grant except for the\nimplicit grant type (since an access token is issued directly).\nHardt Standards Track [Page 21]\nRFC 6749 OAuth 2.0 October 2012\nThe means through which the client obtains the location of the token\nendpoint are beyond the scope of this specification, but the location\nis typically provided in the service documentation.\nThe endpoint URI MAY include an \"application/x-www-form-urlencoded\"\nformatted (per Appendix B) query component ([RFC3986] Section 3.4),\nwhich MUST be retained when adding additional query parameters. The\nendpoint URI MUST NOT include a fragment component.\nSince requests to the token endpoint result in the transmission of\nclear-text credentials (in the HTTP request and response), the\nauthorization server MUST require the use of TLS as described in\nSection 1.6 when sending requests to the token endpoint.\nThe client MUST use the HTTP \"POST\" method when making access token\nrequests.\nParameters sent without a value MUST be treated as if they were\nomitted from the request. The authorization server MUST ignore\nunrecognized request parameters. Request and response parameters\nMUST NOT be included more than once.\n3.2.1. Client Authentication\nConfidential clients or other clients issued client credentials MUST\nauthenticate with the authorization server as described in\nSection 2.3 when making requests to the token endpoint. Client\nauthentication is used for:\no Enforcing the binding of refresh tokens and authorization codes to\nthe client they were issued to. Client authentication is critical\nwhen an authorization code is transmitted to the redirection\nendpoint over an insecure channel or when the redirection URI has\nnot been registered in full.\no Recovering from a compromised client by disabling the client or\nchanging its credentials, thus preventing an attacker from abusing\nstolen refresh tokens. Changing a single set of client\ncredentials is significantly faster than revoking an entire set of\nrefresh tokens.\no Implementing authentication management best practices, which\nrequire periodic credential rotation. Rotation of an entire set\nof refresh tokens can be challenging, while rotation of a single\nset of client credentials is significantly easier.\nHardt Standards Track [Page 22]\nRFC 6749 OAuth 2.0 October 2012\nA client MAY use the \"client_id\" request parameter to identify itself\nwhen sending requests to the token endpoint. In the\n\"authorization_code\" \"grant_type\" request to the token endpoint, an\nunauthenticated client MUST send its \"client_id\" to prevent itself\nfrom inadvertently accepting a code intended for a client with a\ndifferent \"client_id\". This protects the client from substitution of\nthe authentication code. (It provides no additional security for the\nprotected resource.)\n3.3. Access Token Scope\nThe authorization and token endpoints allow the client to specify the\nscope of the access request using the \"scope\" request parameter. In\nturn, the authorization server uses the \"scope\" response parameter to\ninform the client of the scope of the access token issued.\nThe value of the scope parameter is expressed as a list of space-\ndelimited, case-sensitive strings. The strings are defined by the\nauthorization server. If the value contains multiple space-delimited\nstrings, their order does not matter, and each string adds an\nadditional access range to the requested scope.\nscope = scope-token *( SP scope-token )\nscope-token = 1*( %x21 / %x23-5B / %x5D-7E )\nThe authorization server MAY fully or partially ignore the scope\nrequested by the client, based on the authorization server policy or\nthe resource owner's instructions. If the issued access token scope\nis different from the one requested by the client, the authorization\nserver MUST include the \"scope\" response parameter to inform the\nclient of the actual scope granted.\nIf the client omits the scope parameter when requesting\nauthorization, the authorization server MUST either process the\nrequest using a pre-defined default value or fail the request\nindicating an invalid scope. The authorization server SHOULD\ndocument its scope requirements and default value (if defined).\n4. Obtaining Authorization\nTo request an access token, the client obtains authorization from the\nresource owner. The authorization is expressed in the form of an\nauthorization grant, which the client uses to request the access\ntoken. OAuth defines four grant types: authorization code, implicit,\nresource owner password credentials, and client credentials. It also\nprovides an extension mechanism for defining additional grant types.\nHardt Standards Track [Page 23]\nRFC 6749 OAuth 2.0 October 2012\n4.1. Authorization Code Grant\nThe authorization code grant type is used to obtain both access\ntokens and refresh tokens and is optimized for confidential clients.\nSince this is a redirection-based flow, the client must be capable of\ninteracting with the resource owner's user-agent (typically a web\nbrowser) and capable of receiving incoming requests (via redirection)\nfrom the authorization server.\n+----------+\n| Resource |\n| Owner |\n| |\n+----------+\n^\n|\n(B)\n+----|-----+ Client Identifier +---------------+\n| -+----(A)-- & Redirection URI ---->| |\n| User- | | Authorization |\n| Agent -+----(B)-- User authenticates --->| Server |\n| | | |\n| -+----(C)-- Authorization Code ---<| |\n+-|----|---+ +---------------+\n| | ^ v\n(A) (C) | |\n| | | |\n^ v | |\n+---------+ | |\n| |>---(D)-- Authorization Code ---------' |\n| Client | & Redirection URI |\n| | |\n| |<---(E)----- Access Token -------------------'\n+---------+ (w/ Optional Refresh Token)\nNote: The lines illustrating steps (A), (B), and (C) are broken into\ntwo parts as they pass through the user-agent.\nFigure 3: Authorization Code Flow\nHardt Standards Track [Page 24]\nRFC 6749 OAuth 2.0 October 2012\nThe flow illustrated in Figure 3 includes the following steps:\n(A) The client initiates the flow by directing the resource owner's\nuser-agent to the authorization endpoint. The client includes\nits client identifier, requested scope, local state, and a\nredirection URI to which the authorization server will send the\nuser-agent back once access is granted (or denied).\n(B) The authorization server authenticates the resource owner (via\nthe user-agent) and establishes whether the resource owner\ngrants or denies the client's access request.\n(C) Assuming the resource owner grants access, the authorization\nserver redirects the user-agent back to the client using the\nredirection URI provided earlier (in the request or during\nclient registration). The redirection URI includes an\nauthorization code and any local state provided by the client\nearlier.\n(D) The client requests an access token from the authorization\nserver's token endpoint by including the authorization code\nreceived in the previous step. When making the request, the\nclient authenticates with the authorization server. The client\nincludes the redirection URI used to obtain the authorization\ncode for verification.\n(E) The authorization server authenticates the client, validates the\nauthorization code, and ensures that the redirection URI\nreceived matches the URI used to redirect the client in\nstep (C). If valid, the authorization server responds back with\nan access token and, optionally, a refresh token.\n4.1.1. Authorization Request\nThe client constructs the request URI by adding the following\nparameters to the query component of the authorization endpoint URI\nusing the \"application/x-www-form-urlencoded\" format, per Appendix B:\nresponse_type\nREQUIRED. Value MUST be set to \"code\".\nclient_id\nREQUIRED. The client identifier as described in Section 2.2.\nredirect_uri\nOPTIONAL. As described in Section 3.1.2.\nHardt Standards Track [Page 25]\nRFC 6749 OAuth 2.0 October 2012\nscope\nOPTIONAL. The scope of the access request as described by\nSection 3.3.\nstate\nRECOMMENDED. An opaque value used by the client to maintain\nstate between the request and callback. The authorization\nserver includes this value when redirecting the user-agent back\nto the client. The parameter SHOULD be used for preventing\ncross-site request forgery as described in Section 10.12.\nThe client directs the resource owner to the constructed URI using an\nHTTP redirection response, or by other means available to it via the\nuser-agent.\nFor example, the client directs the user-agent to make the following\nHTTP request using TLS (with extra line breaks for display purposes\nonly):\nGET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\n&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\nHost: server.example.com\nThe authorization server validates the request to ensure that all\nrequired parameters are present and valid. If the request is valid,\nthe authorization server authenticates the resource owner and obtains\nan authorization decision (by asking the resource owner or by\nestablishing approval via other means).\nWhen a decision is established, the authorization server directs the\nuser-agent to the provided client redirection URI using an HTTP\nredirection response, or by other means available to it via the\nuser-agent.\n4.1.2. Authorization Response\nIf the resource owner grants the access request, the authorization\nserver issues an authorization code and delivers it to the client by\nadding the following parameters to the query component of the\nredirection URI using the \"application/x-www-form-urlencoded\" format,\nper Appendix B:\ncode\nREQUIRED. The authorization code generated by the\nauthorization server. The authorization code MUST expire\nshortly after it is issued to mitigate the risk of leaks. A\nmaximum authorization code lifetime of 10 minutes is\nRECOMMENDED. The client MUST NOT use the authorization code\nHardt Standards Track [Page 26]\nRFC 6749 OAuth 2.0 October 2012\nmore than once. If an authorization code is used more than\nonce, the authorization server MUST deny the request and SHOULD\nrevoke (when possible) all tokens previously issued based on\nthat authorization code. The authorization code is bound to\nthe client identifier and redirection URI.\nstate\nREQUIRED if the \"state\" parameter was present in the client\nauthorization request. The exact value received from the\nclient.\nFor example, the authorization server redirects the user-agent by\nsending the following HTTP response:\nHTTP/1.1 302 Found\nLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n&state=xyz\nThe client MUST ignore unrecognized response parameters. The\nauthorization code string size is left undefined by this\nspecification. The client should avoid making assumptions about code\nvalue sizes. The authorization server SHOULD document the size of\nany value it issues.\n4.1.2.1. Error Response\nIf the request fails due to a missing, invalid, or mismatching\nredirection URI, or if the client identifier is missing or invalid,\nthe authorization server SHOULD inform the resource owner of the\nerror and MUST NOT automatically redirect the user-agent to the\ninvalid redirection URI.\nIf the resource owner denies the access request or if the request\nfails for reasons other than a missing or invalid redirection URI,\nthe authorization server informs the client by adding the following\nparameters to the query component of the redirection URI using the\n\"application/x-www-form-urlencoded\" format, per Appendix B:\nerror\nREQUIRED. A single ASCII [USASCII] error code from the\nfollowing:\ninvalid_request\nThe request is missing a required parameter, includes an\ninvalid parameter value, includes a parameter more than\nonce, or is otherwise malformed.\nHardt Standards Track [Page 27]\nRFC 6749 OAuth 2.0 October 2012\nunauthorized_client\nThe client is not authorized to request an authorization\ncode using this method.\naccess_denied\nThe resource owner or authorization server denied the\nrequest.\nunsupported_response_type\nThe authorization server does not support obtaining an\nauthorization code using this method.\ninvalid_scope\nThe requested scope is invalid, unknown, or malformed.\nserver_error\nThe authorization server encountered an unexpected\ncondition that prevented it from fulfilling the request.\n(This error code is needed because a 500 Internal Server\nError HTTP status code cannot be returned to the client\nvia an HTTP redirect.)\ntemporarily_unavailable\nThe authorization server is currently unable to handle\nthe request due to a temporary overloading or maintenance\nof the server. (This error code is needed because a 503\nService Unavailable HTTP status code cannot be returned\nto the client via an HTTP redirect.)\nValues for the \"error\" parameter MUST NOT include characters\noutside the set %x20-21 / %x23-5B / %x5D-7E.\nerror_description\nOPTIONAL. Human-readable ASCII [USASCII] text providing\nadditional information, used to assist the client developer in\nunderstanding the error that occurred.\nValues for the \"error_description\" parameter MUST NOT include\ncharacters outside the set %x20-21 / %x23-5B / %x5D-7E.\nerror_uri\nOPTIONAL. A URI identifying a human-readable web page with\ninformation about the error, used to provide the client\ndeveloper with additional information about the error.\nValues for the \"error_uri\" parameter MUST conform to the\nURI-reference syntax and thus MUST NOT include characters\noutside the set %x21 / %x23-5B / %x5D-7E.\nHardt Standards Track [Page 28]\nRFC 6749 OAuth 2.0 October 2012\nstate\nREQUIRED if a \"state\" parameter was present in the client\nauthorization request. The exact value received from the\nclient.\nFor example, the authorization server redirects the user-agent by\nsending the following HTTP response:\nHTTP/1.1 302 Found\nLocation: https://client.example.com/cb?error=access_denied&state=xyz\n4.1.3. Access Token Request\nThe client makes a request to the token endpoint by sending the\nfollowing parameters using the \"application/x-www-form-urlencoded\"\nformat per Appendix B with a character encoding of UTF-8 in the HTTP\nrequest entity-body:\ngrant_type\nREQUIRED. Value MUST be set to \"authorization_code\".\ncode\nREQUIRED. The authorization code received from the\nauthorization server.\nredirect_uri\nREQUIRED, if the \"redirect_uri\" parameter was included in the\nauthorization request as described in Section 4.1.1, and their\nvalues MUST be identical.\nclient_id\nREQUIRED, if the client is not authenticating with the\nauthorization server as described in Section 3.2.1.\nIf the client type is confidential or the client was issued client\ncredentials (or assigned other authentication requirements), the\nclient MUST authenticate with the authorization server as described\nin Section 3.2.1.\nHardt Standards Track [Page 29]\nRFC 6749 OAuth 2.0 October 2012\nFor example, the client makes the following HTTP request using TLS\n(with extra line breaks for display purposes only):\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\ngrant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\nThe authorization server MUST:\no require client authentication for confidential clients or for any\nclient that was issued client credentials (or with other\nauthentication requirements),\no authenticate the client if client authentication is included,\no ensure that the authorization code was issued to the authenticated\nconfidential client, or if the client is public, ensure that the\ncode was issued to \"client_id\" in the request,\no verify that the authorization code is valid, and\no ensure that the \"redirect_uri\" parameter is present if the\n\"redirect_uri\" parameter was included in the initial authorization\nrequest as described in Section 4.1.1, and if included ensure that\ntheir values are identical.\n4.1.4. Access Token Response\nIf the access token request is valid and authorized, the\nauthorization server issues an access token and optional refresh\ntoken as described in Section 5.1. If the request client\nauthentication failed or is invalid, the authorization server returns\nan error response as described in Section 5.2.\nHardt Standards Track [Page 30]\nRFC 6749 OAuth 2.0 October 2012\nAn example successful response:\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n{\n\"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n\"token_type\":\"example\",\n\"expires_in\":3600,\n\"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n\"example_parameter\":\"example_value\"\n}\n4.2. Implicit Grant\nThe implicit grant type is used to obtain access tokens (it does not\nsupport the issuance of refresh tokens) and is optimized for public\nclients known to operate a particular redirection URI. These clients\nare typically implemented in a browser using a scripting language\nsuch as JavaScript.\nSince this is a redirection-based flow, the client must be capable of\ninteracting with the resource owner's user-agent (typically a web\nbrowser) and capable of receiving incoming requests (via redirection)\nfrom the authorization server.\nUnlike the authorization code grant type, in which the client makes\nseparate requests for authorization and for an access token, the\nclient receives the access token as the result of the authorization\nrequest.\nThe implicit grant type does not include client authentication, and\nrelies on the presence of the resource owner and the registration of\nthe redirection URI. Because the access token is encoded into the\nredirection URI, it may be exposed to the resource owner and other\napplications residing on the same device.\nHardt Standards Track [Page 31]\nRFC 6749 OAuth 2.0 October 2012\n+----------+\n| Resource |\n| Owner |\n| |\n+----------+\n^\n|\n(B)\n+----|-----+ Client Identifier +---------------+\n| -+----(A)-- & Redirection URI --->| |\n| User- | | Authorization |\n| Agent -|----(B)-- User authenticates -->| Server |\n| | | |\n| |<---(C)--- Redirection URI ----<| |\n| | with Access Token +---------------+\n| | in Fragment\n| | +---------------+\n| |----(D)--- Redirection URI ---->| Web-Hosted |\n| | without Fragment | Client |\n| | | Resource |\n| (F) |<---(E)------- Script ---------<| |\n| | +---------------+\n+-|--------+\n| |\n(A) (G) Access Token\n| |\n^ v\n+---------+\n| |\n| Client |\n| |\n+---------+\nNote: The lines illustrating steps (A) and (B) are broken into two\nparts as they pass through the user-agent.\nFigure 4: Implicit Grant Flow\nHardt Standards Track [Page 32]\nRFC 6749 OAuth 2.0 October 2012\nThe flow illustrated in Figure 4 includes the following steps:\n(A) The client initiates the flow by directing the resource owner's\nuser-agent to the authorization endpoint. The client includes\nits client identifier, requested scope, local state, and a\nredirection URI to which the authorization server will send the\nuser-agent back once access is granted (or denied).\n(B) The authorization server authenticates the resource owner (via\nthe user-agent) and establishes whether the resource owner\ngrants or denies the client's access request.\n(C) Assuming the resource owner grants access, the authorization\nserver redirects the user-agent back to the client using the\nredirection URI provided earlier. The redirection URI includes\nthe access token in the URI fragment.\n(D) The user-agent follows the redirection instructions by making a\nrequest to the web-hosted client resource (which does not\ninclude the fragment per [RFC2616]). The user-agent retains the\nfragment information locally.\n(E) The web-hosted client resource returns a web page (typically an\nHTML document with an embedded script) capable of accessing the\nfull redirection URI including the fragment retained by the\nuser-agent, and extracting the access token (and other\nparameters) contained in the fragment.\n(F) The user-agent executes the script provided by the web-hosted\nclient resource locally, which extracts the access token.\n(G) The user-agent passes the access token to the client.\nSee Sections 1.3.2 and 9 for background on using the implicit grant.\nSee Sections 10.3 and 10.16 for important security considerations\nwhen using the implicit grant.\n4.2.1. Authorization Request\nThe client constructs the request URI by adding the following\nparameters to the query component of the authorization endpoint URI\nusing the \"application/x-www-form-urlencoded\" format, per Appendix B:\nresponse_type\nREQUIRED. Value MUST be set to \"token\".\nclient_id\nREQUIRED. The client identifier as described in Section 2.2.\nHardt Standards Track [Page 33]\nRFC 6749 OAuth 2.0 October 2012\nredirect_uri\nOPTIONAL. As described in Section 3.1.2.\nscope\nOPTIONAL. The scope of the access request as described by\nSection 3.3.\nstate\nRECOMMENDED. An opaque value used by the client to maintain\nstate between the request and callback. The authorization\nserver includes this value when redirecting the user-agent back\nto the client. The parameter SHOULD be used for preventing\ncross-site request forgery as described in Section 10.12.\nThe client directs the resource owner to the constructed URI using an\nHTTP redirection response, or by other means available to it via the\nuser-agent.\nFor example, the client directs the user-agent to make the following\nHTTP request using TLS (with extra line breaks for display purposes\nonly):\nGET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz\n&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\nHost: server.example.com\nThe authorization server validates the request to ensure that all\nrequired parameters are present and valid. The authorization server\nMUST verify that the redirection URI to which it will redirect the\naccess token matches a redirection URI registered by the client as\ndescribed in Section 3.1.2.\nIf the request is valid, the authorization server authenticates the\nresource owner and obtains an authorization decision (by asking the\nresource owner or by establishing approval via other means).\nWhen a decision is established, the authorization server directs the\nuser-agent to the provided client redirection URI using an HTTP\nredirection response, or by other means available to it via the\nuser-agent.\nHardt Standards Track [Page 34]\nRFC 6749 OAuth 2.0 October 2012\n4.2.2. Access Token Response\nIf the resource owner grants the access request, the authorization\nserver issues an access token and delivers it to the client by adding\nthe following parameters to the fragment component of the redirection\nURI using the \"application/x-www-form-urlencoded\" format, per\nAppendix B:\naccess_token\nREQUIRED. The access token issued by the authorization server.\ntoken_type\nREQUIRED. The type of the token issued as described in\nSection 7.1. Value is case insensitive.\nexpires_in\nRECOMMENDED. The lifetime in seconds of the access token. For\nexample, the value \"3600\" denotes that the access token will\nexpire in one hour from the time the response was generated.\nIf omitted, the authorization server SHOULD provide the\nexpiration time via other means or document the default value.\nscope\nOPTIONAL, if identical to the scope requested by the client;\notherwise, REQUIRED. The scope of the access token as\ndescribed by Section 3.3.\nstate\nREQUIRED if the \"state\" parameter was present in the client\nauthorization request. The exact value received from the\nclient.\nThe authorization server MUST NOT issue a refresh token.\nFor example, the authorization server redirects the user-agent by\nsending the following HTTP response (with extra line breaks for\ndisplay purposes only):\nHTTP/1.1 302 Found\nLocation: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA\n&state=xyz&token_type=example&expires_in=3600\nDevelopers should note that some user-agents do not support the\ninclusion of a fragment component in the HTTP \"Location\" response\nheader field. Such clients will require using other methods for\nredirecting the client than a 3xx redirection response -- for\nexample, returning an HTML page that includes a 'continue' button\nwith an action linked to the redirection URI.\nHardt Standards Track [Page 35]\nRFC 6749 OAuth 2.0 October 2012\nThe client MUST ignore unrecognized response parameters. The access\ntoken string size is left undefined by this specification. The\nclient should avoid making assumptions about value sizes. The\nauthorization server SHOULD document the size of any value it issues.\n4.2.2.1. Error Response\nIf the request fails due to a missing, invalid, or mismatching\nredirection URI, or if the client identifier is missing or invalid,\nthe authorization server SHOULD inform the resource owner of the\nerror and MUST NOT automatically redirect the user-agent to the\ninvalid redirection URI.\nIf the resource owner denies the access request or if the request\nfails for reasons other than a missing or invalid redirection URI,\nthe authorization server informs the client by adding the following\nparameters to the fragment component of the redirection URI using the\n\"application/x-www-form-urlencoded\" format, per Appendix B:\nerror\nREQUIRED. A single ASCII [USASCII] error code from the\nfollowing:\ninvalid_request\nThe request is missing a required parameter, includes an\ninvalid parameter value, includes a parameter more than\nonce, or is otherwise malformed.\nunauthorized_client\nThe client is not authorized to request an access token\nusing this method.\naccess_denied\nThe resource owner or authorization server denied the\nrequest.\nunsupported_response_type\nThe authorization server does not support obtaining an\naccess token using this method.\ninvalid_scope\nThe requested scope is invalid, unknown, or malformed.\nHardt Standards Track [Page 36]\nRFC 6749 OAuth 2.0 October 2012\nserver_error\nThe authorization server encountered an unexpected\ncondition that prevented it from fulfilling the request.\n(This error code is needed because a 500 Internal Server\nError HTTP status code cannot be returned to the client\nvia an HTTP redirect.)\ntemporarily_unavailable\nThe authorization server is currently unable to handle\nthe request due to a temporary overloading or maintenance\nof the server. (This error code is needed because a 503\nService Unavailable HTTP status code cannot be returned\nto the client via an HTTP redirect.)\nValues for the \"error\" parameter MUST NOT include characters\noutside the set %x20-21 / %x23-5B / %x5D-7E.\nerror_description\nOPTIONAL. Human-readable ASCII [USASCII] text providing\nadditional information, used to assist the client developer in\nunderstanding the error that occurred.\nValues for the \"error_description\" parameter MUST NOT include\ncharacters outside the set %x20-21 / %x23-5B / %x5D-7E.\nerror_uri\nOPTIONAL. A URI identifying a human-readable web page with\ninformation about the error, used to provide the client\ndeveloper with additional information about the error.\nValues for the \"error_uri\" parameter MUST conform to the\nURI-reference syntax and thus MUST NOT include characters\noutside the set %x21 / %x23-5B / %x5D-7E.\nstate\nREQUIRED if a \"state\" parameter was present in the client\nauthorization request. The exact value received from the\nclient.\nFor example, the authorization server redirects the user-agent by\nsending the following HTTP response:\nHTTP/1.1 302 Found\nLocation: https://client.example.com/cb#error=access_denied&state=xyz\n4.3. Resource Owner Password Credentials Grant\nThe resource owner password credentials grant type is suitable in\ncases where the resource owner has a trust relationship with the\nclient, such as the device operating system or a highly privileged\nHardt Standards Track [Page 37]\nRFC 6749 OAuth 2.0 October 2012\napplication. The authorization server should take special care when\nenabling this grant type and only allow it when other flows are not\nviable.\nThis grant type is suitable for clients capable of obtaining the\nresource owner's credentials (username and password, typically using\nan interactive form). It is also used to migrate existing clients\nusing direct authentication schemes such as HTTP Basic or Digest\nauthentication to OAuth by converting the stored credentials to an\naccess token.\n+----------+\n| Resource |\n| Owner |\n| |\n+----------+\nv\n| Resource Owner\n(A) Password Credentials\n|\nv\n+---------+ +---------------+\n| |>--(B)---- Resource Owner ------->| |\n| | Password Credentials | Authorization |\n| Client | | Server |\n| |<--(C)---- Access Token ---------<| |\n| | (w/ Optional Refresh Token) | |\n+---------+ +---------------+\nFigure 5: Resource Owner Password Credentials Flow\nThe flow illustrated in Figure 5 includes the following steps:\n(A) The resource owner provides the client with its username and\npassword.\n(B) The client requests an access token from the authorization\nserver's token endpoint by including the credentials received\nfrom the resource owner. When making the request, the client\nauthenticates with the authorization server.\n(C) The authorization server authenticates the client and validates\nthe resource owner credentials, and if valid, issues an access\ntoken.\nHardt Standards Track [Page 38]\nRFC 6749 OAuth 2.0 October 2012\n4.3.1. Authorization Request and Response\nThe method through which the client obtains the resource owner\ncredentials is beyond the scope of this specification. The client\nMUST discard the credentials once an access token has been obtained.\n4.3.2. Access Token Request\nThe client makes a request to the token endpoint by adding the\nfollowing parameters using the \"application/x-www-form-urlencoded\"\nformat per Appendix B with a character encoding of UTF-8 in the HTTP\nrequest entity-body:\ngrant_type\nREQUIRED. Value MUST be set to \"password\".\nusername\nREQUIRED. The resource owner username.\npassword\nREQUIRED. The resource owner password.\nscope\nOPTIONAL. The scope of the access request as described by\nSection 3.3.\nIf the client type is confidential or the client was issued client\ncredentials (or assigned other authentication requirements), the\nclient MUST authenticate with the authorization server as described\nin Section 3.2.1.\nFor example, the client makes the following HTTP request using\ntransport-layer security (with extra line breaks for display purposes\nonly):\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\ngrant_type=password&username=johndoe&password=A3ddj3w\nHardt Standards Track [Page 39]\nRFC 6749 OAuth 2.0 October 2012\nThe authorization server MUST:\no require client authentication for confidential clients or for any\nclient that was issued client credentials (or with other\nauthentication requirements),\no authenticate the client if client authentication is included, and\no validate the resource owner password credentials using its\nexisting password validation algorithm.\nSince this access token request utilizes the resource owner's\npassword, the authorization server MUST protect the endpoint against\nbrute force attacks (e.g., using rate-limitation or generating\nalerts).\n4.3.3. Access Token Response\nIf the access token request is valid and authorized, the\nauthorization server issues an access token and optional refresh\ntoken as described in Section 5.1. If the request failed client\nauthentication or is invalid, the authorization server returns an\nerror response as described in Section 5.2.\nAn example successful response:\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n{\n\"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n\"token_type\":\"example\",\n\"expires_in\":3600,\n\"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n\"example_parameter\":\"example_value\"\n}\n4.4. Client Credentials Grant\nThe client can request an access token using only its client\ncredentials (or other supported means of authentication) when the\nclient is requesting access to the protected resources under its\ncontrol, or those of another resource owner that have been previously\narranged with the authorization server (the method of which is beyond\nthe scope of this specification).\nHardt Standards Track [Page 40]\nRFC 6749 OAuth 2.0 October 2012\nThe client credentials grant type MUST only be used by confidential\nclients.\n+---------+ +---------------+\n| | | |\n| |>--(A)- Client Authentication --->| Authorization |\n| Client | | Server |\n| |<--(B)---- Access Token ---------<| |\n| | | |\n+---------+ +---------------+\nFigure 6: Client Credentials Flow\nThe flow illustrated in Figure 6 includes the following steps:\n(A) The client authenticates with the authorization server and\nrequests an access token from the token endpoint.\n(B) The authorization server authenticates the client, and if valid,\nissues an access token.\n4.4.1. Authorization Request and Response\nSince the client authentication is used as the authorization grant,\nno additional authorization request is needed.\n4.4.2. Access Token Request\nThe client makes a request to the token endpoint by adding the\nfollowing parameters using the \"application/x-www-form-urlencoded\"\nformat per Appendix B with a character encoding of UTF-8 in the HTTP\nrequest entity-body:\ngrant_type\nREQUIRED. Value MUST be set to \"client_credentials\".\nscope\nOPTIONAL. The scope of the access request as described by\nSection 3.3.\nThe client MUST authenticate with the authorization server as\ndescribed in Section 3.2.1.\nHardt Standards Track [Page 41]\nRFC 6749 OAuth 2.0 October 2012\nFor example, the client makes the following HTTP request using\ntransport-layer security (with extra line breaks for display purposes\nonly):\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\ngrant_type=client_credentials\nThe authorization server MUST authenticate the client.\n4.4.3. Access Token Response\nIf the access token request is valid and authorized, the\nauthorization server issues an access token as described in\nSection 5.1. A refresh token SHOULD NOT be included. If the request\nfailed client authentication or is invalid, the authorization server\nreturns an error response as described in Section 5.2.\nAn example successful response:\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n{\n\"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n\"token_type\":\"example\",\n\"expires_in\":3600,\n\"example_parameter\":\"example_value\"\n}\n4.5. Extension Grants\nThe client uses an extension grant type by specifying the grant type\nusing an absolute URI (defined by the authorization server) as the\nvalue of the \"grant_type\" parameter of the token endpoint, and by\nadding any additional parameters necessary.\nHardt Standards Track [Page 42]\nRFC 6749 OAuth 2.0 October 2012\nFor example, to request an access token using a Security Assertion\nMarkup Language (SAML) 2.0 assertion grant type as defined by\n[OAuth-SAML2], the client could make the following HTTP request using\nTLS (with extra line breaks for display purposes only):\nPOST /token HTTP/1.1\nHost: server.example.com\nContent-Type: application/x-www-form-urlencoded\ngrant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Asaml2-\nbearer&assertion=PEFzc2VydGlvbiBJc3N1ZUluc3RhbnQ9IjIwMTEtMDU\n[...omitted for brevity...]aG5TdGF0ZW1lbnQ-PC9Bc3NlcnRpb24-\nIf the access token request is valid and authorized, the\nauthorization server issues an access token and optional refresh\ntoken as described in Section 5.1. If the request failed client\nauthentication or is invalid, the authorization server returns an\nerror response as described in Section 5.2.\n5. Issuing an Access Token\nIf the access token request is valid and authorized, the\nauthorization server issues an access token and optional refresh\ntoken as described in Section 5.1. If the request failed client\nauthentication or is invalid, the authorization server returns an\nerror response as described in Section 5.2.\n5.1. Successful Response\nThe authorization server issues an access token and optional refresh\ntoken, and constructs the response by adding the following parameters\nto the entity-body of the HTTP response with a 200 (OK) status code:\naccess_token\nREQUIRED. The access token issued by the authorization server.\ntoken_type\nREQUIRED. The type of the token issued as described in\nSection 7.1. Value is case insensitive.\nexpires_in\nRECOMMENDED. The lifetime in seconds of the access token. For\nexample, the value \"3600\" denotes that the access token will\nexpire in one hour from the time the response was generated.\nIf omitted, the authorization server SHOULD provide the\nexpiration time via other means or document the default value.\nHardt Standards Track [Page 43]\nRFC 6749 OAuth 2.0 October 2012\nrefresh_token\nOPTIONAL. The refresh token, which can be used to obtain new\naccess tokens using the same authorization grant as described\nin Section 6.\nscope\nOPTIONAL, if identical to the scope requested by the client;\notherwise, REQUIRED. The scope of the access token as\ndescribed by Section 3.3.\nThe parameters are included in the entity-body of the HTTP response\nusing the \"application/json\" media type as defined by [RFC4627]. The\nparameters are serialized into a JavaScript Object Notation (JSON)\nstructure by adding each parameter at the highest structure level.\nParameter names and string values are included as JSON strings.\nNumerical values are included as JSON numbers. The order of\nparameters does not matter and can vary.\nThe authorization server MUST include the HTTP \"Cache-Control\"\nresponse header field [RFC2616] with a value of \"no-store\" in any\nresponse containing tokens, credentials, or other sensitive\ninformation, as well as the \"Pragma\" response header field [RFC2616]\nwith a value of \"no-cache\".\nFor example:\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n{\n\"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n\"token_type\":\"example\",\n\"expires_in\":3600,\n\"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n\"example_parameter\":\"example_value\"\n}\nThe client MUST ignore unrecognized value names in the response. The\nsizes of tokens and other values received from the authorization\nserver are left undefined. The client should avoid making\nassumptions about value sizes. The authorization server SHOULD\ndocument the size of any value it issues.\nHardt Standards Track [Page 44]\nRFC 6749 OAuth 2.0 October 2012\n5.2. Error Response\nThe authorization server responds with an HTTP 400 (Bad Request)\nstatus code (unless specified otherwise) and includes the following\nparameters with the response:\nerror\nREQUIRED. A single ASCII [USASCII] error code from the\nfollowing:\ninvalid_request\nThe request is missing a required parameter, includes an\nunsupported parameter value (other than grant type),\nrepeats a parameter, includes multiple credentials,\nutilizes more than one mechanism for authenticating the\nclient, or is otherwise malformed.\ninvalid_client\nClient authentication failed (e.g., unknown client, no\nclient authentication included, or unsupported\nauthentication method). The authorization server MAY\nreturn an HTTP 401 (Unauthorized) status code to indicate\nwhich HTTP authentication schemes are supported. If the\nclient attempted to authenticate via the \"Authorization\"\nrequest header field, the authorization server MUST\nrespond with an HTTP 401 (Unauthorized) status code and\ninclude the \"WWW-Authenticate\" response header field\nmatching the authentication scheme used by the client.\ninvalid_grant\nThe provided authorization grant (e.g., authorization\ncode, resource owner credentials) or refresh token is\ninvalid, expired, revoked, does not match the redirection\nURI used in the authorization request, or was issued to\nanother client.\nunauthorized_client\nThe authenticated client is not authorized to use this\nauthorization grant type.\nunsupported_grant_type\nThe authorization grant type is not supported by the\nauthorization server.\nHardt Standards Track [Page 45]\nRFC 6749 OAuth 2.0 October 2012\ninvalid_scope\nThe requested scope is invalid, unknown, malformed, or\nexceeds the scope granted by the resource owner.\nValues for the \"error\" parameter MUST NOT include characters\noutside the set %x20-21 / %x23-5B / %x5D-7E.\nerror_description\nOPTIONAL. Human-readable ASCII [USASCII] text providing\nadditional information, used to assist the client developer in\nunderstanding the error that occurred.\nValues for the \"error_description\" parameter MUST NOT include\ncharacters outside the set %x20-21 / %x23-5B / %x5D-7E.\nerror_uri\nOPTIONAL. A URI identifying a human-readable web page with\ninformation about the error, used to provide the client\ndeveloper with additional information about the error.\nValues for the \"error_uri\" parameter MUST conform to the\nURI-reference syntax and thus MUST NOT include characters\noutside the set %x21 / %x23-5B / %x5D-7E.\nThe parameters are included in the entity-body of the HTTP response\nusing the \"application/json\" media type as defined by [RFC4627]. The\nparameters are serialized into a JSON structure by adding each\nparameter at the highest structure level. Parameter names and string\nvalues are included as JSON strings. Numerical values are included\nas JSON numbers. The order of parameters does not matter and can\nvary.\nFor example:\nHTTP/1.1 400 Bad Request\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n{\n\"error\":\"invalid_request\"\n}\nHardt Standards Track [Page 46]\nRFC 6749 OAuth 2.0 October 2012\n6. Refreshing an Access Token\nIf the authorization server issued a refresh token to the client, the\nclient makes a refresh request to the token endpoint by adding the\nfollowing parameters using the \"application/x-www-form-urlencoded\"\nformat per Appendix B with a character encoding of UTF-8 in the HTTP\nrequest entity-body:\ngrant_type\nREQUIRED. Value MUST be set to \"refresh_token\".\nrefresh_token\nREQUIRED. The refresh token issued to the client.\nscope\nOPTIONAL. The scope of the access request as described by\nSection 3.3. The requested scope MUST NOT include any scope\nnot originally granted by the resource owner, and if omitted is\ntreated as equal to the scope originally granted by the\nresource owner.\nBecause refresh tokens are typically long-lasting credentials used to\nrequest additional access tokens, the refresh token is bound to the\nclient to which it was issued. If the client type is confidential or\nthe client was issued client credentials (or assigned other\nauthentication requirements), the client MUST authenticate with the\nauthorization server as described in Section 3.2.1.\nFor example, the client makes the following HTTP request using\ntransport-layer security (with extra line breaks for display purposes\nonly):\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\ngrant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\nHardt Standards Track [Page 47]\nRFC 6749 OAuth 2.0 October 2012\nThe authorization server MUST:\no require client authentication for confidential clients or for any\nclient that was issued client credentials (or with other\nauthentication requirements),\no authenticate the client if client authentication is included and\nensure that the refresh token was issued to the authenticated\nclient, and\no validate the refresh token.\nIf valid and authorized, the authorization server issues an access\ntoken as described in Section 5.1. If the request failed\nverification or is invalid, the authorization server returns an error\nresponse as described in Section 5.2.\nThe authorization server MAY issue a new refresh token, in which case\nthe client MUST discard the old refresh token and replace it with the\nnew refresh token. The authorization server MAY revoke the old\nrefresh token after issuing a new refresh token to the client. If a\nnew refresh token is issued, the refresh token scope MUST be\nidentical to that of the refresh token included by the client in the\nrequest.\n7. Accessing Protected Resources\nThe client accesses protected resources by presenting the access\ntoken to the resource server. The resource server MUST validate the\naccess token and ensure that it has not expired and that its scope\ncovers the requested resource. The methods used by the resource\nserver to validate the access token (as well as any error responses)\nare beyond the scope of this specification but generally involve an\ninteraction or coordination between the resource server and the\nauthorization server.\nThe method in which the client utilizes the access token to\nauthenticate with the resource server depends on the type of access\ntoken issued by the authorization server. Typically, it involves\nusing the HTTP \"Authorization\" request header field [RFC2617] with an\nauthentication scheme defined by the specification of the access\ntoken type used, such as [RFC6750].\nHardt Standards Track [Page 48]\nRFC 6749 OAuth 2.0 October 2012\n7.1. Access Token Types\nThe access token type provides the client with the information\nrequired to successfully utilize the access token to make a protected\nresource request (along with type-specific attributes). The client\nMUST NOT use an access token if it does not understand the token\ntype.\nFor example, the \"bearer\" token type defined in [RFC6750] is utilized\nby simply including the access token string in the request:\nGET /resource/1 HTTP/1.1\nHost: example.com\nAuthorization: Bearer mF_9.B5f-4.1JqM\nwhile the \"mac\" token type defined in [OAuth-HTTP-MAC] is utilized by\nissuing a Message Authentication Code (MAC) key together with the\naccess token that is used to sign certain components of the HTTP\nrequests:\nGET /resource/1 HTTP/1.1\nHost: example.com\nAuthorization: MAC id=\"h480djs93hd8\",\nnonce=\"274312:dj83hs9s\",\nmac=\"kDZvddkndxvhGRXZhvuDjEWhGeE=\"\nThe above examples are provided for illustration purposes only.\nDevelopers are advised to consult the [RFC6750] and [OAuth-HTTP-MAC]\nspecifications before use.\nEach access token type definition specifies the additional attributes\n(if any) sent to the client together with the \"access_token\" response\nparameter. It also defines the HTTP authentication method used to\ninclude the access token when making a protected resource request.\n7.2. Error Response\nIf a resource access request fails, the resource server SHOULD inform\nthe client of the error. While the specifics of such error responses\nare beyond the scope of this specification, this document establishes\na common registry in Section 11.4 for error values to be shared among\nOAuth token authentication schemes.\nNew authentication schemes designed primarily for OAuth token\nauthentication SHOULD define a mechanism for providing an error\nstatus code to the client, in which the error values allowed are\nregistered in the error registry established by this specification.\nHardt Standards Track [Page 49]\nRFC 6749 OAuth 2.0 October 2012\nSuch schemes MAY limit the set of valid error codes to a subset of\nthe registered values. If the error code is returned using a named\nparameter, the parameter name SHOULD be \"error\".\nOther schemes capable of being used for OAuth token authentication,\nbut not primarily designed for that purpose, MAY bind their error\nvalues to the registry in the same manner.\nNew authentication schemes MAY choose to also specify the use of the\n\"error_description\" and \"error_uri\" parameters to return error\ninformation in a manner parallel to their usage in this\nspecification.\n8. Extensibility\n8.1. Defining Access Token Types\nAccess token types can be defined in one of two ways: registered in\nthe Access Token Types registry (following the procedures in\nSection 11.1), or by using a unique absolute URI as its name.\nTypes utilizing a URI name SHOULD be limited to vendor-specific\nimplementations that are not commonly applicable, and are specific to\nthe implementation details of the resource server where they are\nused.\nAll other types MUST be registered. Type names MUST conform to the\ntype-name ABNF. If the type definition includes a new HTTP\nauthentication scheme, the type name SHOULD be identical to the HTTP\nauthentication scheme name (as defined by [RFC2617]). The token type\n\"example\" is reserved for use in examples.\ntype-name = 1*name-char\nname-char = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\n8.2. Defining New Endpoint Parameters\nNew request or response parameters for use with the authorization\nendpoint or the token endpoint are defined and registered in the\nOAuth Parameters registry following the procedure in Section 11.2.\nParameter names MUST conform to the param-name ABNF, and parameter\nvalues syntax MUST be well-defined (e.g., using ABNF, or a reference\nto the syntax of an existing parameter).\nparam-name = 1*name-char\nname-char = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\nHardt Standards Track [Page 50]\nRFC 6749 OAuth 2.0 October 2012\nUnregistered vendor-specific parameter extensions that are not\ncommonly applicable and that are specific to the implementation\ndetails of the authorization server where they are used SHOULD\nutilize a vendor-specific prefix that is not likely to conflict with\nother registered values (e.g., begin with 'companyname_').\n8.3. Defining New Authorization Grant Types\nNew authorization grant types can be defined by assigning them a\nunique absolute URI for use with the \"grant_type\" parameter. If the\nextension grant type requires additional token endpoint parameters,\nthey MUST be registered in the OAuth Parameters registry as described\nby Section 11.2.\n8.4. Defining New Authorization Endpoint Response Types\nNew response types for use with the authorization endpoint are\ndefined and registered in the Authorization Endpoint Response Types\nregistry following the procedure in Section 11.3. Response type\nnames MUST conform to the response-type ABNF.\nresponse-type = response-name *( SP response-name )\nresponse-name = 1*response-char\nresponse-char = \"_\" / DIGIT / ALPHA\nIf a response type contains one or more space characters (%x20), it\nis compared as a space-delimited list of values in which the order of\nvalues does not matter. Only one order of values can be registered,\nwhich covers all other arrangements of the same set of values.\nFor example, the response type \"token code\" is left undefined by this\nspecification. However, an extension can define and register the\n\"token code\" response type. Once registered, the same combination\ncannot be registered as \"code token\", but both values can be used to\ndenote the same response type.\n8.5. Defining Additional Error Codes\nIn cases where protocol extensions (i.e., access token types,\nextension parameters, or extension grant types) require additional\nerror codes to be used with the authorization code grant error\nresponse (Section 4.1.2.1), the implicit grant error response\n(Section 4.2.2.1), the token error response (Section 5.2), or the\nresource access error response (Section 7.2), such error codes MAY be\ndefined.\nHardt Standards Track [Page 51]\nRFC 6749 OAuth 2.0 October 2012\nExtension error codes MUST be registered (following the procedures in\nSection 11.4) if the extension they are used in conjunction with is a\nregistered access token type, a registered endpoint parameter, or an\nextension grant type. Error codes used with unregistered extensions\nMAY be registered.\nError codes MUST conform to the error ABNF and SHOULD be prefixed by\nan identifying name when possible. For example, an error identifying\nan invalid value set to the extension parameter \"example\" SHOULD be\nnamed \"example_invalid\".\nerror = 1*error-char\nerror-char = %x20-21 / %x23-5B / %x5D-7E\n9. Native Applications\nNative applications are clients installed and executed on the device\nused by the resource owner (i.e., desktop application, native mobile\napplication). Native applications require special consideration\nrelated to security, platform capabilities, and overall end-user\nexperience.\nThe authorization endpoint requires interaction between the client\nand the resource owner's user-agent. Native applications can invoke\nan external user-agent or embed a user-agent within the application.\nFor example:\no External user-agent - the native application can capture the\nresponse from the authorization server using a redirection URI\nwith a scheme registered with the operating system to invoke the\nclient as the handler, manual copy-and-paste of the credentials,\nrunning a local web server, installing a user-agent extension, or\nby providing a redirection URI identifying a server-hosted\nresource under the client's control, which in turn makes the\nresponse available to the native application.\no Embedded user-agent - the native application obtains the response\nby directly communicating with the embedded user-agent by\nmonitoring state changes emitted during the resource load, or\naccessing the user-agent's cookies storage.\nWhen choosing between an external or embedded user-agent, developers\nshould consider the following:\no An external user-agent may improve completion rate, as the\nresource owner may already have an active session with the\nauthorization server, removing the need to re-authenticate. It\nprovides a familiar end-user experience and functionality. The\nHardt Standards Track [Page 52]\nRFC 6749 OAuth 2.0 October 2012\nresource owner may also rely on user-agent features or extensions\nto assist with authentication (e.g., password manager, 2-factor\ndevice reader).\no An embedded user-agent may offer improved usability, as it removes\nthe need to switch context and open new windows.\no An embedded user-agent poses a security challenge because resource\nowners are authenticating in an unidentified window without access\nto the visual protections found in most external user-agents. An\nembedded user-agent educates end-users to trust unidentified\nrequests for authentication (making phishing attacks easier to\nexecute).\nWhen choosing between the implicit grant type and the authorization\ncode grant type, the following should be considered:\no Native applications that use the authorization code grant type\nSHOULD do so without using client credentials, due to the native\napplication's inability to keep client credentials confidential.\no When using the implicit grant type flow, a refresh token is not\nreturned, which requires repeating the authorization process once\nthe access token expires.\n10. Security Considerations\nAs a flexible and extensible framework, OAuth's security\nconsiderations depend on many factors. The following sections\nprovide implementers with security guidelines focused on the three\nclient profiles described in Section 2.1: web application,\nuser-agent-based application, and native application.\nA comprehensive OAuth security model and analysis, as well as\nbackground for the protocol design, is provided by\n[OAuth-THREATMODEL].\n10.1. Client Authentication\nThe authorization server establishes client credentials with web\napplication clients for the purpose of client authentication. The\nauthorization server is encouraged to consider stronger client\nauthentication means than a client password. Web application clients\nMUST ensure confidentiality of client passwords and other client\ncredentials.\nHardt Standards Track [Page 53]\nRFC 6749 OAuth 2.0 October 2012\nThe authorization server MUST NOT issue client passwords or other\nclient credentials to native application or user-agent-based\napplication clients for the purpose of client authentication. The\nauthorization server MAY issue a client password or other credentials\nfor a specific installation of a native application client on a\nspecific device.\nWhen client authentication is not possible, the authorization server\nSHOULD employ other means to validate the client's identity -- for\nexample, by requiring the registration of the client redirection URI\nor enlisting the resource owner to confirm identity. A valid\nredirection URI is not sufficient to verify the client's identity\nwhen asking for resource owner authorization but can be used to\nprevent delivering credentials to a counterfeit client after\nobtaining resource owner authorization.\nThe authorization server must consider the security implications of\ninteracting with unauthenticated clients and take measures to limit\nthe potential exposure of other credentials (e.g., refresh tokens)\nissued to such clients.\n10.2. Client Impersonation\nA malicious client can impersonate another client and obtain access\nto protected resources if the impersonated client fails to, or is\nunable to, keep its client credentials confidential.\nThe authorization server MUST authenticate the client whenever\npossible. If the authorization server cannot authenticate the client\ndue to the client's nature, the authorization server MUST require the\nregistration of any redirection URI used for receiving authorization\nresponses and SHOULD utilize other means to protect resource owners\nfrom such potentially malicious clients. For example, the\nauthorization server can engage the resource owner to assist in\nidentifying the client and its origin.\nThe authorization server SHOULD enforce explicit resource owner\nauthentication and provide the resource owner with information about\nthe client and the requested authorization scope and lifetime. It is\nup to the resource owner to review the information in the context of\nthe current client and to authorize or deny the request.\nThe authorization server SHOULD NOT process repeated authorization\nrequests automatically (without active resource owner interaction)\nwithout authenticating the client or relying on other measures to\nensure that the repeated request comes from the original client and\nnot an impersonator.\nHardt Standards Track [Page 54]\nRFC 6749 OAuth 2.0 October 2012\n10.3. Access Tokens\nAccess token credentials (as well as any confidential access token\nattributes) MUST be kept confidential in transit and storage, and\nonly shared among the authorization server, the resource servers the\naccess token is valid for, and the client to whom the access token is\nissued. Access token credentials MUST only be transmitted using TLS\nas described in Section 1.6 with server authentication as defined by\n[RFC2818].\nWhen using the implicit grant type, the access token is transmitted\nin the URI fragment, which can expose it to unauthorized parties.\nThe authorization server MUST ensure that access tokens cannot be\ngenerated, modified, or guessed to produce valid access tokens by\nunauthorized parties.\nThe client SHOULD request access tokens with the minimal scope\nnecessary. The authorization server SHOULD take the client identity\ninto account when choosing how to honor the requested scope and MAY\nissue an access token with less rights than requested.\nThis specification does not provide any methods for the resource\nserver to ensure that an access token presented to it by a given\nclient was issued to that client by the authorization server.\n10.4. Refresh Tokens\nAuthorization servers MAY issue refresh tokens to web application\nclients and native application clients.\nRefresh tokens MUST be kept confidential in transit and storage, and\nshared only among the authorization server and the client to whom the\nrefresh tokens were issued. The authorization server MUST maintain\nthe binding between a refresh token and the client to whom it was\nissued. Refresh tokens MUST only be transmitted using TLS as\ndescribed in Section 1.6 with server authentication as defined by\n[RFC2818].\nThe authorization server MUST verify the binding between the refresh\ntoken and client identity whenever the client identity can be\nauthenticated. When client authentication is not possible, the\nauthorization server SHOULD deploy other means to detect refresh\ntoken abuse.\nFor example, the authorization server could employ refresh token\nrotation in which a new refresh token is issued with every access\ntoken refresh response. The previous refresh token is invalidated\nHardt Standards Track [Page 55]\nRFC 6749 OAuth 2.0 October 2012\nbut retained by the authorization server. If a refresh token is\ncompromised and subsequently used by both the attacker and the\nlegitimate client, one of them will present an invalidated refresh\ntoken, which will inform the authorization server of the breach.\nThe authorization server MUST ensure that refresh tokens cannot be\ngenerated, modified, or guessed to produce valid refresh tokens by\nunauthorized parties.\n10.5. Authorization Codes\nThe transmission of authorization codes SHOULD be made over a secure\nchannel, and the client SHOULD require the use of TLS with its\nredirection URI if the URI identifies a network resource. Since\nauthorization codes are transmitted via user-agent redirections, they\ncould potentially be disclosed through user-agent history and HTTP\nreferrer headers.\nAuthorization codes operate as plaintext bearer credentials, used to\nverify that the resource owner who granted authorization at the\nauthorization server is the same resource owner returning to the\nclient to complete the process. Therefore, if the client relies on\nthe authorization code for its own resource owner authentication, the\nclient redirection endpoint MUST require the use of TLS.\nAuthorization codes MUST be short lived and single-use. If the\nauthorization server observes multiple attempts to exchange an\nauthorization code for an access token, the authorization server\nSHOULD attempt to revoke all access tokens already granted based on\nthe compromised authorization code.\nIf the client can be authenticated, the authorization servers MUST\nauthenticate the client and ensure that the authorization code was\nissued to the same client.\n10.6. Authorization Code Redirection URI Manipulation\nWhen requesting authorization using the authorization code grant\ntype, the client can specify a redirection URI via the \"redirect_uri\"\nparameter. If an attacker can manipulate the value of the\nredirection URI, it can cause the authorization server to redirect\nthe resource owner user-agent to a URI under the control of the\nattacker with the authorization code.\nAn attacker can create an account at a legitimate client and initiate\nthe authorization flow. When the attacker's user-agent is sent to\nthe authorization server to grant access, the attacker grabs the\nauthorization URI provided by the legitimate client and replaces the\nHardt Standards Track [Page 56]\nRFC 6749 OAuth 2.0 October 2012\nclient's redirection URI with a URI under the control of the\nattacker. The attacker then tricks the victim into following the\nmanipulated link to authorize access to the legitimate client.\nOnce at the authorization server, the victim is prompted with a\nnormal, valid request on behalf of a legitimate and trusted client,\nand authorizes the request. The victim is then redirected to an\nendpoint under the control of the attacker with the authorization\ncode. The attacker completes the authorization flow by sending the\nauthorization code to the client using the original redirection URI\nprovided by the client. The client exchanges the authorization code\nwith an access token and links it to the attacker's client account,\nwhich can now gain access to the protected resources authorized by\nthe victim (via the client).\nIn order to prevent such an attack, the authorization server MUST\nensure that the redirection URI used to obtain the authorization code\nis identical to the redirection URI provided when exchanging the\nauthorization code for an access token. The authorization server\nMUST require public clients and SHOULD require confidential clients\nto register their redirection URIs. If a redirection URI is provided\nin the request, the authorization server MUST validate it against the\nregistered value.\n10.7. Resource Owner Password Credentials\nThe resource owner password credentials grant type is often used for\nlegacy or migration reasons. It reduces the overall risk of storing\nusernames and passwords by the client but does not eliminate the need\nto expose highly privileged credentials to the client.\nThis grant type carries a higher risk than other grant types because\nit maintains the password anti-pattern this protocol seeks to avoid.\nThe client could abuse the password, or the password could\nunintentionally be disclosed to an attacker (e.g., via log files or\nother records kept by the client).\nAdditionally, because the resource owner does not have control over\nthe authorization process (the resource owner's involvement ends when\nit hands over its credentials to the client), the client can obtain\naccess tokens with a broader scope than desired by the resource\nowner. The authorization server should consider the scope and\nlifetime of access tokens issued via this grant type.\nThe authorization server and client SHOULD minimize use of this grant\ntype and utilize other grant types whenever possible.\nHardt Standards Track [Page 57]\nRFC 6749 OAuth 2.0 October 2012\n10.8. Request Confidentiality\nAccess tokens, refresh tokens, resource owner passwords, and client\ncredentials MUST NOT be transmitted in the clear. Authorization\ncodes SHOULD NOT be transmitted in the clear.\nThe \"state\" and \"scope\" parameters SHOULD NOT include sensitive\nclient or resource owner information in plain text, as they can be\ntransmitted over insecure channels or stored insecurely.\n10.9. Ensuring Endpoint Authenticity\nIn order to prevent man-in-the-middle attacks, the authorization\nserver MUST require the use of TLS with server authentication as\ndefined by [RFC2818] for any request sent to the authorization and\ntoken endpoints. The client MUST validate the authorization server's\nTLS certificate as defined by [RFC6125] and in accordance with its\nrequirements for server identity authentication.\n10.10. Credentials-Guessing Attacks\nThe authorization server MUST prevent attackers from guessing access\ntokens, authorization codes, refresh tokens, resource owner\npasswords, and client credentials.\nThe probability of an attacker guessing generated tokens (and other\ncredentials not intended for handling by end-users) MUST be less than\nor equal to 2^(-128) and SHOULD be less than or equal to 2^(-160).\nThe authorization server MUST utilize other means to protect\ncredentials intended for end-user usage.\n10.11. Phishing Attacks\nWide deployment of this and similar protocols may cause end-users to\nbecome inured to the practice of being redirected to websites where\nthey are asked to enter their passwords. If end-users are not\ncareful to verify the authenticity of these websites before entering\ntheir credentials, it will be possible for attackers to exploit this\npractice to steal resource owners' passwords.\nService providers should attempt to educate end-users about the risks\nphishing attacks pose and should provide mechanisms that make it easy\nfor end-users to confirm the authenticity of their sites. Client\ndevelopers should consider the security implications of how they\ninteract with the user-agent (e.g., external, embedded), and the\nability of the end-user to verify the authenticity of the\nauthorization server.\nHardt Standards Track [Page 58]\nRFC 6749 OAuth 2.0 October 2012\nTo reduce the risk of phishing attacks, the authorization servers\nMUST require the use of TLS on every endpoint used for end-user\ninteraction.\n10.12. Cross-Site Request Forgery\nCross-site request forgery (CSRF) is an exploit in which an attacker\ncauses the user-agent of a victim end-user to follow a malicious URI\n(e.g., provided to the user-agent as a misleading link, image, or\nredirection) to a trusting server (usually established via the\npresence of a valid session cookie).\nA CSRF attack against the client's redirection URI allows an attacker\nto inject its own authorization code or access token, which can\nresult in the client using an access token associated with the\nattacker's protected resources rather than the victim's (e.g., save\nthe victim's bank account information to a protected resource\ncontrolled by the attacker).\nThe client MUST implement CSRF protection for its redirection URI.\nThis is typically accomplished by requiring any request sent to the\nredirection URI endpoint to include a value that binds the request to\nthe user-agent's authenticated state (e.g., a hash of the session\ncookie used to authenticate the user-agent). The client SHOULD\nutilize the \"state\" request parameter to deliver this value to the\nauthorization server when making an authorization request.\nOnce authorization has been obtained from the end-user, the\nauthorization server redirects the end-user's user-agent back to the\nclient with the required binding value contained in the \"state\"\nparameter. The binding value enables the client to verify the\nvalidity of the request by matching the binding value to the\nuser-agent's authenticated state. The binding value used for CSRF\nprotection MUST contain a non-guessable value (as described in\nSection 10.10), and the user-agent's authenticated state (e.g.,\nsession cookie, HTML5 local storage) MUST be kept in a location\naccessible only to the client and the user-agent (i.e., protected by\nsame-origin policy).\nA CSRF attack against the authorization server's authorization\nendpoint can result in an attacker obtaining end-user authorization\nfor a malicious client without involving or alerting the end-user.\nThe authorization server MUST implement CSRF protection for its\nauthorization endpoint and ensure that a malicious client cannot\nobtain authorization without the awareness and explicit consent of\nthe resource owner.\nHardt Standards Track [Page 59]\nRFC 6749 OAuth 2.0 October 2012\n10.13. Clickjacking\nIn a clickjacking attack, an attacker registers a legitimate client\nand then constructs a malicious site in which it loads the\nauthorization server's authorization endpoint web page in a\ntransparent iframe overlaid on top of a set of dummy buttons, which\nare carefully constructed to be placed directly under important\nbuttons on the authorization page. When an end-user clicks a\nmisleading visible button, the end-user is actually clicking an\ninvisible button on the authorization page (such as an \"Authorize\"\nbutton). This allows an attacker to trick a resource owner into\ngranting its client access without the end-user's knowledge.\nTo prevent this form of attack, native applications SHOULD use\nexternal browsers instead of embedding browsers within the\napplication when requesting end-user authorization. For most newer\nbrowsers, avoidance of iframes can be enforced by the authorization\nserver using the (non-standard) \"x-frame-options\" header. This\nheader can have two values, \"deny\" and \"sameorigin\", which will block\nany framing, or framing by sites with a different origin,\nrespectively. For older browsers, JavaScript frame-busting\ntechniques can be used but may not be effective in all browsers.\n10.14. Code Injection and Input Validation\nA code injection attack occurs when an input or otherwise external\nvariable is used by an application unsanitized and causes\nmodification to the application logic. This may allow an attacker to\ngain access to the application device or its data, cause denial of\nservice, or introduce a wide range of malicious side-effects.\nThe authorization server and client MUST sanitize (and validate when\npossible) any value received -- in particular, the value of the\n\"state\" and \"redirect_uri\" parameters.\n10.15. Open Redirectors\nThe authorization server, authorization endpoint, and client\nredirection endpoint can be improperly configured and operate as open\nredirectors. An open redirector is an endpoint using a parameter to\nautomatically redirect a user-agent to the location specified by the\nparameter value without any validation.\nOpen redirectors can be used in phishing attacks, or by an attacker\nto get end-users to visit malicious sites by using the URI authority\ncomponent of a familiar and trusted destination. In addition, if the\nauthorization server allows the client to register only part of the\nredirection URI, an attacker can use an open redirector operated by\nHardt Standards Track [Page 60]\nRFC 6749 OAuth 2.0 October 2012\nthe client to construct a redirection URI that will pass the\nauthorization server validation but will send the authorization code\nor access token to an endpoint under the control of the attacker.\n10.16. Misuse of Access Token to Impersonate Resource Owner in Implicit\nFlow\nFor public clients using implicit flows, this specification does not\nprovide any method for the client to determine what client an access\ntoken was issued to.\nA resource owner may willingly delegate access to a resource by\ngranting an access token to an attacker's malicious client. This may\nbe due to phishing or some other pretext. An attacker may also steal\na token via some other mechanism. An attacker may then attempt to\nimpersonate the resource owner by providing the access token to a\nlegitimate public client.\nIn the implicit flow (response_type=token), the attacker can easily\nswitch the token in the response from the authorization server,\nreplacing the real access token with the one previously issued to the\nattacker.\nServers communicating with native applications that rely on being\npassed an access token in the back channel to identify the user of\nthe client may be similarly compromised by an attacker creating a\ncompromised application that can inject arbitrary stolen access\ntokens.\nAny public client that makes the assumption that only the resource\nowner can present it with a valid access token for the resource is\nvulnerable to this type of attack.\nThis type of attack may expose information about the resource owner\nat the legitimate client to the attacker (malicious client). This\nwill also allow the attacker to perform operations at the legitimate\nclient with the same permissions as the resource owner who originally\ngranted the access token or authorization code.\nAuthenticating resource owners to clients is out of scope for this\nspecification. Any specification that uses the authorization process\nas a form of delegated end-user authentication to the client (e.g.,\nthird-party sign-in service) MUST NOT use the implicit flow without\nadditional security mechanisms that would enable the client to\ndetermine if the access token was issued for its use (e.g., audience-\nrestricting the access token).\nHardt Standards Track [Page 61]\nRFC 6749 OAuth 2.0 October 2012\n11. IANA Considerations\n11.1. OAuth Access Token Types Registry\nThis specification establishes the OAuth Access Token Types registry.\nAccess token types are registered with a Specification Required\n([RFC5226]) after a two-week review period on the\noauth-ext-review@ietf.org mailing list, on the advice of one or more\nDesignated Experts. However, to allow for the allocation of values\nprior to publication, the Designated Expert(s) may approve\nregistration once they are satisfied that such a specification will\nbe published.\nRegistration requests must be sent to the oauth-ext-review@ietf.org\nmailing list for review and comment, with an appropriate subject\n(e.g., \"Request for access token type: example\").\nWithin the review period, the Designated Expert(s) will either\napprove or deny the registration request, communicating this decision\nto the review list and IANA. Denials should include an explanation\nand, if applicable, suggestions as to how to make the request\nsuccessful.\nIANA must only accept registry updates from the Designated Expert(s)\nand should direct all requests for registration to the review mailing\nlist.\n11.1.1. Registration Template\nType name:\nThe name requested (e.g., \"example\").\nAdditional Token Endpoint Response Parameters:\nAdditional response parameters returned together with the\n\"access_token\" parameter. New parameters MUST be separately\nregistered in the OAuth Parameters registry as described by\nSection 11.2.\nHTTP Authentication Scheme(s):\nThe HTTP authentication scheme name(s), if any, used to\nauthenticate protected resource requests using access tokens of\nthis type.\nChange controller:\nFor Standards Track RFCs, state \"IETF\". For others, give the name\nof the responsible party. Other details (e.g., postal address,\nemail address, home page URI) may also be included.\nHardt Standards Track [Page 62]\nRFC 6749 OAuth 2.0 October 2012\nSpecification document(s):\nReference to the document(s) that specify the parameter,\npreferably including a URI that can be used to retrieve a copy of\nthe document(s). An indication of the relevant sections may also\nbe included but is not required.\n11.2. OAuth Parameters Registry\nThis specification establishes the OAuth Parameters registry.\nAdditional parameters for inclusion in the authorization endpoint\nrequest, the authorization endpoint response, the token endpoint\nrequest, or the token endpoint response are registered with a\nSpecification Required ([RFC5226]) after a two-week review period on\nthe oauth-ext-review@ietf.org mailing list, on the advice of one or\nmore Designated Experts. However, to allow for the allocation of\nvalues prior to publication, the Designated Expert(s) may approve\nregistration once they are satisfied that such a specification will\nbe published.\nRegistration requests must be sent to the oauth-ext-review@ietf.org\nmailing list for review and comment, with an appropriate subject\n(e.g., \"Request for parameter: example\").\nWithin the review period, the Designated Expert(s) will either\napprove or deny the registration request, communicating this decision\nto the review list and IANA. Denials should include an explanation\nand, if applicable, suggestions as to how to make the request\nsuccessful.\nIANA must only accept registry updates from the Designated Expert(s)\nand should direct all requests for registration to the review mailing\nlist.\n11.2.1. Registration Template\nParameter name:\nThe name requested (e.g., \"example\").\nParameter usage location:\nThe location(s) where parameter can be used. The possible\nlocations are authorization request, authorization response, token\nrequest, or token response.\nChange controller:\nFor Standards Track RFCs, state \"IETF\". For others, give the name\nof the responsible party. Other details (e.g., postal address,\nemail address, home page URI) may also be included.\nHardt Standards Track [Page 63]\nRFC 6749 OAuth 2.0 October 2012\nSpecification document(s):\nReference to the document(s) that specify the parameter,\npreferably including a URI that can be used to retrieve a copy of\nthe document(s). An indication of the relevant sections may also\nbe included but is not required.\n11.2.2. Initial Registry Contents\nThe OAuth Parameters registry's initial contents are:\no Parameter name: client_id\no Parameter usage location: authorization request, token request\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: client_secret\no Parameter usage location: token request\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: response_type\no Parameter usage location: authorization request\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: redirect_uri\no Parameter usage location: authorization request, token request\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: scope\no Parameter usage location: authorization request, authorization\nresponse, token request, token response\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: state\no Parameter usage location: authorization request, authorization\nresponse\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: code\no Parameter usage location: authorization response, token request\no Change controller: IETF\no Specification document(s): RFC 6749\nHardt Standards Track [Page 64]\nRFC 6749 OAuth 2.0 October 2012\no Parameter name: error_description\no Parameter usage location: authorization response, token response\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: error_uri\no Parameter usage location: authorization response, token response\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: grant_type\no Parameter usage location: token request\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: access_token\no Parameter usage location: authorization response, token response\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: token_type\no Parameter usage location: authorization response, token response\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: expires_in\no Parameter usage location: authorization response, token response\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: username\no Parameter usage location: token request\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: password\no Parameter usage location: token request\no Change controller: IETF\no Specification document(s): RFC 6749\no Parameter name: refresh_token\no Parameter usage location: token request, token response\no Change controller: IETF\no Specification document(s): RFC 6749\nHardt Standards Track [Page 65]\nRFC 6749 OAuth 2.0 October 2012\n11.3. OAuth Authorization Endpoint Response Types Registry\nThis specification establishes the OAuth Authorization Endpoint\nResponse Types registry.\nAdditional response types for use with the authorization endpoint are\nregistered with a Specification Required ([RFC5226]) after a two-week\nreview period on the oauth-ext-review@ietf.org mailing list, on the\nadvice of one or more Designated Experts. However, to allow for the\nallocation of values prior to publication, the Designated Expert(s)\nmay approve registration once they are satisfied that such a\nspecification will be published.\nRegistration requests must be sent to the oauth-ext-review@ietf.org\nmailing list for review and comment, with an appropriate subject\n(e.g., \"Request for response type: example\").\nWithin the review period, the Designated Expert(s) will either\napprove or deny the registration request, communicating this decision\nto the review list and IANA. Denials should include an explanation\nand, if applicable, suggestions as to how to make the request\nsuccessful.\nIANA must only accept registry updates from the Designated Expert(s)\nand should direct all requests for registration to the review mailing\nlist.\n11.3.1. Registration Template\nResponse type name:\nThe name requested (e.g., \"example\").\nChange controller:\nFor Standards Track RFCs, state \"IETF\". For others, give the name\nof the responsible party. Other details (e.g., postal address,\nemail address, home page URI) may also be included.\nSpecification document(s):\nReference to the document(s) that specify the type, preferably\nincluding a URI that can be used to retrieve a copy of the\ndocument(s). An indication of the relevant sections may also be\nincluded but is not required.\nHardt Standards Track [Page 66]\nRFC 6749 OAuth 2.0 October 2012\n11.3.2. Initial Registry Contents\nThe OAuth Authorization Endpoint Response Types registry's initial\ncontents are:\no Response type name: code\no Change controller: IETF\no Specification document(s): RFC 6749\no Response type name: token\no Change controller: IETF\no Specification document(s): RFC 6749\n11.4. OAuth Extensions Error Registry\nThis specification establishes the OAuth Extensions Error registry.\nAdditional error codes used together with other protocol extensions\n(i.e., extension grant types, access token types, or extension\nparameters) are registered with a Specification Required ([RFC5226])\nafter a two-week review period on the oauth-ext-review@ietf.org\nmailing list, on the advice of one or more Designated Experts.\nHowever, to allow for the allocation of values prior to publication,\nthe Designated Expert(s) may approve registration once they are\nsatisfied that such a specification will be published.\nRegistration requests must be sent to the oauth-ext-review@ietf.org\nmailing list for review and comment, with an appropriate subject\n(e.g., \"Request for error code: example\").\nWithin the review period, the Designated Expert(s) will either\napprove or deny the registration request, communicating this decision\nto the review list and IANA. Denials should include an explanation\nand, if applicable, suggestions as to how to make the request\nsuccessful.\nIANA must only accept registry updates from the Designated Expert(s)\nand should direct all requests for registration to the review mailing\nlist.\nHardt Standards Track [Page 67]\nRFC 6749 OAuth 2.0 October 2012\n11.4.1. Registration Template\nError name:\nThe name requested (e.g., \"example\"). Values for the error name\nMUST NOT include characters outside the set %x20-21 / %x23-5B /\n%x5D-7E.\nError usage location:\nThe location(s) where the error can be used. The possible\nlocations are authorization code grant error response\n(Section 4.1.2.1), implicit grant error response\n(Section 4.2.2.1), token error response (Section 5.2), or resource\naccess error response (Section 7.2).\nRelated protocol extension:\nThe name of the extension grant type, access token type, or\nextension parameter that the error code is used in conjunction\nwith.\nChange controller:\nFor Standards Track RFCs, state \"IETF\". For others, give the name\nof the responsible party. Other details (e.g., postal address,\nemail address, home page URI) may also be included.\nSpecification document(s):\nReference to the document(s) that specify the error code,\npreferably including a URI that can be used to retrieve a copy of\nthe document(s). An indication of the relevant sections may also\nbe included but is not required.\n12. References\n12.1. Normative References\n[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate\nRequirement Levels\", BCP 14, RFC 2119, March 1997.\n[RFC2246] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\",\nRFC 2246, January 1999.\n[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\nMasinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\nTransfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n[RFC2617] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,\nLeach, P., Luotonen, A., and L. Stewart, \"HTTP\nAuthentication: Basic and Digest Access Authentication\",\nRFC 2617, June 1999.\nHardt Standards Track [Page 68]\nRFC 6749 OAuth 2.0 October 2012\n[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.\n[RFC3629] Yergeau, F., \"UTF-8, a transformation format of\nISO 10646\", STD 63, RFC 3629, November 2003.\n[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\nResource Identifier (URI): Generic Syntax\", STD 66,\nRFC 3986, January 2005.\n[RFC4627] Crockford, D., \"The application/json Media Type for\nJavaScript Object Notation (JSON)\", RFC 4627, July 2006.\n[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\",\nRFC 4949, August 2007.\n[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an\nIANA Considerations Section in RFCs\", BCP 26, RFC 5226,\nMay 2008.\n[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax\nSpecifications: ABNF\", STD 68, RFC 5234, January 2008.\n[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security\n(TLS) Protocol Version 1.2\", RFC 5246, August 2008.\n[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and\nVerification of Domain-Based Application Service Identity\nwithin Internet Public Key Infrastructure Using X.509\n(PKIX) Certificates in the Context of Transport Layer\nSecurity (TLS)\", RFC 6125, March 2011.\n[USASCII] American National Standards Institute, \"Coded Character\nSet -- 7-bit American Standard Code for Information\nInterchange\", ANSI X3.4, 1986.\n[W3C.REC-html401-19991224]\nRaggett, D., Le Hors, A., and I. Jacobs, \"HTML 4.01\nSpecification\", World Wide Web Consortium\nRecommendation REC-html401-19991224, December 1999,\n<http://www.w3.org/TR/1999/REC-html401-19991224>.\n[W3C.REC-xml-20081126]\nBray, T., Paoli, J., Sperberg-McQueen, C., Maler, E.,\nand F. Yergeau, \"Extensible Markup Language (XML) 1.0\n(Fifth Edition)\", World Wide Web Consortium\nRecommendation REC-xml-20081126, November 2008,\n<http://www.w3.org/TR/2008/REC-xml-20081126>.\nHardt Standards Track [Page 69]\nRFC 6749 OAuth 2.0 October 2012\n12.2. Informative References\n[OAuth-HTTP-MAC]\nHammer-Lahav, E., Ed., \"HTTP Authentication: MAC Access\nAuthentication\", Work in Progress, February 2012.\n[OAuth-SAML2]\nCampbell, B. and C. Mortimore, \"SAML 2.0 Bearer Assertion\nProfiles for OAuth 2.0\", Work in Progress, September 2012.\n[OAuth-THREATMODEL]\nLodderstedt, T., Ed., McGloin, M., and P. Hunt, \"OAuth 2.0\nThreat Model and Security Considerations\", Work\nin Progress, October 2012.\n[OAuth-WRAP]\nHardt, D., Ed., Tom, A., Eaton, B., and Y. Goland, \"OAuth\nWeb Resource Authorization Profiles\", Work in Progress,\nJanuary 2010.\n[RFC5849] Hammer-Lahav, E., \"The OAuth 1.0 Protocol\", RFC 5849,\nApril 2010.\n[RFC6750] Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization\nFramework: Bearer Token Usage\", RFC 6750, October 2012.\nHardt Standards Track [Page 70]\nRFC 6749 OAuth 2.0 October 2012\nAppendix A. Augmented Backus-Naur Form (ABNF) Syntax\nThis section provides Augmented Backus-Naur Form (ABNF) syntax\ndescriptions for the elements defined in this specification using the\nnotation of [RFC5234]. The ABNF below is defined in terms of Unicode\ncode points [W3C.REC-xml-20081126]; these characters are typically\nencoded in UTF-8. Elements are presented in the order first defined.\nSome of the definitions that follow use the \"URI-reference\"\ndefinition from [RFC3986].\nSome of the definitions that follow use these common definitions:\nVSCHAR = %x20-7E\nNQCHAR = %x21 / %x23-5B / %x5D-7E\nNQSCHAR = %x20-21 / %x23-5B / %x5D-7E\nUNICODECHARNOCRLF = %x09 /%x20-7E / %x80-D7FF /\n%xE000-FFFD / %x10000-10FFFF\n(The UNICODECHARNOCRLF definition is based upon the Char definition\nin Section 2.2 of [W3C.REC-xml-20081126], but omitting the Carriage\nReturn and Linefeed characters.)\nA.1. \"client_id\" Syntax\nThe \"client_id\" element is defined in Section 2.3.1:\nclient-id = *VSCHAR\nA.2. \"client_secret\" Syntax\nThe \"client_secret\" element is defined in Section 2.3.1:\nclient-secret = *VSCHAR\nA.3. \"response_type\" Syntax\nThe \"response_type\" element is defined in Sections 3.1.1 and 8.4:\nresponse-type = response-name *( SP response-name )\nresponse-name = 1*response-char\nresponse-char = \"_\" / DIGIT / ALPHA\nHardt Standards Track [Page 71]\nRFC 6749 OAuth 2.0 October 2012\nA.4. \"scope\" Syntax\nThe \"scope\" element is defined in Section 3.3:\nscope = scope-token *( SP scope-token )\nscope-token = 1*NQCHAR\nA.5. \"state\" Syntax\nThe \"state\" element is defined in Sections 4.1.1, 4.1.2, 4.1.2.1,\n4.2.1, 4.2.2, and 4.2.2.1:\nstate = 1*VSCHAR\nA.6. \"redirect_uri\" Syntax\nThe \"redirect_uri\" element is defined in Sections 4.1.1, 4.1.3,\nand 4.2.1:\nredirect-uri = URI-reference\nA.7. \"error\" Syntax\nThe \"error\" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,\n7.2, and 8.5:\nerror = 1*NQSCHAR\nA.8. \"error_description\" Syntax\nThe \"error_description\" element is defined in Sections 4.1.2.1,\n4.2.2.1, 5.2, and 7.2:\nerror-description = 1*NQSCHAR\nA.9. \"error_uri\" Syntax\nThe \"error_uri\" element is defined in Sections 4.1.2.1, 4.2.2.1, 5.2,\nand 7.2:\nerror-uri = URI-reference\nHardt Standards Track [Page 72]\nRFC 6749 OAuth 2.0 October 2012\nA.10. \"grant_type\" Syntax\nThe \"grant_type\" element is defined in Sections 4.1.3, 4.3.2, 4.4.2,\n4.5, and 6:\ngrant-type = grant-name / URI-reference\ngrant-name = 1*name-char\nname-char = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\nA.11. \"code\" Syntax\nThe \"code\" element is defined in Section 4.1.3:\ncode = 1*VSCHAR\nA.12. \"access_token\" Syntax\nThe \"access_token\" element is defined in Sections 4.2.2 and 5.1:\naccess-token = 1*VSCHAR\nA.13. \"token_type\" Syntax\nThe \"token_type\" element is defined in Sections 4.2.2, 5.1, and 8.1:\ntoken-type = type-name / URI-reference\ntype-name = 1*name-char\nname-char = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\nA.14. \"expires_in\" Syntax\nThe \"expires_in\" element is defined in Sections 4.2.2 and 5.1:\nexpires-in = 1*DIGIT\nA.15. \"username\" Syntax\nThe \"username\" element is defined in Section 4.3.2:\nusername = *UNICODECHARNOCRLF\nA.16. \"password\" Syntax\nThe \"password\" element is defined in Section 4.3.2:\npassword = *UNICODECHARNOCRLF\nHardt Standards Track [Page 73]\nRFC 6749 OAuth 2.0 October 2012\nA.17. \"refresh_token\" Syntax\nThe \"refresh_token\" element is defined in Sections 5.1 and 6:\nrefresh-token = 1*VSCHAR\nA.18. Endpoint Parameter Syntax\nThe syntax for new endpoint parameters is defined in Section 8.2:\nparam-name = 1*name-char\nname-char = \"-\" / \".\" / \"_\" / DIGIT / ALPHA\nAppendix B. Use of application/x-www-form-urlencoded Media Type\nAt the time of publication of this specification, the\n\"application/x-www-form-urlencoded\" media type was defined in\nSection 17.13.4 of [W3C.REC-html401-19991224] but not registered in\nthe IANA MIME Media Types registry\n(<http://www.iana.org/assignments/media-types>). Furthermore, that\ndefinition is incomplete, as it does not consider non-US-ASCII\ncharacters.\nTo address this shortcoming when generating payloads using this media\ntype, names and values MUST be encoded using the UTF-8 character\nencoding scheme [RFC3629] first; the resulting octet sequence then\nneeds to be further encoded using the escaping rules defined in\n[W3C.REC-html401-19991224].\nWhen parsing data from a payload using this media type, the names and\nvalues resulting from reversing the name/value encoding consequently\nneed to be treated as octet sequences, to be decoded using the UTF-8\ncharacter encoding scheme.\nFor example, the value consisting of the six Unicode code points\n(1) U+0020 (SPACE), (2) U+0025 (PERCENT SIGN),\n(3) U+0026 (AMPERSAND), (4) U+002B (PLUS SIGN),\n(5) U+00A3 (POUND SIGN), and (6) U+20AC (EURO SIGN) would be encoded\ninto the octet sequence below (using hexadecimal notation):\n20 25 26 2B C2 A3 E2 82 AC\nand then represented in the payload as:\n+%25%26%2B%C2%A3%E2%82%AC\nHardt Standards Track [Page 74]\nRFC 6749 OAuth 2.0 October 2012\nAppendix C. Acknowledgements\nThe initial OAuth 2.0 protocol specification was edited by David\nRecordon, based on two previous publications: the OAuth 1.0 community\nspecification [RFC5849], and OAuth WRAP (OAuth Web Resource\nAuthorization Profiles) [OAuth-WRAP]. Eran Hammer then edited many\nof the intermediate drafts that evolved into this RFC. The Security\nConsiderations section was drafted by Torsten Lodderstedt, Mark\nMcGloin, Phil Hunt, Anthony Nadalin, and John Bradley. The section\non use of the \"application/x-www-form-urlencoded\" media type was\ndrafted by Julian Reschke. The ABNF section was drafted by Michael\nB. Jones.\nThe OAuth 1.0 community specification was edited by Eran Hammer and\nauthored by Mark Atwood, Dirk Balfanz, Darren Bounds, Richard M.\nConlan, Blaine Cook, Leah Culver, Breno de Medeiros, Brian Eaton,\nKellan Elliott-McCrea, Larry Halff, Eran Hammer, Ben Laurie, Chris\nMessina, John Panzer, Sam Quigley, David Recordon, Eran Sandler,\nJonathan Sergent, Todd Sieling, Brian Slesinsky, and Andy Smith.\nThe OAuth WRAP specification was edited by Dick Hardt and authored by\nBrian Eaton, Yaron Y. Goland, Dick Hardt, and Allen Tom.\nThis specification is the work of the OAuth Working Group, which\nincludes dozens of active and dedicated participants. In particular,\nthe following individuals contributed ideas, feedback, and wording\nthat shaped and formed the final specification:\nMichael Adams, Amanda Anganes, Andrew Arnott, Dirk Balfanz, Aiden\nBell, John Bradley, Marcos Caceres, Brian Campbell, Scott Cantor,\nBlaine Cook, Roger Crew, Leah Culver, Bill de hOra, Andre DeMarre,\nBrian Eaton, Wesley Eddy, Wolter Eldering, Brian Ellin, Igor\nFaynberg, George Fletcher, Tim Freeman, Luca Frosini, Evan Gilbert,\nYaron Y. Goland, Brent Goldman, Kristoffer Gronowski, Eran Hammer,\nDick Hardt, Justin Hart, Craig Heath, Phil Hunt, Michael B. Jones,\nTerry Jones, John Kemp, Mark Kent, Raffi Krikorian, Chasen Le Hara,\nRasmus Lerdorf, Torsten Lodderstedt, Hui-Lan Lu, Casey Lucas, Paul\nMadsen, Alastair Mair, Eve Maler, James Manger, Mark McGloin,\nLaurence Miao, William Mills, Chuck Mortimore, Anthony Nadalin,\nJulian Reschke, Justin Richer, Peter Saint-Andre, Nat Sakimura, Rob\nSayre, Marius Scurtescu, Naitik Shah, Luke Shepard, Vlad Skvortsov,\nJustin Smith, Haibin Song, Niv Steingarten, Christian Stuebner,\nJeremy Suriel, Paul Tarjan, Christopher Thomas, Henry S. Thompson,\nAllen Tom, Franklin Tse, Nick Walker, Shane Weeden, and Skylar\nWoodward.\nHardt Standards Track [Page 75]\nRFC 6749 OAuth 2.0 October 2012\nThis document was produced under the chairmanship of Blaine Cook,\nPeter Saint-Andre, Hannes Tschofenig, Barry Leiba, and Derek Atkins.\nThe area directors included Lisa Dusseault, Peter Saint-Andre, and\nStephen Farrell.\nAuthor's Address\nDick Hardt (editor)\nMicrosoft\nEMail: dick.hardt@gmail.com\nURI: http://dickhardt.org/\nHardt Standards Track [Page 76]"
    },
    {
      "url": "https://learn.microsoft.com/en-us/uwp/api/windows.security.authentication.web.core.webauthenticationcoremanager?view=winrt-26100",
      "text": "WebAuthenticationCoreManager Class\nDefinition\nImportant\nSome information relates to prerelease product that may be substantially modified before it\u2019s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\nContains core methods for obtaining tokens from web account providers.\npublic ref class WebAuthenticationCoreManager abstract sealed\n/// [Windows.Foundation.Metadata.ContractVersion(Windows.Foundation.UniversalApiContract, 65536)]\n/// [Windows.Foundation.Metadata.MarshalingBehavior(Windows.Foundation.Metadata.MarshalingType.Agile)]\n/// [Windows.Foundation.Metadata.Threading(Windows.Foundation.Metadata.ThreadingModel.Both)]\nclass WebAuthenticationCoreManager final\n[Windows.Foundation.Metadata.ContractVersion(typeof(Windows.Foundation.UniversalApiContract), 65536)]\n[Windows.Foundation.Metadata.MarshalingBehavior(Windows.Foundation.Metadata.MarshalingType.Agile)]\n[Windows.Foundation.Metadata.Threading(Windows.Foundation.Metadata.ThreadingModel.Both)]\npublic static class WebAuthenticationCoreManager\nPublic Class WebAuthenticationCoreManager\n- Inheritance\n- Attributes\nWindows requirements\n| Device family |\nWindows 10 (introduced in 10.0.10240.0)\n|\n| API contract |\nWindows.Foundation.UniversalApiContract (introduced in v1.0)\n|\nRemarks\nVersion history\n| Windows version | SDK version | Value added |\n|---|---|---|\n| 1607 | 14393 | CreateWebAccountMonitor |\n| 1803 | 17134 | FindAllAccountsAsync(WebAccountProvider) |\n| 1803 | 17134 | FindAllAccountsAsync(WebAccountProvider,String) |\n| 1803 | 17134 | FindSystemAccountProviderAsync(String) |\n| 1803 | 17134 | FindSystemAccountProviderAsync(String,String) |\n| 1803 | 17134 | FindSystemAccountProviderAsync(String,String,User) |\nMethods\n| AddAccountWithTransferTokenAsync(WebAuthenticationTransferTokenRequest) |\nA method that adds a user's account to a cloud device using a transfer token. |\n| CreateWebAccountMonitor(IIterable<WebAccount>) |\nCreates a web account monitor to watch given accounts. |\n| FindAccountAsync(WebAccountProvider, String) |\nAsynchronously attempts to find a web account provider. |\n| FindAccountProviderAsync(String, String, User) |\nAsynchronously attempts to find a web account provider. |\n| FindAccountProviderAsync(String, String) |\nAsynchronously attempts to find a web account provider. |\n| FindAccountProviderAsync(String) |\nAsynchronously attempts to find a web account provider. |\n| FindAllAccountsAsync(WebAccountProvider, String) |\nEnumerates all of the accounts that have been added by a user for a particular ID provider. |\n| FindAllAccountsAsync(WebAccountProvider) |\nEnumerates all of the accounts that have been added by a user for a particular ID provider. |\n| FindSystemAccountProviderAsync(String, String, User) |\nAsynchronously attempts to find a web account provider for device-wide authentication. |\n| FindSystemAccountProviderAsync(String, String) |\nAsynchronously attempts to find a web account provider for device-wide authentication. |\n| FindSystemAccountProviderAsync(String) |\nAsynchronously attempts to find a web account provider for device-wide authentication. |\n| GetTokenSilentlyAsync(WebTokenRequest, WebAccount) |\nAsynchronously attempts to get a token without showing any UI. The user will never be prompted to enter their credentials. |\n| GetTokenSilentlyAsync(WebTokenRequest) |\nAsynchronously attempts to get a token without showing any UI. The user will never be prompted to enter their credentials. |\n| RequestTokenAsync(WebTokenRequest, WebAccount) |\nAsynchronously requests a token from a web account provider. If necessary, the user is prompted to enter their credentials. |\n| RequestTokenAsync(WebTokenRequest) |\nAsynchronously requests a token from a web account provider. If necessary, the user is prompted to enter their credentials. |"
    },
    {
      "url": "https://openid.net/specs/openid-connect-core-1_0.html",
      "text": "| TOC |\n|\nOpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. It enables Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner.\nThis specification defines the core OpenID Connect functionality: authentication built on top of OAuth 2.0 and the use of Claims to communicate information about the End-User. It also describes the security and privacy considerations for using OpenID Connect.\n1.\nIntroduction\n1.1.\nRequirements Notation and Conventions\n1.2.\nTerminology\n1.3.\nOverview\n2.\nID Token\n3.\nAuthentication\n3.1.\nAuthentication using the Authorization Code Flow\n3.1.1.\nAuthorization Code Flow Steps\n3.1.2.\nAuthorization Endpoint\n3.1.2.1.\nAuthentication Request\n3.1.2.2.\nAuthentication Request Validation\n3.1.2.3.\nAuthorization Server Authenticates End-User\n3.1.2.4.\nAuthorization Server Obtains End-User Consent/Authorization\n3.1.2.5.\nSuccessful Authentication Response\n3.1.2.6.\nAuthentication Error Response\n3.1.2.7.\nAuthentication Response Validation\n3.1.3.\nToken Endpoint\n3.1.3.1.\nToken Request\n3.1.3.2.\nToken Request Validation\n3.1.3.3.\nSuccessful Token Response\n3.1.3.4.\nToken Error Response\n3.1.3.5.\nToken Response Validation\n3.1.3.6.\nID Token\n3.1.3.7.\nID Token Validation\n3.1.3.8.\nAccess Token Validation\n3.2.\nAuthentication using the Implicit Flow\n3.2.1.\nImplicit Flow Steps\n3.2.2.\nAuthorization Endpoint\n3.2.2.1.\nAuthentication Request\n3.2.2.2.\nAuthentication Request Validation\n3.2.2.3.\nAuthorization Server Authenticates End-User\n3.2.2.4.\nAuthorization Server Obtains End-User Consent/Authorization\n3.2.2.5.\nSuccessful Authentication Response\n3.2.2.6.\nAuthentication Error Response\n3.2.2.7.\nRedirect URI Fragment Handling\n3.2.2.8.\nAuthentication Response Validation\n3.2.2.9.\nAccess Token Validation\n3.2.2.10.\nID Token\n3.2.2.11.\nID Token Validation\n3.3.\nAuthentication using the Hybrid Flow\n3.3.1.\nHybrid Flow Steps\n3.3.2.\nAuthorization Endpoint\n3.3.2.1.\nAuthentication Request\n3.3.2.2.\nAuthentication Request Validation\n3.3.2.3.\nAuthorization Server Authenticates End-User\n3.3.2.4.\nAuthorization Server Obtains End-User Consent/Authorization\n3.3.2.5.\nSuccessful Authentication Response\n3.3.2.6.\nAuthentication Error Response\n3.3.2.7.\nRedirect URI Fragment Handling\n3.3.2.8.\nAuthentication Response Validation\n3.3.2.9.\nAccess Token Validation\n3.3.2.10.\nAuthorization Code Validation\n3.3.2.11.\nID Token\n3.3.2.12.\nID Token Validation\n3.3.3.\nToken Endpoint\n3.3.3.1.\nToken Request\n3.3.3.2.\nToken Request Validation\n3.3.3.3.\nSuccessful Token Response\n3.3.3.4.\nToken Error Response\n3.3.3.5.\nToken Response Validation\n3.3.3.6.\nID Token\n3.3.3.7.\nID Token Validation\n3.3.3.8.\nAccess Token\n3.3.3.9.\nAccess Token Validation\n4.\nInitiating Login from a Third Party\n5.\nClaims\n5.1.\nStandard Claims\n5.1.1.\nAddress Claim\n5.1.2.\nAdditional Claims\n5.2.\nClaims Languages and Scripts\n5.3.\nUserInfo Endpoint\n5.3.1.\nUserInfo Request\n5.3.2.\nSuccessful UserInfo Response\n5.3.3.\nUserInfo Error Response\n5.3.4.\nUserInfo Response Validation\n5.4.\nRequesting Claims using Scope Values\n5.5.\nRequesting Claims using the \"claims\" Request Parameter\n5.5.1.\nIndividual Claims Requests\n5.5.1.1.\nRequesting the \"acr\" Claim\n5.5.2.\nLanguages and Scripts for Individual Claims\n5.6.\nClaim Types\n5.6.1.\nNormal Claims\n5.6.2.\nAggregated and Distributed Claims\n5.6.2.1.\nExample of Aggregated Claims\n5.6.2.2.\nExample of Distributed Claims\n5.7.\nClaim Stability and Uniqueness\n6.\nPassing Request Parameters as JWTs\n6.1.\nPassing a Request Object by Value\n6.1.1.\nRequest using the \"request\" Request Parameter\n6.2.\nPassing a Request Object by Reference\n6.2.1.\nURI Referencing the Request Object\n6.2.2.\nRequest using the \"request_uri\" Request Parameter\n6.2.3.\nAuthorization Server Fetches Request Object\n6.2.4.\n\"request_uri\" Rationale\n6.3.\nValidating JWT-Based Requests\n6.3.1.\nEncrypted Request Object\n6.3.2.\nSigned Request Object\n6.3.3.\nRequest Parameter Assembly and Validation\n7.\nSelf-Issued OpenID Provider\n7.1.\nSelf-Issued OpenID Provider Discovery\n7.2.\nSelf-Issued OpenID Provider Registration\n7.2.1.\nProviding Information with the \"registration\" Request Parameter\n7.3.\nSelf-Issued OpenID Provider Request\n7.4.\nSelf-Issued OpenID Provider Response\n7.5.\nSelf-Issued ID Token Validation\n8.\nSubject Identifier Types\n8.1.\nPairwise Identifier Algorithm\n9.\nClient Authentication\n10.\nSignatures and Encryption\n10.1.\nSigning\n10.1.1.\nRotation of Asymmetric Signing Keys\n10.2.\nEncryption\n10.2.1.\nRotation of Asymmetric Encryption Keys\n11.\nOffline Access\n12.\nUsing Refresh Tokens\n12.1.\nRefresh Request\n12.2.\nSuccessful Refresh Response\n12.3.\nRefresh Error Response\n13.\nSerializations\n13.1.\nQuery String Serialization\n13.2.\nForm Serialization\n13.3.\nJSON Serialization\n14.\nString Operations\n15.\nImplementation Considerations\n15.1.\nMandatory to Implement Features for All OpenID Providers\n15.2.\nMandatory to Implement Features for Dynamic OpenID Providers\n15.3.\nDiscovery and Registration\n15.4.\nMandatory to Implement Features for Relying Parties\n15.5.\nImplementation Notes\n15.5.1.\nAuthorization Code Implementation Notes\n15.5.2.\nNonce Implementation Notes\n15.5.3.\nRedirect URI Fragment Handling Implementation Notes\n15.6.\nCompatibility Notes\n15.7.\nRelated Specifications and Implementer's Guides\n16.\nSecurity Considerations\n16.1.\nRequest Disclosure\n16.2.\nServer Masquerading\n16.3.\nToken Manufacture/Modification\n16.4.\nAccess Token Disclosure\n16.5.\nServer Response Disclosure\n16.6.\nServer Response Repudiation\n16.7.\nRequest Repudiation\n16.8.\nAccess Token Redirect\n16.9.\nToken Reuse\n16.10.\nEavesdropping or Leaking Authorization Codes (Secondary Authenticator Capture)\n16.11.\nToken Substitution\n16.12.\nTiming Attack\n16.13.\nOther Crypto Related Attacks\n16.14.\nSigning and Encryption Order\n16.15.\nIssuer Identifier\n16.16.\nImplicit Flow Threats\n16.17.\nTLS Requirements\n16.18.\nLifetimes of Access Tokens and Refresh Tokens\n16.19.\nSymmetric Key Entropy\n16.20.\nNeed for Signed Requests\n16.21.\nNeed for Encrypted Requests\n16.22.\nHTTP 307 Redirects\n16.23.\nCustom URI Schemes on iOS\n17.\nPrivacy Considerations\n17.1.\nPersonally Identifiable Information\n17.2.\nData Access Monitoring\n17.3.\nCorrelation\n17.4.\nOffline Access\n18.\nIANA Considerations\n18.1.\nJSON Web Token Claims Registration\n18.1.1.\nRegistry Contents\n18.2.\nOAuth Parameters Registration\n18.2.1.\nRegistry Contents\n18.3.\nOAuth Extensions Error Registration\n18.3.1.\nRegistry Contents\n18.4.\nURI Scheme Registration\n18.4.1.\nRegistry Contents\n19.\nReferences\n19.1.\nNormative References\n19.2.\nInformative References\nAppendix A.\nAuthorization Examples\nA.1.\nExample using response_type=code\nA.2.\nExample using response_type=id_token\nA.3.\nExample using response_type=id_token token\nA.4.\nExample using response_type=code id_token\nA.5.\nExample using response_type=code token\nA.6.\nExample using response_type=code id_token token\nA.7.\nRSA Key Used in Examples\nAppendix B.\nAcknowledgements\nAppendix C.\nNotices\n\u00a7\nAuthors' Addresses\n| TOC |\nOpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 [RFC6749] (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) protocol. It enables Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner.\nThe OpenID Connect Core 1.0 specification defines the core OpenID Connect functionality: authentication built on top of OAuth 2.0 and the use of Claims to communicate information about the End-User. It also describes the security and privacy considerations for using OpenID Connect.\nAs background, the OAuth 2.0 Authorization Framework (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749] and OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, \u201cThe OAuth 2.0 Authorization Framework: Bearer Token Usage,\u201d October 2012.) [RFC6750] specifications provide a general framework for third-party applications to obtain and use limited access to HTTP resources. They define mechanisms to obtain and use Access Tokens to access resources but do not define standard methods to provide identity information. Notably, without profiling OAuth 2.0, it is incapable of providing information about the authentication of an End-User. Readers are expected to be familiar with these specifications.\nOpenID Connect implements authentication as an extension to the OAuth 2.0 authorization process. Use of this extension is requested by Clients by including the openid scope value in the Authorization Request. Information about the authentication performed is returned in a JSON Web Token (JWT) (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.) [JWT] called an ID Token (see Section 2 (ID Token)). OAuth 2.0 Authentication Servers implementing OpenID Connect are also referred to as OpenID Providers (OPs). OAuth 2.0 Clients using OpenID Connect are also referred to as Relying Parties (RPs).\nThis specification assumes that the Relying Party has already obtained configuration information about the OpenID Provider, including its Authorization Endpoint and Token Endpoint locations. This information is normally obtained via Discovery, as described in OpenID Connect Discovery 1.0 (Sakimura, N., Bradley, J., Jones, M., and E. Jay, \u201cOpenID Connect Discovery 1.0,\u201d December 2023.) [OpenID.Discovery], or may be obtained via other mechanisms.\nLikewise, this specification assumes that the Relying Party has already obtained sufficient credentials and provided information needed to use the OpenID Provider. This is normally done via Dynamic Registration, as described in OpenID Connect Dynamic Client Registration 1.0 (Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023.) [OpenID.Registration], or may be obtained via other mechanisms.\nThe previous versions of this specification are:\n| TOC |\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 (Bradner, S., \u201cKey words for use in RFCs to Indicate Requirement Levels,\u201d March 1997.) [RFC2119].\nIn the .txt version of this specification, values are quoted to indicate that they are to be taken literally. When using these values in protocol messages, the quotes MUST NOT be used as part of the value. In the HTML version of this specification, values to be taken literally are indicated by the use of this fixed-width font.\nAll uses of JSON Web Signature (JWS) (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Signature (JWS),\u201d May 2015.) [JWS] and JSON Web Encryption (JWE) (Jones, M. and J. Hildebrand, \u201cJSON Web Encryption (JWE),\u201d May 2015.) [JWE] data structures in this specification utilize the JWS Compact Serialization or the JWE Compact Serialization; the JWS JSON Serialization and the JWE JSON Serialization are not used.\n| TOC |\nThis specification uses the terms \"Access Token\", \"Authorization Code\", \"Authorization Endpoint\", \"Authorization Grant\", \"Authorization Server\", \"Client\", \"Client Authentication\", \"Client Identifier\", \"Client Secret\", \"Grant Type\", \"Protected Resource\", \"Redirection URI\", \"Refresh Token\", \"Resource Server\", \"Response Type\", and \"Token Endpoint\" defined by OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749], the terms \"Claim Name\", \"Claim Value\", \"JSON Web Token (JWT)\", \"JWT Claims Set\", and \"Nested JWT\" defined by JSON Web Token (JWT) (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.) [JWT], the terms \"Base64url Encoding\", \"Header Parameter\", and \"JOSE Header\" defined by JSON Web Signature (JWS) (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Signature (JWS),\u201d May 2015.) [JWS], the term \"User Agent\" defined by RFC 7230 (Fielding, R., Ed. and J. Reschke, Ed., \u201cHypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing,\u201d June 2014.) [RFC7230], and the term \"Response Mode\" defined by OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014.) [OAuth.Responses].\nThis specification also defines the following terms:\n- Authentication\n- Process used to achieve sufficient confidence in the binding between the Entity and the presented Identity.\n- Authentication Request\n- OAuth 2.0 Authorization Request using extension parameters and scopes defined by OpenID Connect to request that the End-User be authenticated by the Authorization Server, which is an OpenID Connect Provider, to the Client, which is an OpenID Connect Relying Party.\n- Authentication Context\n- Information that the Relying Party can require before it makes an entitlement decision with respect to an authentication response. Such context can include, but is not limited to, the actual authentication method used or level of assurance such as ISO/IEC 29115 (International Organization for Standardization, \u201cISO/IEC 29115:2013. Information technology - Security techniques - Entity authentication assurance framework,\u201d April 2013.) [ISO29115] entity authentication assurance level.\n- Authentication Context Class\n- Set of authentication methods or procedures that are considered to be equivalent to each other in a particular context.\n- Authentication Context Class Reference\n- Identifier for an Authentication Context Class.\n- Authorization Code Flow\n- OAuth 2.0 flow in which an Authorization Code is returned from the Authorization Endpoint and all tokens are returned from the Token Endpoint.\n- Authorization Request\n- OAuth 2.0 Authorization Request as defined by [RFC6749] (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.).\n- Claim\n- Piece of information asserted about an Entity.\n- Claim Type\n- Syntax used for representing a Claim Value. This specification defines Normal, Aggregated, and Distributed Claim Types.\n- Claims Provider\n- Server that can return Claims about an Entity.\n- Credential\n- Data presented as evidence of the right to use an identity or other resources.\n- End-User\n- Human participant.\n- Entity\n- Something that has a separate and distinct existence and that can be identified in a context. An End-User is one example of an Entity.\n- Essential Claim\n- Claim specified by the Client as being necessary to ensure a smooth authorization experience for the specific task requested by the End-User.\n- Hybrid Flow\n- OAuth 2.0 flow in which an Authorization Code is returned from the Authorization Endpoint, some tokens are returned from the Authorization Endpoint, and others are returned from the Token Endpoint.\n- ID Token\n- JSON Web Token (JWT) (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.) [JWT] that contains Claims about the Authentication event. It MAY contain other Claims.\n- Identifier\n- Value that uniquely characterizes an Entity in a specific context.\n- Identity\n- Set of attributes related to an Entity.\n- Implicit Flow\n- OAuth 2.0 flow in which all tokens are returned from the Authorization Endpoint and neither the Token Endpoint nor an Authorization Code are used.\n- Issuer\n- Entity that issues a set of Claims.\n- Issuer Identifier\n- Verifiable Identifier for an Issuer. An Issuer Identifier is a case-sensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components and no query or fragment components.\n- Message\n- Request or a response between an OpenID Relying Party and an OpenID Provider.\n- OpenID Provider (OP)\n- OAuth 2.0 Authorization Server that is capable of Authenticating the End-User and providing Claims to a Relying Party about the Authentication event and the End-User.\n- Request Object\n- JWT that contains a set of request parameters as its Claims.\n- Request URI\n- URL that references a resource containing a Request Object. The Request URI contents MUST be retrievable by the Authorization Server.\n- Pairwise Pseudonymous Identifier (PPID)\n- Identifier that identifies the Entity to a Relying Party that cannot be correlated with the Entity's PPID at another Relying Party.\n- Personally Identifiable Information (PII)\n- Information that (a) can be used to identify the natural person to whom such information relates, or (b) is or might be directly or indirectly linked to a natural person to whom such information relates.\n- Relying Party (RP)\n- OAuth 2.0 Client application requiring End-User Authentication and Claims from an OpenID Provider.\n- Sector Identifier\n- Host component of a URL used by the Relying Party's organization that is an input to the computation of pairwise Subject Identifiers for that Relying Party.\n- Self-Issued OpenID Provider\n- Personal, self-hosted OpenID Provider that issues self-signed ID Tokens.\n- Subject Identifier\n- Locally unique and never reassigned identifier within the Issuer for the End-User, which is intended to be consumed by the Client.\n- UserInfo Endpoint\n- Protected Resource that, when presented with an Access Token by the Client, returns authorized information about the End-User represented by the corresponding Authorization Grant. The UserInfo Endpoint URL MUST use the https scheme and MAY contain port, path, and query parameter components.\n- Validation\n- Process intended to establish the soundness or correctness of a construct.\n- Verification\n- Process intended to test or prove the truth or accuracy of a fact or value.\n- Voluntary Claim\n- Claim specified by the Client as being useful but not Essential for the specific task requested by the End-User.\nIMPORTANT NOTE TO READERS: The terminology definitions in this section are a normative portion of this specification, imposing requirements upon implementations. All the capitalized words in the text of this specification, such as \"Issuer Identifier\", reference these defined terms. Whenever the reader encounters them, their definitions found in this section must be followed.\nFor more background on some of the terminology used, see Internet Security Glossary, Version 2 (Shirey, R., \u201cInternet Security Glossary, Version 2,\u201d August 2007.) [RFC4949], ISO/IEC 29115 Entity Authentication Assurance (International Organization for Standardization, \u201cISO/IEC 29115:2013. Information technology - Security techniques - Entity authentication assurance framework,\u201d April 2013.) [ISO29115], and ITU-T X.1252 (International Telecommunication Union, \u201cITU-T Recommendation X.1252 - Cyberspace security - Identity management - Baseline identity management terms and definitions,\u201d April 2010.) [X.1252].\n| TOC |\nThe OpenID Connect protocol, in abstract, follows the following steps.\nThese steps are illustrated in the following diagram:\n+--------+ +--------+ | | | | | |---------(1) AuthN Request-------->| | | | | | | | +--------+ | | | | | | | | | | | End- |<--(2) AuthN & AuthZ-->| | | | | User | | | | RP | | | | OP | | | +--------+ | | | | | | | |<--------(3) AuthN Response--------| | | | | | | |---------(4) UserInfo Request----->| | | | | | | |<--------(5) UserInfo Response-----| | | | | | +--------+ +--------+\n| TOC |\nThe primary extension that OpenID Connect makes to OAuth 2.0 to enable End-Users to be Authenticated is the ID Token data structure. The ID Token is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when using a Client, and potentially other requested Claims. The ID Token is represented as a JSON Web Token (JWT) (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.) [JWT].\nThe following Claims are used within the ID Token for all OAuth 2.0 flows used by OpenID Connect:\n- iss\n- REQUIRED. Issuer Identifier for the Issuer of the response. The iss value is a case-sensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components and no query or fragment components.\n- sub\n- REQUIRED. Subject Identifier. A locally unique and never reassigned identifier within the Issuer for the End-User, which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed 255 ASCII [RFC20] (Cerf, V., \u201cASCII format for Network Interchange,\u201d October 1969.) characters in length. The sub value is a case-sensitive string.\n- aud\n- REQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an audience value. It MAY also contain identifiers for other audiences. In the general case, the aud value is an array of case-sensitive strings. In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\n- exp\n- REQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted by the RP when performing authentication with the OP. The processing of this parameter requires that the current date/time MUST be before the expiration date/time listed in the value. Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew. Its value is a JSON [RFC8259] (Bray, T., Ed., \u201cThe JavaScript Object Notation (JSON) Data Interchange Format,\u201d December 2017.) number representing the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time. See RFC 3339 (Klyne, G. and C. Newman, \u201cDate and Time on the Internet: Timestamps,\u201d July 2002.) [RFC3339] for details regarding date/times in general and UTC in particular. NOTE: The ID Token expiration time is unrelated the lifetime of the authenticated session between the RP and the OP.\n- iat\n- REQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time.\n- auth_time\n- Time when the End-User authentication occurred. Its value is a JSON number representing the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time. When a max_age request is made or when auth_time is requested as an Essential Claim, then this Claim is REQUIRED; otherwise, its inclusion is OPTIONAL. (The auth_time Claim semantically corresponds to the OpenID 2.0 PAPE (Recordon, D., Jones, M., Bufu, J., Ed., Daugherty, J., Ed., and N. Sakimura, \u201cOpenID Provider Authentication Policy Extension 1.0,\u201d December 2008.) [OpenID.PAPE] auth_time response parameter.)\n- nonce\n- String value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. If present in the ID Token, Clients MUST verify that the nonce Claim Value is equal to the value of the nonce parameter sent in the Authentication Request. If present in the Authentication Request, Authorization Servers MUST include a nonce Claim in the ID Token with the Claim Value being the nonce value sent in the Authentication Request. Authorization Servers SHOULD perform no other processing on nonce values used. The nonce value is a case-sensitive string.\n- acr\n- OPTIONAL. Authentication Context Class Reference. String specifying an Authentication Context Class Reference value that identifies the Authentication Context Class that the authentication performed satisfied. The value \"0\" indicates the End-User authentication did not meet the requirements of ISO/IEC 29115 (International Organization for Standardization, \u201cISO/IEC 29115:2013. Information technology - Security techniques - Entity authentication assurance framework,\u201d April 2013.) [ISO29115] level 1. For historic reasons, the value \"0\" is used to indicate that there is no confidence that the same person is actually there. Authentications with level 0 SHOULD NOT be used to authorize access to any resource of any monetary value. (This corresponds to the OpenID 2.0 PAPE (Recordon, D., Jones, M., Bufu, J., Ed., Daugherty, J., Ed., and N. Sakimura, \u201cOpenID Provider Authentication Policy Extension 1.0,\u201d December 2008.) [OpenID.PAPE] nist_auth_level 0.) An absolute URI or an RFC 6711 (Johansson, L., \u201cAn IANA Registry for Level of Assurance (LoA) Profiles,\u201d August 2012.) [RFC6711] registered name SHOULD be used as the acr value; registered names MUST NOT be used with a different meaning than that which is registered. Parties using this claim will need to agree upon the meanings of the values used, which may be context specific. The acr value is a case-sensitive string.\n- amr\n- OPTIONAL. Authentication Methods References. JSON array of strings that are identifiers for authentication methods used in the authentication. For instance, values might indicate that both password and OTP authentication methods were used. The amr value is an array of case-sensitive strings. Values used in the amr Claim SHOULD be from those registered in the IANA Authentication Method Reference Values registry [IANA.AMR] (IANA, \u201cAuthentication Method Reference Values,\u201d .) established by [RFC8176] (Jones, M., Hunt, P., and A. Nadalin, \u201cAuthentication Method Reference Values,\u201d June 2017.); parties using this claim will need to agree upon the meanings of any unregistered values used, which may be context specific.\n- azp\n- OPTIONAL. Authorized party - the party to which the ID Token was issued. If present, it MUST contain the OAuth 2.0 Client ID of this party. The azp value is a case-sensitive string containing a StringOrURI value. Note that in practice, the azp Claim only occurs when extensions beyond the scope of this specification are used; therefore, implementations not using such extensions are encouraged to not use azp and to ignore it when it does occur.\nID Tokens MAY contain other Claims. Any Claims used that are not understood MUST be ignored. See Sections 3.1.3.6 (ID Token), 3.3.2.11 (ID Token), 5.1 (Standard Claims), and 7.4 (Self-Issued OpenID Provider Response) for additional Claims defined by this specification.\nID Tokens MUST be signed using JWS (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Signature (JWS),\u201d May 2015.) [JWS] and optionally both signed and then encrypted using JWS (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Signature (JWS),\u201d May 2015.) [JWS] and JWE (Jones, M. and J. Hildebrand, \u201cJSON Web Encryption (JWE),\u201d May 2015.) [JWE] respectively, thereby providing authentication, integrity, non-repudiation, and optionally, confidentiality, per Section 16.14 (Signing and Encryption Order). If the ID Token is encrypted, it MUST be signed then encrypted, with the result being a Nested JWT, as defined in [JWT] (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.). ID Tokens MUST NOT use none as the alg value unless the Response Type used returns no ID Token from the Authorization Endpoint (such as when using the Authorization Code Flow) and the Client explicitly requested the use of none at Registration time.\nID Tokens SHOULD NOT use the JWS or JWE x5u, x5c, jku, or jwk Header Parameter fields. Instead, references to keys used are communicated in advance using Discovery and Registration parameters, per Section 10 (Signatures and Encryption).\nThe following is a non-normative example of the set of Claims (the JWT Claims Set) in an ID Token:\n{ \"iss\": \"https://server.example.com\", \"sub\": \"24400320\", \"aud\": \"s6BhdRkqt3\", \"nonce\": \"n-0S6_WzA2Mj\", \"exp\": 1311281970, \"iat\": 1311280970, \"auth_time\": 1311280969, \"acr\": \"urn:mace:incommon:iap:silver\" }\n| TOC |\nOpenID Connect performs authentication to log in the End-User or to determine that the End-User is already logged in. OpenID Connect returns the result of the Authentication performed by the Server to the Client in a secure manner so that the Client can rely on it. For this reason, the Client is called Relying Party (RP) in this case.\nThe Authentication result is returned in an ID Token, as defined in Section 2 (ID Token). It has Claims expressing such information as the Issuer, the Subject Identifier, when the authentication was performed, etc.\nAuthentication can follow one of three paths: the Authorization Code Flow (response_type=code), the Implicit Flow (response_type=id_token token or response_type=id_token), or the Hybrid Flow (using other Response Type values defined in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014.) [OAuth.Responses]). The flows determine how the ID Token and Access Token are returned to the Client.\nThe characteristics of the three flows are summarized in the following non-normative table. The table is intended to provide some guidance on which flow to choose in particular contexts.\n| Property | Authorization Code Flow | Implicit Flow | Hybrid Flow |\n|---|---|---|---|\n| All tokens returned from Authorization Endpoint | no | yes | no |\n| All tokens returned from Token Endpoint | yes | no | no |\n| Tokens not revealed to User Agent | yes | no | no |\n| Client can be authenticated | yes | no | yes |\n| Refresh Token possible | yes | no | yes |\n| Communication in one round trip | no | yes | no |\n| Most communication server-to-server | yes | no | varies |\n| OpenID Connect Authentication Flows |\nThe flow used is determined by the response_type value contained in the Authorization Request. These response_type values select these flows:\n| \"response_type\" value | Flow |\n|---|---|\n| code | Authorization Code Flow |\n| id_token | Implicit Flow |\n| id_token token | Implicit Flow |\n| code id_token | Hybrid Flow |\n| code token | Hybrid Flow |\n| code id_token token | Hybrid Flow |\n| OpenID Connect \"response_type\" Values |\nAll but the code Response Type value, which is defined by OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749], are defined in the OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014.) [OAuth.Responses] specification. NOTE: While OAuth 2.0 also defines the token Response Type value for the Implicit Flow, OpenID Connect does not use this Response Type, since no ID Token would be returned.\n| TOC |\nThis section describes how to perform authentication using the Authorization Code Flow. When using the Authorization Code Flow, all tokens are returned from the Token Endpoint.\nThe Authorization Code Flow returns an Authorization Code to the Client, which can then exchange it for an ID Token and an Access Token directly. This provides the benefit of not exposing any tokens to the User Agent and possibly other malicious applications with access to the User Agent. The Authorization Server can also authenticate the Client before exchanging the Authorization Code for an Access Token. The Authorization Code flow is suitable for Clients that can securely maintain a Client Secret between themselves and the Authorization Server.\n| TOC |\nThe Authorization Code Flow goes through the following steps.\n| TOC |\nThe Authorization Endpoint performs Authentication of the End-User. This is done by sending the User Agent to the Authorization Server's Authorization Endpoint for Authentication and Authorization, using request parameters defined by OAuth 2.0 and additional parameters and parameter values defined by OpenID Connect.\nCommunication with the Authorization Endpoint MUST utilize TLS. See Section 16.17 (TLS Requirements) for more information on using TLS.\n| TOC |\nAn Authentication Request is an OAuth 2.0 Authorization Request that requests that the End-User be authenticated by the Authorization Server.\nAuthorization Servers MUST support the use of the HTTP GET and POST methods defined in RFC 7231 (Fielding, R., Ed. and J. Reschke, Ed., \u201cHypertext Transfer Protocol (HTTP/1.1): Semantics and Content,\u201d June 2014.) [RFC7231] at the Authorization Endpoint. Clients MAY use the HTTP GET or POST methods to send the Authorization Request to the Authorization Server. If using the HTTP GET method, the request parameters are serialized using URI Query String Serialization, per Section 13.1 (Query String Serialization). If using the HTTP POST method, the request parameters are serialized using Form Serialization, per Section 13.2 (Form Serialization).\nOpenID Connect uses the following OAuth 2.0 request parameters with the Authorization Code Flow:\n- scope\n- REQUIRED. OpenID Connect requests MUST contain the openid scope value. If the openid scope value is not present, the behavior is entirely unspecified. Other scope values MAY be present. Scope values used that are not understood by an implementation SHOULD be ignored. See Sections 5.4 (Requesting Claims using Scope Values) and 11 (Offline Access) for additional scope values defined by this specification.\n- response_type\n- REQUIRED. OAuth 2.0 Response Type value that determines the authorization processing flow to be used, including what parameters are returned from the endpoints used. When using the Authorization Code Flow, this value is code.\n- client_id\n- REQUIRED. OAuth 2.0 Client Identifier valid at the Authorization Server.\n- redirect_uri\n- REQUIRED. Redirection URI to which the response will be sent. This URI MUST exactly match one of the Redirection URI values for the Client pre-registered at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [RFC3986] (Berners-Lee, T., Fielding, R., and L. Masinter, \u201cUniform Resource Identifier (URI): Generic Syntax,\u201d January 2005.) (Simple String Comparison). When using this flow, the Redirection URI SHOULD use the https scheme; however, it MAY use the http scheme, provided that the Client Type is confidential, as defined in Section 2.1 of OAuth 2.0, and provided the OP allows the use of http Redirection URIs in this case. Also, if the Client is a native application, it MAY use the http scheme with localhost or the IP loopback literals 127.0.0.1 or [::1] as the hostname. The Redirection URI MAY use an alternate scheme, such as one that is intended to identify a callback into a native application.\n- state\n- RECOMMENDED. Opaque value used to maintain state between the request and the callback. Typically, Cross-Site Request Forgery (CSRF, XSRF) mitigation is done by cryptographically binding the value of this parameter with a browser cookie.\nOpenID Connect also uses the following OAuth 2.0 request parameter, which is defined in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014.) [OAuth.Responses]:\n- response_mode\n- OPTIONAL. Informs the Authorization Server of the mechanism to be used for returning parameters from the Authorization Endpoint. This use of this parameter is NOT RECOMMENDED when the Response Mode that would be requested is the default mode specified for the Response Type.\nThis specification also defines the following request parameters:\n- nonce\n- OPTIONAL. String value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. Sufficient entropy MUST be present in the nonce values used to prevent attackers from guessing values. For implementation notes, see Section 15.5.2 (Nonce Implementation Notes).\n- display\n- OPTIONAL. ASCII string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User. The defined values are:\n- page\n- The Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode.\n- popup\n- The Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over.\n- touch\n- The Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface.\n- wap\n- The Authorization Server SHOULD display the authentication and consent UI consistent with a \"feature phone\" type display.\n- The Authorization Server MAY also attempt to detect the capabilities of the User Agent and present an appropriate display.\n- If an OP receives a display value outside the set defined above that it does not understand, it MAY return an error or it MAY ignore it; in practice, not returning errors for not-understood values will help facilitate phasing in extensions using new display values.\n- prompt\n- OPTIONAL. Space-delimited, case-sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for reauthentication and consent. The defined values are:\n- none\n- The Authorization Server MUST NOT display any authentication or consent user interface pages. An error is returned if an End-User is not already authenticated or the Client does not have pre-configured consent for the requested Claims or does not fulfill other conditions for processing the request. The error code will typically be login_required, interaction_required, or another code defined in Section 3.1.2.6 (Authentication Error Response). This can be used as a method to check for existing authentication and/or consent.\n- login\n- The Authorization Server SHOULD prompt the End-User for reauthentication. If it cannot reauthenticate the End-User, it MUST return an error, typically login_required.\n- consent\n- The Authorization Server SHOULD prompt the End-User for consent before returning information to the Client. If it cannot obtain consent, it MUST return an error, typically consent_required.\n- select_account\n- The Authorization Server SHOULD prompt the End-User to select a user account. This enables an End-User who has multiple accounts at the Authorization Server to select amongst the multiple accounts that they might have current sessions for. If it cannot obtain an account selection choice made by the End-User, it MUST return an error, typically account_selection_required.\n- The prompt parameter can be used by the Client to make sure that the End-User is still present for the current session or to bring attention to the request. If this parameter contains none with any other value, an error is returned.\n- If an OP receives a prompt value outside the set defined above that it does not understand, it MAY return an error or it MAY ignore it; in practice, not returning errors for not-understood values will help facilitate phasing in extensions using new prompt values.\n- max_age\n- OPTIONAL. Maximum Authentication Age. Specifies the allowable elapsed time in seconds since the last time the End-User was actively authenticated by the OP. If the elapsed time is greater than this value, the OP MUST attempt to actively re-authenticate the End-User. (The max_age request parameter corresponds to the OpenID 2.0 PAPE (Recordon, D., Jones, M., Bufu, J., Ed., Daugherty, J., Ed., and N. Sakimura, \u201cOpenID Provider Authentication Policy Extension 1.0,\u201d December 2008.) [OpenID.PAPE] max_auth_age request parameter.) When max_age is used, the ID Token returned MUST include an auth_time Claim Value. Note that max_age=0 is equivalent to prompt=login.\n- ui_locales\n- OPTIONAL. End-User's preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 (Phillips, A., Ed. and M. Davis, Ed., \u201cTags for Identifying Languages,\u201d September 2009.) [RFC5646] language tag values, ordered by preference. For instance, the value \"fr-CA fr en\" represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider.\n- id_token_hint\n- OPTIONAL. ID Token previously issued by the Authorization Server being passed as a hint about the End-User's current or past authenticated session with the Client. If the End-User identified by the ID Token is already logged in or is logged in as a result of the request (with the OP possibly evaluating other information beyond the ID Token in this decision), then the Authorization Server returns a positive response; otherwise, it MUST return an error, such as login_required. When possible, an id_token_hint SHOULD be present when prompt=none is used and an invalid_request error MAY be returned if it is not; however, the server SHOULD respond successfully when possible, even if it is not present. The Authorization Server need not be listed as an audience of the ID Token when it is used as an id_token_hint value.\n- If the ID Token received by the RP from the OP is encrypted, to use it as an id_token_hint, the Client MUST decrypt the signed ID Token contained within the encrypted ID Token. The Client MAY re-encrypt the signed ID token to the Authentication Server using a key that enables the server to decrypt the ID Token and use the re-encrypted ID token as the id_token_hint value.\n- login_hint\n- OPTIONAL. Hint to the Authorization Server about the login identifier the End-User might use to log in (if necessary). This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier) and then wants to pass that value as a hint to the discovered authorization service. It is RECOMMENDED that the hint value match the value used for discovery. This value MAY also be a phone number in the format specified for the phone_number Claim. The use of this parameter is left to the OP's discretion.\n- acr_values\n- OPTIONAL. Requested Authentication Context Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request, with the values appearing in order of preference. The Authentication Context Class satisfied by the authentication performed is returned as the acr Claim Value, as specified in Section 2 (ID Token). The acr Claim is requested as a Voluntary Claim by this parameter.\nOther parameters MAY be sent. See Sections 3.2.2 (Authorization Endpoint), 3.3.2 (Authorization Endpoint), 5.2 (Claims Languages and Scripts), 5.5 (Requesting Claims using the \"claims\" Request Parameter), 6 (Passing Request Parameters as JWTs), and 7.2.1 (Providing Information with the \"registration\" Request Parameter) for additional Authorization Request parameters and parameter values defined by this specification.\nThe following is a non-normative example HTTP 302 redirect response by the Client, which triggers the User Agent to make an Authentication Request to the Authorization Endpoint (with line wraps within values for display purposes only):\nHTTP/1.1 302 Found Location: https://server.example.com/authorize? response_type=code &scope=openid%20profile%20email &client_id=s6BhdRkqt3 &state=af0ifjsldkj &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb\nThe following is the non-normative example request that would be sent by the User Agent to the Authorization Server in response to the HTTP 302 redirect response by the Client above (with line wraps within values for display purposes only):\nGET /authorize? response_type=code &scope=openid%20profile%20email &client_id=s6BhdRkqt3 &state=af0ifjsldkj &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1 Host: server.example.com\n| TOC |\nThe Authorization Server MUST validate the request received as follows:\nAs specified in OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749], Authorization Servers SHOULD ignore unrecognized request parameters.\nIf the Authorization Server encounters any error, it MUST return an error response, per Section 3.1.2.6 (Authentication Error Response).\n| TOC |\nIf the request is valid, the Authorization Server attempts to Authenticate the End-User or determines whether the End-User is Authenticated, depending upon the request parameter values used. The methods used by the Authorization Server to Authenticate the End-User (e.g., username and password, session cookies, etc.) are beyond the scope of this specification. An Authentication user interface MAY be displayed by the Authorization Server, depending upon the request parameter values used and the authentication methods used.\nThe Authorization Server MUST attempt to Authenticate the End-User in the following cases:\nThe Authorization Server MUST NOT interact with the End-User in the following case:\nWhen interacting with the End-User, the Authorization Server MUST employ appropriate measures against Cross-Site Request Forgery and Clickjacking as, described in Sections 10.12 and 10.13 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749].\n| TOC |\nOnce the End-User is authenticated, the Authorization Server MUST obtain an authorization decision before releasing information to the Relying Party. When permitted by the request parameters used, this MAY be done through an interactive dialogue with the End-User that makes it clear what is being consented to or by establishing consent via conditions for processing the request or other means (for example, via previous administrative consent). Sections 2 (ID Token) and 5.3 (UserInfo Endpoint) describe information release mechanisms.\n| TOC |\nAn Authentication Response is an OAuth 2.0 Authorization Response message returned from the OP's Authorization Endpoint in response to the Authorization Request message sent by the RP.\nWhen using the Authorization Code Flow, the Authorization Response MUST return the parameters defined in Section 4.1.2 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749] by adding them as query parameters to the redirect_uri specified in the Authorization Request using the application/x-www-form-urlencoded format, unless a different Response Mode was specified.\nThe following is a non-normative example successful response using this flow (with line wraps within values for display purposes only):\nHTTP/1.1 302 Found Location: https://client.example.org/cb? code=SplxlOBeZQQYbYS6WxSbIA &state=af0ifjsldkj\nFor implementation notes on the contents of the Authorization Code, see Section 15.5.1 (Authorization Code Implementation Notes).\n| TOC |\nAn Authentication Error Response is an OAuth 2.0 Authorization Error Response message returned from the OP's Authorization Endpoint in response to the Authorization Request message sent by the RP.\nIf the End-User denies the request or the End-User authentication fails, the OP (Authorization Server) informs the RP (Client) by using the Error Response parameters defined in Section 4.1.2.1 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749]. (HTTP errors unrelated to RFC 6749 are returned to the User Agent using the appropriate HTTP status code.)\nUnless the Redirection URI is invalid, the Authorization Server returns the Client to the Redirection URI specified in the Authorization Request with the appropriate error and state parameters. Other parameters SHOULD NOT be returned. If the Redirection URI is invalid, the Authorization Server MUST NOT redirect the User Agent to the invalid Redirection URI.\nIf the Response Mode value is not supported, the Authorization Server returns an HTTP response code of 400 (Bad Request) without Error Response parameters, since understanding the Response Mode is necessary to know how to return those parameters.\nIn addition to the error codes defined in Section 4.1.2.1 of OAuth 2.0, this specification also defines the following error codes:\n- interaction_required\n- The Authorization Server requires End-User interaction of some form to proceed. This error MAY be returned when the prompt parameter value in the Authentication Request is none, but the Authentication Request cannot be completed without displaying a user interface for End-User interaction.\n- login_required\n- The Authorization Server requires End-User authentication. This error MAY be returned when the prompt parameter value in the Authentication Request is none, but the Authentication Request cannot be completed without displaying a user interface for End-User authentication.\n- account_selection_required\n- The End-User is REQUIRED to select a session at the Authorization Server. The End-User MAY be authenticated at the Authorization Server with different associated accounts, but the End-User did not select a session. This error MAY be returned when the prompt parameter value in the Authentication Request is none, but the Authentication Request cannot be completed without displaying a user interface to prompt for a session to use.\n- consent_required\n- The Authorization Server requires End-User consent. This error MAY be returned when the prompt parameter value in the Authentication Request is none, but the Authentication Request cannot be completed without displaying a user interface for End-User consent.\n- invalid_request_uri\n- The request_uri in the Authorization Request returns an error or contains invalid data.\n- invalid_request_object\n- The request parameter contains an invalid Request Object.\n- request_not_supported\n- The OP does not support use of the request parameter defined in Section 6 (Passing Request Parameters as JWTs).\n- request_uri_not_supported\n- The OP does not support use of the request_uri parameter defined in Section 6 (Passing Request Parameters as JWTs).\n- registration_not_supported\n- The OP does not support use of the registration parameter defined in Section 7.2.1 (Providing Information with the \"registration\" Request Parameter).\nThe error response parameters are the following:\n- error\n- REQUIRED. Error code.\n- error_description\n- OPTIONAL. Human-readable ASCII encoded text description of the error.\n- error_uri\n- OPTIONAL. URI of a web page that includes additional information about the error.\n- state\n- OAuth 2.0 state value. REQUIRED if the Authorization Request included the state parameter. Set to the value received from the Client.\nWhen using the Authorization Code Flow, the error response parameters are added to the query component of the Redirection URI, unless a different Response Mode was specified.\nThe following is a non-normative example error response using this flow (with line wraps within values for display purposes only):\nHTTP/1.1 302 Found Location: https://client.example.org/cb? error=invalid_request &error_description= Unsupported%20response_type%20value &state=af0ifjsldkj\n| TOC |\nWhen using the Authorization Code Flow, the Client MUST validate the response according to RFC 6749, especially Sections 4.1.2 and 10.12.\n| TOC |\nTo obtain an Access Token, an ID Token, and optionally a Refresh Token, the RP (Client) sends a Token Request to the Token Endpoint to obtain a Token Response, as described in Section 3.2 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749], when using the Authorization Code Flow.\nCommunication with the Token Endpoint MUST utilize TLS. See Section 16.17 (TLS Requirements) for more information on using TLS.\n| TOC |\nA Client makes a Token Request by presenting its Authorization Grant (in the form of an Authorization Code) to the Token Endpoint using the grant_type value authorization_code, as described in Section 4.1.3 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749]. If the Client is a Confidential Client, then it MUST authenticate to the Token Endpoint using the authentication method registered for its client_id, as described in Section 9 (Client Authentication).\nThe Client sends the parameters to the Token Endpoint using the HTTP POST method and the Form Serialization, per Section 13.2 (Form Serialization), as described in Section 4.1.3 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749].\nThe following is a non-normative example of a Token Request (with line wraps within values for display purposes only):\nPOST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb\n| TOC |\nThe Authorization Server MUST validate the Token Request as follows:\n| TOC |\nAfter receiving and validating a valid and authorized Token Request from the Client, the Authorization Server returns a successful response that includes an ID Token and an Access Token. The parameters in the successful response are defined in Section 4.1.4 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749]. The response uses the application/json media type.\nThe OAuth 2.0 token_type response parameter value MUST be Bearer, as specified in OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, \u201cThe OAuth 2.0 Authorization Framework: Bearer Token Usage,\u201d October 2012.) [RFC6750], unless another Token Type has been negotiated with the Client. Servers SHOULD support the Bearer Token Type; use of other Token Types is outside the scope of this specification. Note that the token_type value is case insensitive.\nIn addition to the response parameters specified by OAuth 2.0, the following parameters MUST be included in the response:\n- id_token\n- ID Token value associated with the authenticated session.\nAll Token Responses that contain tokens, secrets, or other sensitive information MUST include the following HTTP response header fields and values:\n| Header Name | Header Value |\n|---|---|\n| Cache-Control | no-store |\n| HTTP Response Headers and Values |\nThe following is a non-normative example of a successful Token Response. The ID Token signature in the example can be verified with the key at Appendix A.7 (RSA Key Used in Examples).\nHTTP/1.1 200 OK Content-Type: application/json Cache-Control: no-store { \"access_token\": \"SlAV32hkKG\", \"token_type\": \"Bearer\", \"refresh_token\": \"8xLOxBtZp8\", \"expires_in\": 3600, \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ.ewogImlzc yI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4Mjg5 NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAibi0wUzZ fV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEzMTEyODA5Nz AKfQ.ggW8hZ1EuVLuxNuuIJKX_V8a_OMXzR0EHR9R6jgdqrOOF4daGU96Sr_P6q Jp6IcmD3HP99Obi1PRs-cwh3LO-p146waJ8IhehcwL7F09JdijmBqkvPeB2T9CJ NqeGpe-gccMg4vfKjkM8FcGvnzZUN4_KSP0aAp1tOJ1zZwgjxqGByKHiOtX7Tpd QyHE5lcMiKPXfEIQILVq0pc_E2DzL7emopWoaoZTF_m0_N0YzFC6g6EJbOEoRoS K5hoDalrcvRYLSrQAZZKflyuVCyixEoV9GfNQC3_osjzw2PAithfubEEBLuVVk4 XUVrWOLrLl0nx7RkKU8NXNHq-rvKMzqg\" }\nAs specified in OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749], Clients SHOULD ignore unrecognized response parameters.\n| TOC |\nIf the Token Request is invalid or unauthorized, the Authorization Server constructs the error response. The parameters of the Token Error Response are defined as in Section 5.2 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749]. The HTTP response body uses the application/json media type with HTTP response code of 400.\nThe following is a non-normative example Token Error Response:\nHTTP/1.1 400 Bad Request Content-Type: application/json Cache-Control: no-store { \"error\": \"invalid_request\" }\n| TOC |\nThe Client MUST validate the Token Response as follows:\n| TOC |\nThe contents of the ID Token are as described in Section 2 (ID Token). When using the Authorization Code Flow, these additional requirements for the following ID Token Claims apply:\n- at_hash\n- OPTIONAL. Access Token hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the access_token value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, hash the access_token value with SHA-256, then take the left-most 128 bits and base64url-encode them. The at_hash value is a case-sensitive string.\n| TOC |\nClients MUST validate the ID Token in the Token Response in the following manner:\n| TOC |\nWhen using the Authorization Code Flow, if the ID Token contains an at_hash Claim, the Client MAY use it to validate the Access Token in the same manner as for the Implicit Flow, as defined in Section 3.2.2.9 (Access Token Validation), but using the ID Token and Access Token returned from the Token Endpoint.\n| TOC |\nThis section describes how to perform authentication using the Implicit Flow. When using the Implicit Flow, all tokens are returned from the Authorization Endpoint; the Token Endpoint is not used.\nThe Implicit Flow is mainly used by Clients implemented in a browser using a scripting language. The Access Token and ID Token are returned directly to the Client, which may expose them to the End-User and applications that have access to the End-User's User Agent. The Authorization Server does not perform Client Authentication.\n| TOC |\nThe Implicit Flow follows the following steps:\n| TOC |\nWhen using the Implicit Flow, the Authorization Endpoint is used in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2 (Authorization Endpoint), with the exception of the differences specified in this section.\n| TOC |\nAuthentication Requests are made as defined in Section 3.1.2.1 (Authentication Request), except that these Authentication Request parameters are used as follows:\n- response_type\n- REQUIRED. OAuth 2.0 Response Type value that determines the authorization processing flow to be used, including what parameters are returned from the endpoints used. When using the Implicit Flow, this value is id_token token or id_token. The meanings of both of these values are defined in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014.) [OAuth.Responses]. No Access Token is returned when the value is id_token.\n- NOTE: While OAuth 2.0 also defines the token Response Type value for the Implicit Flow, OpenID Connect does not use this Response Type, since no ID Token would be returned.\n- redirect_uri\n- REQUIRED. Redirection URI to which the response will be sent. This URI MUST exactly match one of the Redirection URI values for the Client pre-registered at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [RFC3986] (Berners-Lee, T., Fielding, R., and L. Masinter, \u201cUniform Resource Identifier (URI): Generic Syntax,\u201d January 2005.) (Simple String Comparison). When using this flow, the Redirection URI MUST NOT use the http scheme unless the Client is a native application, in which case it MAY use the http scheme with localhost or the IP loopback literals 127.0.0.1 or [::1] as the hostname.\n- nonce\n- REQUIRED. String value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. Sufficient entropy MUST be present in the nonce values used to prevent attackers from guessing values. For implementation notes, see Section 15.5.2 (Nonce Implementation Notes).\nThe following is a non-normative example request using the Implicit Flow that would be sent by the User Agent to the Authorization Server in response to a corresponding HTTP 302 redirect response by the Client (with line wraps within values for display purposes only):\nGET /authorize? response_type=id_token%20token &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile &state=af0ifjsldkj &nonce=n-0S6_WzA2Mj HTTP/1.1 Host: server.example.com\n| TOC |\nWhen using the Implicit Flow, the Authentication Request is validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.2 (Authentication Request Validation).\n| TOC |\nWhen using the Implicit Flow, End-User Authentication is performed in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.3 (Authorization Server Authenticates End-User).\n| TOC |\nWhen using the Implicit Flow, End-User Consent is obtained in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.4 (Authorization Server Obtains End-User Consent/Authorization).\n| TOC |\nWhen using the Implicit Flow, Authentication Responses are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.5 (Successful Authentication Response), with the exception of the differences specified in this section.\nWhen using the Implicit Flow, all response parameters are added to the fragment component of the Redirection URI, as specified in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014.) [OAuth.Responses], unless a different Response Mode was specified.\nThese parameters are returned from the Authorization Endpoint:\n- access_token\n- OAuth 2.0 Access Token. This is returned unless the response_type value used is id_token.\n- token_type\n- OAuth 2.0 Token Type value. The value MUST be Bearer or another token_type value that the Client has negotiated with the Authorization Server. Clients implementing this profile MUST support the OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, \u201cThe OAuth 2.0 Authorization Framework: Bearer Token Usage,\u201d October 2012.) [RFC6750] specification. This profile only describes the use of bearer tokens. This is returned in the same cases as access_token is.\n- id_token\n- REQUIRED. ID Token.\n- state\n- OAuth 2.0 state value. REQUIRED if the state parameter is present in the Authorization Request. Clients MUST verify that the state value is equal to the value of state parameter in the Authorization Request.\n- expires_in\n- OPTIONAL. Expiration time of the Access Token in seconds since the response was generated.\nPer Section 4.2.2 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749], no code result is returned when using the Implicit Flow.\nThe following is a non-normative example of a successful response using the Implicit Flow (with line wraps for the display purposes only):\nHTTP/1.1 302 Found Location: https://client.example.org/cb# access_token=SlAV32hkKG &token_type=bearer &id_token=eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso &expires_in=3600 &state=af0ifjsldkj\n| TOC |\nWhen using the Implicit Flow, Authorization Error Responses are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.6 (Authentication Error Response), with the exception of the differences specified in this section.\nWhenever Error Response parameters are returned, such as when End-User denies the authorization or the End-User authentication fails, the Authorization Server MUST return the error Authorization Response in the fragment component of the Redirection URI, as defined in Section 4.2.2.1 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749] and OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014.) [OAuth.Responses], unless a different Response Mode was specified.\n| TOC |\nSince response parameters are returned in the Redirection URI fragment value, the Client needs to have the User Agent parse the fragment encoded values and pass them to on to the Client's processing logic for consumption. See Section 15.5.3 (Redirect URI Fragment Handling Implementation Notes) for implementation notes on URI fragment handling.\n| TOC |\nWhen using the Implicit Flow, the Client MUST validate the response as follows:\n| TOC |\nTo validate an Access Token issued from the Authorization Endpoint with an ID Token, the Client SHOULD do the following:\n| TOC |\nThe contents of the ID Token are as described in Section 2 (ID Token). When using the Implicit Flow, these additional requirements for the following ID Token Claims apply:\n- nonce\n- Use of the nonce Claim is REQUIRED for this flow.\n- at_hash\n- Access Token hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the access_token value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, hash the access_token value with SHA-256, then take the left-most 128 bits and base64url-encode them. The at_hash value is a case-sensitive string.\n- If the ID Token is issued from the Authorization Endpoint with an access_token value, which is the case for the response_type value id_token token, this is REQUIRED; it MAY NOT be used when no Access Token is issued, which is the case for the response_type value id_token.\n| TOC |\nWhen using the Implicit Flow, the contents of the ID Token MUST be validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.7 (ID Token Validation), with the exception of the differences specified in this section.\n| TOC |\nThis section describes how to perform authentication using the Hybrid Flow. When using the Hybrid Flow, some tokens are returned from the Authorization Endpoint and others are returned from the Token Endpoint. The mechanisms for returning tokens in the Hybrid Flow are specified in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014.) [OAuth.Responses].\n| TOC |\nThe Hybrid Flow follows the following steps:\n| TOC |\nWhen using the Hybrid Flow, the Authorization Endpoint is used in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2 (Authorization Endpoint), with the exception of the differences specified in this section.\n| TOC |\nAuthentication Requests are made as defined in Section 3.1.2.1 (Authentication Request), except that these Authentication Request parameters are used as follows:\n- response_type\n- REQUIRED. OAuth 2.0 Response Type value that determines the authorization processing flow to be used, including what parameters are returned from the endpoints used. When using the Hybrid Flow, this value is code id_token, code token, or code id_token token. The meanings of these values are defined in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014.) [OAuth.Responses].\n- nonce\n- REQUIRED if the Response Type of the request is code id_token or code id_token token and OPTIONAL when the Response Type of the request is code token. It is a string value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. Sufficient entropy MUST be present in the nonce values used to prevent attackers from guessing values. For implementation notes, see Section 15.5.2 (Nonce Implementation Notes).\nThe following is a non-normative example request using the Hybrid Flow that would be sent by the User Agent to the Authorization Server in response to a corresponding HTTP 302 redirect response by the Client (with line wraps within values for display purposes only):\nGET /authorize? response_type=code%20id_token &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile%20email &nonce=n-0S6_WzA2Mj &state=af0ifjsldkj HTTP/1.1 Host: server.example.com\n| TOC |\nWhen using the Hybrid Flow, the Authentication Request is validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.2 (Authentication Request Validation).\n| TOC |\nWhen using the Hybrid Flow, End-User Authentication is performed in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.3 (Authorization Server Authenticates End-User).\n| TOC |\nWhen using the Hybrid Flow, End-User Consent is obtained in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.4 (Authorization Server Obtains End-User Consent/Authorization).\n| TOC |\nWhen using the Hybrid Flow, Authentication Responses are made in the same manner as for the Implicit Flow, as defined in Section 3.2.2.5 (Successful Authentication Response), with the exception of the differences specified in this section.\nThese Authorization Endpoint results are used in the following manner:\n- access_token\n- OAuth 2.0 Access Token. This is returned when the response_type value used is code token, or code id_token token. (A token_type value is also returned in the same cases.)\n- id_token\n- ID Token. This is returned when the response_type value used is code id_token or code id_token token.\n- code\n- Authorization Code. This is always returned when using the Hybrid Flow.\nThe following is a non-normative example of a successful response using the Hybrid Flow (with line wraps for the display purposes only):\nHTTP/1.1 302 Found Location: https://client.example.org/cb# code=SplxlOBeZQQYbYS6WxSbIA &id_token=eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso &state=af0ifjsldkj\n| TOC |\nWhen using the Hybrid Flow, Authorization Error Responses are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.6 (Authentication Error Response), with the exception of the differences specified in this section.\nWhenever Error Response parameters are returned, such as when End-User denies the authorization or the End-User authentication fails, the Authorization Server MUST return the error Authorization Response in the fragment component of the Redirection URI, as defined in Section 4.2.2.1 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749] and OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014.) [OAuth.Responses], unless a different Response Mode was specified.\n| TOC |\nWhen using the Hybrid Flow, the same requirements for Redirection URI fragment parameter handling apply as do for the Implicit Flow, as defined in Section 3.2.2.7 (Redirect URI Fragment Handling). Also see Section 15.5.3 (Redirect URI Fragment Handling Implementation Notes) for implementation notes on URI fragment handling.\n| TOC |\nWhen using the Hybrid Flow, the Client MUST validate the response as follows:\n| TOC |\nWhen using the Hybrid Flow, Access Tokens returned from the Authorization Endpoint are validated in the same manner as for the Implicit Flow, as defined in Section 3.2.2.9 (Access Token Validation).\n| TOC |\nTo validate an Authorization Code issued from the Authorization Endpoint with an ID Token, the Client SHOULD do the following:\n| TOC |\nThe contents of the ID Token are as described in Section 2 (ID Token). When using the Hybrid Flow, these additional requirements for the following ID Token Claims apply to an ID Token returned from the Authorization Endpoint:\n- nonce\n- If a nonce parameter is present in the Authentication Request, Authorization Servers MUST include a nonce Claim in the ID Token.\n- at_hash\n- Access Token hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the access_token value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, hash the access_token value with SHA-256, then take the left-most 128 bits and base64url-encode them. The at_hash value is a case-sensitive string.\n- If the ID Token is issued from the Authorization Endpoint with an access_token value, which is the case for the response_type value code id_token token, this is REQUIRED; otherwise, its inclusion is OPTIONAL.\n- c_hash\n- Code hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the code value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is HS512, hash the code value with SHA-512, then take the left-most 256 bits and base64url-encode them. The c_hash value is a case-sensitive string.\n- If the ID Token is issued from the Authorization Endpoint with a code, which is the case for the response_type values code id_token and code id_token token, this is REQUIRED; otherwise, its inclusion is OPTIONAL.\n| TOC |\nWhen using the Hybrid Flow, the contents of an ID Token returned from the Authorization Endpoint MUST be validated in the same manner as for the Implicit Flow, as defined in Section 3.2.2.11 (ID Token Validation).\n| TOC |\nWhen using the Hybrid Flow, the Token Endpoint is used in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3 (Token Endpoint), with the exception of the differences specified in this section.\n| TOC |\nWhen using the Hybrid Flow, Token Requests are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.1 (Token Request).\n| TOC |\nWhen using the Hybrid Flow, Token Requests are validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.2 (Token Request Validation).\n| TOC |\nWhen using the Hybrid Flow, Token Responses are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.3 (Successful Token Response).\n| TOC |\nWhen using the Hybrid Flow, Token Error Responses are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.4 (Token Error Response).\n| TOC |\nWhen using the Hybrid Flow, Token Responses are validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.5 (Token Response Validation).\n| TOC |\nWhen using the Hybrid Flow, the contents of an ID Token returned from the Token Endpoint are the same as for an ID Token returned from the Authorization Endpoint, as defined in Section 3.3.2.11 (ID Token), with the exception of the differences specified in this section.\nIf an ID Token is returned from both the Authorization Endpoint and from the Token Endpoint, which is the case for the response_type values code id_token and code id_token token, the iss and sub Claim Values MUST be identical in both ID Tokens. All Claims about the Authentication event present in either SHOULD be present in both. If either ID Token contains Claims about the End-User, any that are present in both SHOULD have the same values in both. Note that the OP MAY choose to return fewer Claims about the End-User from the Authorization Endpoint, for instance, for privacy reasons. The at_hash and c_hash Claims MAY be omitted from the ID Token returned from the Token Endpoint even when these Claims are present in the ID Token returned from the Authorization Endpoint, because the ID Token and Access Token values returned from the Token Endpoint are already cryptographically bound together by the TLS encryption performed by the Token Endpoint.\n| TOC |\nWhen using the Hybrid Flow, the contents of an ID Token returned from the Token Endpoint MUST be validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.7 (ID Token Validation).\n| TOC |\nIf an Access Token is returned from both the Authorization Endpoint and from the Token Endpoint, which is the case for the response_type values code token and code id_token token, their values MAY be the same or they MAY be different. Note that different Access Tokens might be returned be due to the different security characteristics of the two endpoints and the lifetimes and the access to resources granted by them might also be different.\n| TOC |\nWhen using the Hybrid Flow, the Access Token returned from the Token Endpoint is validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.8 (Access Token Validation).\n| TOC |\nIn some cases, the login flow is initiated by an OpenID Provider or another party, rather than the Relying Party. In this case, the initiator redirects to the RP at its login initiation endpoint, which requests that the RP send an Authentication Request to a specified OP. Note that this login initiation endpoint can be a different page at the RP than the RP's default landing page. RPs supporting OpenID Connect Dynamic Client Registration 1.0 (Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023.) [OpenID.Registration] register this endpoint value using the initiate_login_uri Registration parameter.\nThe party initiating the login request does so by redirecting to the login initiation endpoint at the RP, passing the following parameters:\n- iss\n- REQUIRED. Issuer Identifier for the OP that the RP is to send the Authentication Request to. Its value MUST be a URL using the https scheme.\n- login_hint\n- OPTIONAL. Hint to the Authorization Server about the End-User to be authenticated. The meaning of this string-valued parameter is left to the OP's discretion. In common use cases, the value will contain an e-mail address, phone number, or username collected by the RP before requesting authentication at the OP. For example, this hint can be used by an RP after it asks the End-User for their e-mail address (or other identifier), passing that identifier as a hint to the OpenID Provider. It is RECOMMENDED that the hint value match the value provided for discovery. Other uses MAY include using the sub claim from the ID Token as the hint value or potentially other kinds of information about the requested authentication.\n- target_link_uri\n- OPTIONAL. URL that the RP is requested to redirect to after authentication. RPs MUST verify the value of the target_link_uri to prevent being used as an open redirector to external sites.\nThe parameters can either be passed as query parameters using the HTTP GET method or be passed as HTML form values that are auto-submitted in the User Agent, and thus are transmitted via the HTTP POST method.\nOther parameters MAY be sent, if defined by extensions. Any parameters used that are not understood MUST be ignored by the Client.\nClients SHOULD employ frame busting and other techniques to prevent End-Users from being logged in by third party sites without their knowledge through attacks such as Clickjacking. Refer to Section 4.4.1.9 of [RFC6819] (Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \u201cOAuth 2.0 Threat Model and Security Considerations,\u201d January 2013.) for more details.\n| TOC |\nThis section specifies how the Client can obtain Claims about the End-User and the Authentication event. It also defines a standard set of basic profile Claims. Pre-defined sets of Claims can be requested using specific scope values or individual Claims can be requested using the claims request parameter. The Claims can come directly from the OpenID Provider or from distributed sources as well.\n| TOC |\nThis specification defines a set of standard Claims. They can be requested to be returned either in the UserInfo Response, per Section 5.3.2 (Successful UserInfo Response), or in the ID Token, per Section 2 (ID Token).\n| Member | Type | Description |\n|---|---|---|\n| sub | string | Subject - Identifier for the End-User at the Issuer. |\n| name | string | End-User's full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User's locale and preferences. |\n| given_name | string | Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters. |\n| family_name | string | Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters. |\n| middle_name | string | Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used. |\n| nickname | string | Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael. |\n| preferred_username | string | Shorthand name by which the End-User wishes to be referred to at the RP, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The RP MUST NOT rely upon this value being unique, as discussed in Section 5.7 (Claim Stability and Uniqueness). |\n| profile | string | URL of the End-User's profile page. The contents of this Web page SHOULD be about the End-User. |\n| picture | string | URL of the End-User's profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User. |\n| website | string | URL of the End-User's Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with. |\n| string | End-User's preferred e-mail address. Its value MUST conform to the RFC 5322 (Resnick, P., Ed., \u201cInternet Message Format,\u201d October 2008.) [RFC5322] addr-spec syntax. The RP MUST NOT rely upon this value being unique, as discussed in Section 5.7 (Claim Stability and Uniqueness). | |\n| email_verified | boolean | True if the End-User's e-mail address has been verified; otherwise false. When this Claim Value is true, this means that the OP took affirmative steps to ensure that this e-mail address was controlled by the End-User at the time the verification was performed. The means by which an e-mail address is verified is context specific, and dependent upon the trust framework or contractual agreements within which the parties are operating. |\n| gender | string | End-User's gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable. |\n| birthdate | string | End-User's birthday, represented as an ISO 8601-1 (International Organization for Standardization, \u201cISO 8601-1:2019/Amd 1:2022. Date and time - Representations for information interchange - Part 1: Basic rules,\u201d October 2022.) [ISO8601\u20111] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform's date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates. |\n| zoneinfo | string | String from IANA Time Zone Database [IANA.time\u2011zones] (IANA, \u201cTime Zone Database,\u201d .) representing the End-User's time zone. For example, Europe/Paris or America/Los_Angeles. |\n| locale | string | End-User's locale, represented as a BCP47 (Phillips, A., Ed. and M. Davis, Ed., \u201cTags for Identifying Languages,\u201d September 2009.) [RFC5646] language tag. This is typically an ISO 639 Alpha-2 (International Organization for Standardization, \u201cISO 639:2023. Code for individual languages and language groups,\u201d November 2023.) [ISO639] language code in lowercase and an ISO 3166-1 Alpha-2 (International Organization for Standardization, \u201cISO 3166-1:2020. Codes for the representation of names of countries and their subdivisions - Part 1: Country codes,\u201d August 2020.) [ISO3166\u20111] country code in uppercase, separated by a dash. For example, en-US or fr-CA. As a compatibility note, some implementations have used an underscore as the separator rather than a dash, for example, en_US; Relying Parties MAY choose to accept this locale syntax as well. |\n| phone_number | string | End-User's preferred telephone number. E.164 (International Telecommunication Union, \u201cE.164: The international public telecommunication numbering plan,\u201d 2010.) [E.164] is RECOMMENDED as the format of this Claim, for example, +1 (425) 555-1212 or +56 (2) 687 2400. If the phone number contains an extension, it is RECOMMENDED that the extension be represented using the RFC 3966 (Schulzrinne, H., \u201cThe tel URI for Telephone Numbers,\u201d December 2004.) [RFC3966] extension syntax, for example, +1 (604) 555-1234;ext=5678. |\n| phone_number_verified | boolean | True if the End-User's phone number has been verified; otherwise false. When this Claim Value is true, this means that the OP took affirmative steps to ensure that this phone number was controlled by the End-User at the time the verification was performed. The means by which a phone number is verified is context specific, and dependent upon the trust framework or contractual agreements within which the parties are operating. When true, the phone_number Claim MUST be in E.164 format and any extensions MUST be represented in RFC 3966 format. |\n| address | JSON object | End-User's preferred postal address. The value of the address member is a JSON [RFC8259] (Bray, T., Ed., \u201cThe JavaScript Object Notation (JSON) Data Interchange Format,\u201d December 2017.) structure containing some or all of the members defined in Section 5.1.1 (Address Claim). |\n| updated_at | number | Time the End-User's information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time. |\n| Table 1: Registered Member Definitions |\n| TOC |\nThe Address Claim represents a physical mailing address. Implementations MAY return only a subset of the fields of an address, depending upon the information available and the End-User's privacy preferences. For example, the country and region might be returned without returning more fine-grained address information.\nImplementations MAY return just the full address as a single string in the formatted sub-field, or they MAY return just the individual component fields using the other sub-fields, or they MAY return both. If both variants are returned, they SHOULD represent the same address, with the formatted address indicating how the component fields are combined.\nAll the address values defined below are represented as JSON strings.\n- formatted\n- Full mailing address, formatted for display or use on a mailing label. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").\n- street_address\n- Full street address component, which MAY include house number, street name, Post Office Box, and multi-line extended street address information. This field MAY contain multiple lines, separated by newlines. Newlines can be represented either as a carriage return/line feed pair (\"\\r\\n\") or as a single line feed character (\"\\n\").\n- locality\n- City or locality component.\n- region\n- State, province, prefecture, or region component.\n- postal_code\n- Zip code or postal code component.\n- country\n- Country name component.\n| TOC |\nWhile this specification defines only a small set of Claims as standard Claims, other Claims MAY be used in conjunction with the standard Claims. When using such Claims, it is RECOMMENDED that collision-resistant names be used for the Claim Names, as described in the JSON Web Token (JWT) (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.) [JWT] specification. Alternatively, Private Claim Names can be safely used when naming conflicts are unlikely to arise, as described in the JWT specification. Or, if specific additional Claims will have broad and general applicability, they can be registered with Registered Claim Names, per the JWT specification.\n| TOC |\nHuman-readable Claim Values and Claim Values that reference human-readable values MAY be represented in multiple languages and scripts. To specify the languages and scripts, BCP47 (Phillips, A., Ed. and M. Davis, Ed., \u201cTags for Identifying Languages,\u201d September 2009.) [RFC5646] language tags are added to member names, delimited by a # character. For example, family_name#ja-Kana-JP expresses the Family Name in Katakana in Japanese, which is commonly used to index and represent the phonetics of the Kanji representation of the same name represented as family_name#ja-Hani-JP. As another example, both website and website#de Claim Values might be returned, referencing a Web site in an unspecified language and a Web site in German.\nSince Claim Names are case sensitive, it is strongly RECOMMENDED that language tag values used in Claim Names be spelled using the character case with which they are registered in the IANA \"Language Subtag Registry\" [IANA.Language] (IANA, \u201cLanguage Subtag Registry,\u201d .). In particular, normally language names are spelled with lowercase characters, region names are spelled with uppercase characters, and scripts are spelled with mixed case characters. However, since BCP47 language tag values are case insensitive, implementations SHOULD interpret the language tag values supplied in a case-insensitive manner.\nPer the recommendations in BCP47, language tag values for Claims SHOULD only be as specific as necessary. For instance, using fr might be sufficient in many contexts, rather than fr-CA or fr-FR. Where possible, OPs SHOULD try to match requested Claim locales with Claims it has. For instance, if the Client asks for a Claim with a de (German) language tag and the OP has a value tagged with de-CH (Swiss German) and no generic German value, it would be appropriate for the OP to return the Swiss German value to the Client. (This intentionally moves as much of the complexity of language tag matching to the OP as possible, to simplify Clients.)\nOpenID Connect defines the following Authorization Request parameter to enable specify the preferred languages and scripts to be used for the returned Claims:\n- claims_locales\n- OPTIONAL. End-User's preferred languages and scripts for Claims being returned, represented as a space-separated list of BCP47 (Phillips, A., Ed. and M. Davis, Ed., \u201cTags for Identifying Languages,\u201d September 2009.) [RFC5646] language tag values, ordered by preference. An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider.\nWhen the OP determines, either through the claims_locales parameter, or by other means, that the End-User and Client are requesting Claims in only one set of languages and scripts, it is RECOMMENDED that OPs return Claims without language tags when they employ this language and script. It is also RECOMMENDED that Clients be written in a manner that they can handle and utilize Claims using language tags.\n| TOC |\nThe UserInfo Endpoint is an OAuth 2.0 Protected Resource that returns Claims about the authenticated End-User. To obtain the requested Claims about the End-User, the Client makes a request to the UserInfo Endpoint using an Access Token obtained through OpenID Connect Authentication. These Claims are normally represented by a JSON object that contains a collection of name and value pairs for the Claims.\nCommunication with the UserInfo Endpoint MUST utilize TLS. See Section 16.17 (TLS Requirements) for more information on using TLS.\nThe UserInfo Endpoint MUST support the use of the HTTP GET and HTTP POST methods defined in RFC 7231 (Fielding, R., Ed. and J. Reschke, Ed., \u201cHypertext Transfer Protocol (HTTP/1.1): Semantics and Content,\u201d June 2014.) [RFC7231].\nThe UserInfo Endpoint MUST accept Access Tokens as OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, \u201cThe OAuth 2.0 Authorization Framework: Bearer Token Usage,\u201d October 2012.) [RFC6750].\nThe UserInfo Endpoint SHOULD support the use of Cross-Origin Resource Sharing (CORS) (Opera Software ASA, \u201cCross-Origin Resource Sharing,\u201d July 2010.) [CORS] and/or other methods as appropriate to enable JavaScript Clients and other Browser-Based Clients to access it.\n| TOC |\nThe Client sends the UserInfo Request using either HTTP GET or HTTP POST. The Access Token obtained from an OpenID Connect Authentication Request MUST be sent as a Bearer Token, per Section 2 of OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, \u201cThe OAuth 2.0 Authorization Framework: Bearer Token Usage,\u201d October 2012.) [RFC6750].\nIt is RECOMMENDED that the request use the HTTP GET method and the Access Token be sent using the Authorization header field.\nThe following is a non-normative example of a UserInfo Request:\nGET /userinfo HTTP/1.1 Host: server.example.com Authorization: Bearer SlAV32hkKG\n| TOC |\nThe UserInfo Claims MUST be returned as the members of a JSON object unless a signed or encrypted response was requested during Client Registration. The Claims defined in Section 5.1 (Standard Claims) can be returned, as can additional Claims not specified there.\nFor privacy reasons, OpenID Providers MAY elect to not return values for some requested Claims. It is not an error condition to not return a requested Claim.\nIf a Claim is not returned, that Claim Name SHOULD be omitted from the JSON object representing the Claims; it SHOULD NOT be present with a null or empty string value.\nThe sub (subject) Claim MUST always be returned in the UserInfo Response.\nNOTE: Due to the possibility of token substitution attacks (see Section 16.11 (Token Substitution)), the UserInfo Response is not guaranteed to be about the End-User identified by the sub (subject) element of the ID Token. The sub Claim in the UserInfo Response MUST be verified to exactly match the sub Claim in the ID Token; if they do not match, the UserInfo Response values MUST NOT be used.\nUpon receipt of the UserInfo Request, the UserInfo Endpoint MUST return the JSON Serialization of the UserInfo Response as in Section 13.3 (JSON Serialization) in the HTTP response body unless a different format was specified during Registration [OpenID.Registration] (Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023.). The UserInfo Endpoint MUST return a content-type header to indicate which format is being returned. The content-type of the HTTP response MUST be application/json if the response body is a text JSON object; the response body SHOULD be encoded using UTF-8.\nIf the UserInfo Response is signed and/or encrypted, then the Claims are returned in a JWT and the content-type MUST be application/jwt. The response MAY be encrypted without also being signed. If both signing and encryption are requested, the response MUST be signed then encrypted, with the result being a Nested JWT, as defined in [JWT] (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.).\nIf signed, the UserInfo Response MUST contain the Claims iss (issuer) and aud (audience) as members. The iss value MUST be the OP's Issuer Identifier URL. The aud value MUST be or include the RP's Client ID value.\nThe following is a non-normative example of a UserInfo Response:\nHTTP/1.1 200 OK Content-Type: application/json { \"sub\": \"248289761001\", \"name\": \"Jane Doe\", \"given_name\": \"Jane\", \"family_name\": \"Doe\", \"preferred_username\": \"j.doe\", \"email\": \"janedoe@example.com\", \"picture\": \"http://example.com/janedoe/me.jpg\" }\n| TOC |\nWhen an error condition occurs, the UserInfo Endpoint returns an Error Response as defined in Section 3 of OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, \u201cThe OAuth 2.0 Authorization Framework: Bearer Token Usage,\u201d October 2012.) [RFC6750]. (HTTP errors unrelated to RFC 6750 are returned to the User Agent using the appropriate HTTP status code.)\nThe following is a non-normative example of a UserInfo Error Response:\nHTTP/1.1 401 Unauthorized WWW-Authenticate: Bearer error=\"invalid_token\", error_description=\"The Access Token expired\"\n| TOC |\nThe Client MUST validate the UserInfo Response as follows:\n| TOC |\nOpenID Connect Clients use scope values, as defined in Section 3.3 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749], to specify what access privileges are being requested for Access Tokens. The scopes associated with Access Tokens determine what resources will be available when they are used to access OAuth 2.0 protected endpoints. Protected Resource endpoints MAY perform different actions and return different information based on the scope values and other parameters used when requesting the presented Access Token.\nFor OpenID Connect, scopes can be used to request that specific sets of information be made available as Claim Values.\nClaims requested by the following scopes are treated by Authorization Servers as Voluntary Claims.\nOpenID Connect defines the following scope values that are used to request Claims:\n- profile\n- OPTIONAL. This scope value requests access to the End-User's default profile Claims, which are: name, family_name, given_name, middle_name, nickname, preferred_username, profile, picture, website, gender, birthdate, zoneinfo, locale, and updated_at.\n- OPTIONAL. This scope value requests access to the email and email_verified Claims.\n- address\n- OPTIONAL. This scope value requests access to the address Claim.\n- phone\n- OPTIONAL. This scope value requests access to the phone_number and phone_number_verified Claims.\nMultiple scope values MAY be used by creating a space-delimited, case-sensitive list of ASCII scope values.\nThe Claims requested by the profile, email, address, and phone scope values are returned from the UserInfo Endpoint, as described in Section 5.3.2 (Successful UserInfo Response), when a response_type value is used that results in an Access Token being issued. However, when no Access Token is issued (which is the case for the response_type value id_token), the resulting Claims are returned in the ID Token.\nIn some cases, the End-User will be given the option to have the OpenID Provider decline to provide some or all information requested by RPs. To minimize the amount of information that the End-User is being asked to disclose, an RP can elect to only request a subset of the information available from the UserInfo Endpoint.\nThe following is a non-normative example of an unencoded scope request:\nscope=openid profile email phone\n| TOC |\nOpenID Connect defines the following Authorization Request parameter to enable requesting individual Claims and specifying parameters that apply to the requested Claims:\n- claims\n- OPTIONAL. This parameter is used to request that specific Claims be returned. The value is a JSON object listing the requested Claims.\nThe claims Authentication Request parameter requests that specific Claims be returned from the UserInfo Endpoint and/or in the ID Token. It is represented as a JSON object containing lists of Claims being requested from these locations. Properties of the Claims being requested MAY also be specified.\nSupport for the claims parameter is OPTIONAL. Should an OP not support this parameter and an RP uses it, the OP SHOULD return a set of Claims to the RP that it believes would be useful to the RP and the End-User using whatever heuristics it believes are appropriate. The claims_parameter_supported Discovery result indicates whether the OP supports this parameter.\nThe claims parameter value is represented in an OAuth 2.0 request as UTF-8 encoded JSON (which ends up being form-urlencoded when passed as an OAuth parameter). When used in a Request Object value, per Section 6.1 (Passing a Request Object by Value), the JSON is used as the value of the claims member.\nThe top-level members of the Claims request JSON object are:\n- userinfo\n- OPTIONAL. Requests that the listed individual Claims be returned from the UserInfo Endpoint. If present, the listed Claims are being requested to be added to any Claims that are being requested using scope values. If not present, the Claims being requested from the UserInfo Endpoint are only those requested using scope values.\n- When the userinfo member is used, the request MUST also use a response_type value that results in an Access Token being issued to the Client for use at the UserInfo Endpoint.\n- id_token\n- OPTIONAL. Requests that the listed individual Claims be returned in the ID Token. If present, the listed Claims are being requested to be added to the default Claims in the ID Token. If not present, the default ID Token Claims are requested, as per the ID Token definition in Section 2 (ID Token) and per the additional per-flow ID Token requirements in Sections 3.1.3.6 (ID Token), 3.2.2.10 (ID Token), 3.3.2.11 (ID Token), and 3.3.3.6 (ID Token).\nOther members MAY be present. Any members used that are not understood MUST be ignored.\nAn example Claims request is as follows:\n{ \"userinfo\": { \"given_name\": {\"essential\": true}, \"nickname\": null, \"email\": {\"essential\": true}, \"email_verified\": {\"essential\": true}, \"picture\": null, \"http://example.info/claims/groups\": null }, \"id_token\": { \"auth_time\": {\"essential\": true}, \"acr\": {\"values\": [\"urn:mace:incommon:iap:silver\"] } } }\n| TOC |\nThe userinfo and id_token members of the claims request both are JSON objects with the names of the individual Claims being requested as the member names. The member values MUST be one of the following:\n- null\n- Indicates that this Claim is being requested in the default manner. In particular, this is a Voluntary Claim. For instance, the Claim request:\nrequests the given_name Claim in the default manner.\"given_name\": null- JSON Object\n- Used to provide additional information about the Claim being requested. This specification defines the following members:\n- essential\n- OPTIONAL. Indicates whether the Claim being requested is an Essential Claim. If the value is true, this indicates that the Claim is an Essential Claim. For instance, the Claim request:\ncan be used to specify that it is Essential to return an auth_time Claim Value.\"auth_time\": {\"essential\": true}- If the value is false, it indicates that it is a Voluntary Claim. The default is false.\n- By requesting Claims as Essential Claims, the RP indicates to the End-User that releasing these Claims will ensure a smooth authorization for the specific task requested by the End-User. Note that even if the Claims are not available because the End-User did not authorize their release or they are not present, the Authorization Server MUST NOT generate an error when Claims are not returned, whether they are Essential or Voluntary, unless otherwise specified in the description of the specific claim.\n- value\n- OPTIONAL. Requests that the Claim be returned with a particular value. For instance, the Claim request:\ncan be used to specify that the request apply to the End-User with Subject Identifier 248289761001.\"sub\": {\"value\": \"248289761001\"}- The value of the value member MUST be a valid value for the Claim being requested. Definitions of individual Claims can include requirements on how and whether the value qualifier is to be used when requesting that Claim. An equality comparison is used to determine whether the requested Claim value matches.\n- When the Claim value does not match the requested value, the Claim is not included in the response. If the Claim was sub, a mismatch MUST cause the authentication to fail, as described in Section 3.1.2.2 (Authentication Request Validation).\n- values\n- OPTIONAL. Requests that the Claim be returned with one of a set of values, with the values appearing in order of preference. This is processed equivalently to a value request, except that a choice of acceptable Claim values is provided.\n- For instance, the Claim request:\nspecifies that it is Essential that the acr Claim be returned with either the value urn:mace:incommon:iap:silver or urn:mace:incommon:iap:bronze.\"acr\": {\"essential\": true, \"values\": [\"urn:mace:incommon:iap:silver\", \"urn:mace:incommon:iap:bronze\"]}- The values in the values member array MUST be valid values for the Claim being requested. Definitions of individual Claims can include requirements on how and whether the values qualifier is to be used when requesting that Claim. An equality comparison is used to determine whether the requested Claim values match.\n- When the Claim value does not match any of the requested values, the Claim is not included in the response.\n- Other members MAY be defined to provide additional information about the requested Claims. Any members used that are not understood MUST be ignored.\nNote that when the claims request parameter is supported, the scope values that request Claims, as defined in Section 5.4 (Requesting Claims using Scope Values), are effectively shorthand methods for requesting sets of individual Claims. For example, using the scope value openid email and a response_type that returns an Access Token is equivalent to using the scope value openid and the following request for individual Claims.\nEquivalent of using the email scope value:\n{ \"userinfo\": { \"email\": null, \"email_verified\": null } }\n| TOC |\nIf the acr Claim is requested as an Essential Claim for the ID Token with a value or values parameter requesting specific Authentication Context Class Reference values and the implementation supports the claims parameter, the Authorization Server MUST return an acr Claim Value that matches one of the requested values. The Authorization Server MAY ask the End-User to re-authenticate with additional factors to meet this requirement. If this is an Essential Claim and the requirement cannot be met, then the Authorization Server MUST treat that outcome as a failed authentication attempt.\nNote that the RP MAY request the acr Claim as a Voluntary Claim by using the acr_values request parameter or by not including \"essential\": true in an individual acr Claim request. If the Claim is not Essential and a requested value cannot be provided, the Authorization Server SHOULD return the session's current acr as the value of the acr Claim. If the Claim is not Essential, the Authorization Server is not required to provide this Claim in its response.\nIf the client requests the acr Claim using both the acr_values request parameter and an individual acr Claim request for the ID Token listing specific requested values, the resulting behavior is unspecified.\n| TOC |\nAs described in Section 5.2 (Claims Languages and Scripts), human-readable Claim Values and Claim Values that reference human-readable values MAY be represented in multiple languages and scripts. Within a request for individual Claims, requested languages and scripts for particular Claims MAY be requested by including Claim Names that contain #-separated BCP47 (Phillips, A., Ed. and M. Davis, Ed., \u201cTags for Identifying Languages,\u201d September 2009.) [RFC5646] language tags in the Claims request, using the Claim Name syntax specified in Section 5.2 (Claims Languages and Scripts). For example, a Family Name in Katakana in Japanese can be requested using the Claim Name family_name#ja-Kana-JP and a Kanji representation of the Family Name in Japanese can be requested using the Claim Name family_name#ja-Hani-JP. A German-language Web site can be requested with the Claim Name website#de.\nIf an OP receives a request for human-readable Claims in a language and script that it does not have, any versions of those Claims returned that do not use the requested language and script SHOULD use a language tag in the Claim Name.\n| TOC |\nThree representations of Claim Values are defined by this specification:\n- Normal Claims\n- Claims that are directly asserted by the OpenID Provider.\n- Aggregated Claims\n- Claims that are asserted by a Claims Provider other than the OpenID Provider but are returned by OpenID Provider.\n- Distributed Claims\n- Claims that are asserted by a Claims Provider other than the OpenID Provider but are returned as references by the OpenID Provider.\nNormal Claims MUST be supported. Support for Aggregated Claims and Distributed Claims is OPTIONAL.\n| TOC |\nNormal Claims are represented as members in a JSON object. The Claim Name is the member name and the Claim Value is the member value.\nThe following is a non-normative response containing Normal Claims:\n{ \"sub\": \"248289761001\", \"name\": \"Jane Doe\", \"given_name\": \"Jane\", \"family_name\": \"Doe\", \"email\": \"janedoe@example.com\", \"picture\": \"http://example.com/janedoe/me.jpg\" }\n| TOC |\nAggregated and distributed Claims are represented by using special _claim_names and _claim_sources members of the JSON object containing the Claims.\n- _claim_names\n- JSON object whose member names are the Claim Names for the Aggregated and Distributed Claims. The member values are references to the member names in the _claim_sources member from which the actual Claim Values can be retrieved. The OP MAY omit some Claims available from referenced Claims Providers from the set of Claim Names.\n- _claim_sources\n- JSON object whose member names are referenced by the member values of the _claim_names member. The member values contain sets of Aggregated Claims or reference locations for Distributed Claims. The member values can have one of the following formats depending on whether it is providing Aggregated or Distributed Claims:\n- Aggregated Claims\n- JSON object that MUST contain the JWT member whose value is a JWT (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.) [JWT] that MUST contain all the Claims in the _claim_names object that references the corresponding _claim_sources member. Other members MAY be present. Any members used that are not understood MUST be ignored.\n- JWT\n- REQUIRED. JWT containing Claim Values.\n- The JWT SHOULD NOT contain a sub (subject) Claim unless its value is an identifier for the End-User at the Claims Provider (and not for the OpenID Provider or another party); this typically means that a sub Claim SHOULD NOT be provided.\n- Distributed Claims\n- JSON object that contains the following members and values:\n- endpoint\n- REQUIRED. OAuth 2.0 resource endpoint from which the associated Claim can be retrieved. The endpoint URL MUST return the Claim as a JWT.\n- access_token\n- OPTIONAL. Access Token enabling retrieval of the Claims from the endpoint URL by using the OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, \u201cThe OAuth 2.0 Authorization Framework: Bearer Token Usage,\u201d October 2012.) [RFC6750] protocol. Claims SHOULD be requested using the Authorization Request header field and Claims Providers MUST support this method. If the Access Token is not available, RPs MAY need to retrieve the Access Token out of band or use an Access Token that was pre-negotiated between the Claims Provider and RP, or the Claims Provider MAY reauthenticate the End-User and/or reauthorize the RP.\n- Since it is not an error condition to not return a requested Claim, RPs MUST be prepared to handle the condition that some Claims listed in _claim_sources are not returned from the Claims Provider. They SHOULD treat this the same as when any other requested Claim is not returned.\n- A sub (subject) Claim SHOULD NOT be returned from the Claims Provider unless its value is an identifier for the End-User at the Claims Provider (and not for the OpenID Provider or another party); this typically means that a sub Claim SHOULD NOT be provided.\nAn iss (issuer) Claim SHOULD be included in any JWT issued by a Claims Provider so that the Claims Provider's keys can be retrieved for signature validation of the JWT. The value of the Claim is the Claims Provider's Issuer Identifier URL.\nIn general, it is up to the OP when it is appropriate to use Aggregated Claims and Distributed Claims. In some cases, information about when to use what Claim Types might be negotiated out of band between RPs and OPs.\n| TOC |\nIn this non-normative example, Claims from Claims Provider A are combined with other Claims held by the OpenID provider, with the Claims from Claims Provider A being returned as Aggregated Claims.\nIn this example, these Claims about Jane Doe have been issued by Claims Provider A. (The example also includes the Claims Provider's Issuer Identifier URL.)\n{ \"iss\": \"https://a.example.com\", \"address\": { \"street_address\": \"1234 Hollywood Blvd.\", \"locality\": \"Los Angeles\", \"region\": \"CA\", \"postal_code\": \"90210\", \"country\": \"United States of America\"}, \"phone_number\": \"+1 (310) 123-4567\" }\nClaims Provider A signs the JSON Claims, representing them in a signed JWT: jwt_header.jwt_part2.jwt_part3. It is this JWT that is used by the OpenID Provider.\nIn this example, this JWT containing Jane Doe's Aggregated Claims from Claims Provider A is combined with other Normal Claims, and returned as the following set of Claims:\n{ \"sub\": \"248289761001\", \"name\": \"Jane Doe\", \"given_name\": \"Jane\", \"family_name\": \"Doe\", \"birthdate\": \"0000-03-22\", \"eye_color\": \"blue\", \"email\": \"janedoe@example.com\", \"_claim_names\": { \"address\": \"src1\", \"phone_number\": \"src1\" }, \"_claim_sources\": { \"src1\": {\"JWT\": \"jwt_header.jwt_part2.jwt_part3\"} } }\n| TOC |\nIn this non-normative example, the OpenID Provider combines Normal Claims that it holds with references to Claims held by two different Claims Providers, B and C, incorporating references to some of the Claims held by B and C as Distributed Claims.\nIn this example, these Claims about Jane Doe are held by Claims Provider B (Jane Doe's bank). (The example also includes the Claims Provider's Issuer Identifier URL.)\n{ \"iss\": \"https://bank.example.com\", \"shipping_address\": { \"street_address\": \"1234 Hollywood Blvd.\", \"locality\": \"Los Angeles\", \"region\": \"CA\", \"postal_code\": \"90210\", \"country\": \"United States of America\"}, \"payment_info\": \"Some_Card 1234 5678 9012 3456\", \"phone_number\": \"+1 (310) 123-4567\" }\nAlso in this example, this Claim about Jane Doe is held by Claims Provider C (a credit agency). (The example also includes the Claims Provider's Issuer Identifier URL.)\n{ \"iss\": \"https://creditagency.example.com\", \"credit_score\": 650 }\nThe OpenID Provider returns Jane Doe's Claims along with references to the Distributed Claims from Claims Provider B and Claims Provider C by sending the Access Tokens and URLs of locations from which the Distributed Claims can be retrieved:\n{ \"sub\": \"248289761001\", \"name\": \"Jane Doe\", \"given_name\": \"Jane\", \"family_name\": \"Doe\", \"email\": \"janedoe@example.com\", \"birthdate\": \"0000-03-22\", \"eye_color\": \"blue\", \"_claim_names\": { \"payment_info\": \"src1\", \"shipping_address\": \"src1\", \"credit_score\": \"src2\" }, \"_claim_sources\": { \"src1\": {\"endpoint\": \"https://bank.example.com/claim_source\"}, \"src2\": {\"endpoint\": \"https://creditagency.example.com/claims_here\", \"access_token\": \"ksj3n283dke\"} } }\nNote that not returning phone_number, which is held by Claims Provider B, demonstrates that not all Claims held by a utilized Claims Provider need be included.\n| TOC |\nThe sub (subject) and iss (issuer) Claims from the ID Token, used together, are the only Claims that an RP can rely upon as a stable identifier for the End-User, since the sub Claim MUST be locally unique and never reassigned within the Issuer for a particular End-User, as described in Section 2 (ID Token). Therefore, the only guaranteed unique identifier for a given End-User is the combination of the iss Claim and the sub Claim.\nAll other Claims carry no such guarantees across different issuers in terms of stability over time or uniqueness across users, and Issuers are permitted to apply local restrictions and policies. For instance, an Issuer MAY re-use an email Claim Value across different End-Users at different points in time, and the claimed email address for a given End-User MAY change over time. Therefore, other Claims such as email, phone_number, preferred_username, and name MUST NOT be used as unique identifiers for the End-User, whether obtained from the ID Token or the UserInfo Endpoint.\n| TOC |\nOpenID Connect defines the following Authorization Request parameters to enable Authentication Requests to be signed and optionally encrypted:\n- request\n- OPTIONAL. This parameter enables OpenID Connect requests to be passed in a single, self-contained parameter and to be optionally signed and/or encrypted. The parameter value is a Request Object value, as specified in Section 6.1 (Passing a Request Object by Value). It represents the request as a JWT whose Claims are the request parameters.\n- request_uri\n- OPTIONAL. This parameter enables OpenID Connect requests to be passed by reference, rather than by value. The request_uri value is a URL referencing a resource containing a Request Object value, which is a JWT containing the request parameters. This URL MUST use the https scheme unless the target Request Object is signed in a way that is verifiable by the OP.\nRequests using these parameters are represented as JWTs, which are respectively passed by value or by reference. The ability to pass requests by reference is particularly useful for large requests. If one of these parameters is used, the other MUST NOT be used in the same request.\nNote that the Request Objects defined here are compatible with those specified by The OAuth 2.0 Authorization Framework: JWT-Secured Authorization Request (JAR) (Sakimura, N., Bradley, J., and M. Jones, \u201cThe OAuth 2.0 Authorization Framework: JWT-Secured Authorization Request (JAR),\u201d August 2021.) [RFC9101].\n| TOC |\nThe request Authorization Request parameter enables OpenID Connect requests to be passed in a single, self-contained parameter and to be optionally signed and/or encrypted. It represents the request as a JWT whose Claims are the request parameters specified in Section 3.1.2 (Authorization Endpoint). This JWT is called a Request Object.\nSupport for the request parameter is OPTIONAL. The request_parameter_supported Discovery result indicates whether the OP supports this parameter. Should an OP not support this parameter and an RP uses it, the OP MUST return the request_not_supported error.\nWhen the request parameter is used, the OpenID Connect request parameter values contained in the JWT supersede those passed using the OAuth 2.0 request syntax. However, parameters MAY also be passed using the OAuth 2.0 request syntax even when a Request Object is used; this would typically be done to enable a cached, pre-signed (and possibly pre-encrypted) Request Object value to be used containing the fixed request parameters, while parameters that can vary with each request, such as state and nonce, are passed as OAuth 2.0 parameters.\nSo that the request is a valid OAuth 2.0 Authorization Request, values for the response_type and client_id parameters MUST be included using the OAuth 2.0 request syntax, since they are REQUIRED by OAuth 2.0. The values for these parameters MUST match those in the Request Object, if present.\nEven if a scope parameter is present in the Request Object value, a scope parameter MUST always be passed using the OAuth 2.0 request syntax containing the openid scope value to indicate to the underlying OAuth 2.0 logic that this is an OpenID Connect request.\nThe Request Object MAY be signed or unsigned (unsecured). When it is unsecured, this is indicated by use of the none algorithm [JWA] (Jones, M., \u201cJSON Web Algorithms (JWA),\u201d May 2015.) in the JOSE Header. If signed, the Request Object SHOULD contain the Claims iss (issuer) and aud (audience) as members. The iss value SHOULD be the Client ID of the RP, unless it was signed by a different party than the RP. The aud value SHOULD be or include the OP's Issuer Identifier URL.\nThe Request Object MAY also be encrypted using JWE (Jones, M. and J. Hildebrand, \u201cJSON Web Encryption (JWE),\u201d May 2015.) [JWE] and MAY be encrypted without also being signed. If both signing and encryption are performed, it MUST be signed then encrypted, with the result being a Nested JWT, as defined in [JWT] (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.).\nrequest and request_uri parameters MUST NOT be included in Request Objects.\nThe following is a non-normative example of the Claims in a Request Object before base64url-encoding and signing:\n{ \"iss\": \"s6BhdRkqt3\", \"aud\": \"https://server.example.com\", \"response_type\": \"code id_token\", \"client_id\": \"s6BhdRkqt3\", \"redirect_uri\": \"https://client.example.org/cb\", \"scope\": \"openid\", \"state\": \"af0ifjsldkj\", \"nonce\": \"n-0S6_WzA2Mj\", \"max_age\": 86400, \"claims\": { \"userinfo\": { \"given_name\": {\"essential\": true}, \"nickname\": null, \"email\": {\"essential\": true}, \"email_verified\": {\"essential\": true}, \"picture\": null }, \"id_token\": { \"gender\": null, \"birthdate\": {\"essential\": true}, \"acr\": {\"values\": [\"urn:mace:incommon:iap:silver\"]} } } }\nSigning it with the RS256 algorithm results in this Request Object value (with line wraps within values for display purposes only):\neyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ew0KICJpc3MiOiAiczZCaGRSa3 F0MyIsDQogImF1ZCI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsDQogInJl c3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsDQogImNsaWVudF9pZCI6ICJzNk JoZFJrcXQzIiwNCiAicmVkaXJlY3RfdXJpIjogImh0dHBzOi8vY2xpZW50LmV4YW1w bGUub3JnL2NiIiwNCiAic2NvcGUiOiAib3BlbmlkIiwNCiAic3RhdGUiOiAiYWYwaW Zqc2xka2oiLA0KICJub25jZSI6ICJuLTBTNl9XekEyTWoiLA0KICJtYXhfYWdlIjog ODY0MDAsDQogImNsYWltcyI6IA0KICB7DQogICAidXNlcmluZm8iOiANCiAgICB7DQ ogICAgICJnaXZlbl9uYW1lIjogeyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAgICAgIm5p Y2tuYW1lIjogbnVsbCwNCiAgICAgImVtYWlsIjogeyJlc3NlbnRpYWwiOiB0cnVlfS wNCiAgICAgImVtYWlsX3ZlcmlmaWVkIjogeyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAg ICAgInBpY3R1cmUiOiBudWxsDQogICAgfSwNCiAgICJpZF90b2tlbiI6IA0KICAgIH sNCiAgICAgImdlbmRlciI6IG51bGwsDQogICAgICJiaXJ0aGRhdGUiOiB7ImVzc2Vu dGlhbCI6IHRydWV9LA0KICAgICAiYWNyIjogeyJ2YWx1ZXMiOiBbInVybjptYWNlOm luY29tbW9uOmlhcDpzaWx2ZXIiXX0NCiAgICB9DQogIH0NCn0.nwwnNsk1-Zkbmnvs F6zTHm8CHERFMGQPhos-EJcaH4Hh-sMgk8ePrGhw_trPYs8KQxsn6R9Emo_wHwajyF KzuMXZFSZ3p6Mb8dkxtVyjoy2GIzvuJT_u7PkY2t8QU9hjBcHs68PkgjDVTrG1uRTx 0GxFbuPbj96tVuj11pTnmFCUR6IEOXKYr7iGOCRB3btfJhM0_AKQUfqKnRlrRscc8K ol-cSLWoYE9l5QqholImzjT_cMnNIznW9E7CDyWXTsO70xnB4SkG6pXfLSjLLlxmPG iyon_-Te111V8uE83IlzCYIb_NMXvtTIVc1jpspnTSD7xMbpL-2QgwUsAlMGzw\nThe following RSA public key, represented in JWK format, can be used to validate the Request Object signature in this and subsequent Request Object examples (with line wraps within values for display purposes only):\n{ \"kty\":\"RSA\", \"kid\":\"k2bdc\", \"n\":\"y9Lqv4fCp6Ei-u2-ZCKq83YvbFEk6JMs_pSj76eMkddWRuWX2aBKGHAtKlE5P 7_vn__PCKZWePt3vGkB6ePgzAFu08NmKemwE5bQI0e6kIChtt_6KzT5OaaXDF I6qCLJmk51Cc4VYFaxgqevMncYrzaW_50mZ1yGSFIQzLYP8bijAHGVjdEFgZa ZEN9lsn_GdWLaJpHrB3ROlS50E45wxrlg9xMncVb8qDPuXZarvghLL0HzOuYR adBJVoWZowDNTpKpk2RklZ7QaBO7XDv3uR7s_sf2g-bAjSYxYUGsqkNA9b3xV W53am_UZZ3tZbFTIh557JICWKHlWj5uzeJXaw\", \"e\":\"AQAB\" }\n| TOC |\nThe Client sends the Authorization Request to the Authorization Endpoint.\nThe following is a non-normative example of an Authorization Request using the request parameter (with line wraps within values for display purposes only):\nhttps://server.example.com/authorize? response_type=code%20id_token &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid &state=af0ifjsldkj &nonce=n-0S6_WzA2Mj &request=eyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ew0KICJpc3MiOiA iczZCaGRSa3F0MyIsDQogImF1ZCI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmN vbSIsDQogInJlc3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsDQogImNsaWV udF9pZCI6ICJzNkJoZFJrcXQzIiwNCiAicmVkaXJlY3RfdXJpIjogImh0dHBzOi8 vY2xpZW50LmV4YW1wbGUub3JnL2NiIiwNCiAic2NvcGUiOiAib3BlbmlkIiwNCiA ic3RhdGUiOiAiYWYwaWZqc2xka2oiLA0KICJub25jZSI6ICJuLTBTNl9XekEyTWo iLA0KICJtYXhfYWdlIjogODY0MDAsDQogImNsYWltcyI6IA0KICB7DQogICAidXN lcmluZm8iOiANCiAgICB7DQogICAgICJnaXZlbl9uYW1lIjogeyJlc3NlbnRpYWw iOiB0cnVlfSwNCiAgICAgIm5pY2tuYW1lIjogbnVsbCwNCiAgICAgImVtYWlsIjo geyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAgICAgImVtYWlsX3ZlcmlmaWVkIjogeyJ lc3NlbnRpYWwiOiB0cnVlfSwNCiAgICAgInBpY3R1cmUiOiBudWxsDQogICAgfSw NCiAgICJpZF90b2tlbiI6IA0KICAgIHsNCiAgICAgImdlbmRlciI6IG51bGwsDQo gICAgICJiaXJ0aGRhdGUiOiB7ImVzc2VudGlhbCI6IHRydWV9LA0KICAgICAiYWN yIjogeyJ2YWx1ZXMiOiBbInVybjptYWNlOmluY29tbW9uOmlhcDpzaWx2ZXIiXX0 NCiAgICB9DQogIH0NCn0.nwwnNsk1-ZkbmnvsF6zTHm8CHERFMGQPhos-EJcaH4H h-sMgk8ePrGhw_trPYs8KQxsn6R9Emo_wHwajyFKzuMXZFSZ3p6Mb8dkxtVyjoy2 GIzvuJT_u7PkY2t8QU9hjBcHs68PkgjDVTrG1uRTx0GxFbuPbj96tVuj11pTnmFC UR6IEOXKYr7iGOCRB3btfJhM0_AKQUfqKnRlrRscc8Kol-cSLWoYE9l5QqholImz jT_cMnNIznW9E7CDyWXTsO70xnB4SkG6pXfLSjLLlxmPGiyon_-Te111V8uE83Il zCYIb_NMXvtTIVc1jpspnTSD7xMbpL-2QgwUsAlMGzw\n| TOC |\nThe request_uri Authorization Request parameter enables OpenID Connect requests to be passed by reference, rather than by value. This parameter is used identically to the request parameter, other than that the Request Object value is retrieved from the resource at the specified URL, rather than passed by value.\nThe request_uri_parameter_supported Discovery result indicates whether the OP supports this parameter. Should an OP not support this parameter and an RP uses it, the OP MUST return the request_uri_not_supported error.\nWhen the request_uri parameter is used, the OpenID Connect request parameter values contained in the referenced JWT supersede those passed using the OAuth 2.0 request syntax. However, parameters MAY also be passed using the OAuth 2.0 request syntax even when a request_uri is used; this would typically be done to enable a cached, pre-signed (and possibly pre-encrypted) Request Object value to be used containing the fixed request parameters, while parameters that can vary with each request, such as state and nonce, are passed as OAuth 2.0 parameters.\nSo that the request is a valid OAuth 2.0 Authorization Request, values for the response_type and client_id parameters MUST be included using the OAuth 2.0 request syntax, since they are REQUIRED by OAuth 2.0. The values for these parameters MUST match those in the Request Object, if present.\nEven if a scope parameter is present in the referenced Request Object, a scope parameter MUST always be passed using the OAuth 2.0 request syntax containing the openid scope value to indicate to the underlying OAuth 2.0 logic that this is an OpenID Connect request.\nServers MAY cache the contents of the resources referenced by Request URIs. If the contents of the referenced resource could ever change, the URI SHOULD include the base64url-encoded SHA-256 hash of the referenced resource contents as the fragment component of the URI. If the fragment value used for a URI changes, that signals the server that any cached value for that URI with the old fragment value is no longer valid.\nNote that Clients MAY pre-register request_uri values using the request_uris parameter defined in Section 2.1 of the OpenID Connect Dynamic Client Registration 1.0 (Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023.) [OpenID.Registration] specification. OPs can require that request_uri values used be pre-registered with the require_request_uri_registration discovery parameter.\nThe entire Request URI SHOULD NOT exceed 512 ASCII characters.\nThe contents of the resource referenced by the URL MUST be a Request Object. The scheme used in the request_uri value MUST be https, unless the target Request Object is signed in a way that is verifiable by the Authorization Server. The request_uri value MUST be reachable by the Authorization Server and SHOULD be reachable by the Client.\nThe following is a non-normative example of the contents of a Request Object resource that can be referenced by a request_uri (with line wraps within values for display purposes only):\neyJhbGciOiJSUzI1NiIsImtpZCI6ImsyYmRjIn0.ew0KICJpc3MiOiAiczZCaGRSa3 F0MyIsDQogImF1ZCI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsDQogInJl c3BvbnNlX3R5cGUiOiAiY29kZSBpZF90b2tlbiIsDQogImNsaWVudF9pZCI6ICJzNk JoZFJrcXQzIiwNCiAicmVkaXJlY3RfdXJpIjogImh0dHBzOi8vY2xpZW50LmV4YW1w bGUub3JnL2NiIiwNCiAic2NvcGUiOiAib3BlbmlkIiwNCiAic3RhdGUiOiAiYWYwaW Zqc2xka2oiLA0KICJub25jZSI6ICJuLTBTNl9XekEyTWoiLA0KICJtYXhfYWdlIjog ODY0MDAsDQogImNsYWltcyI6IA0KICB7DQogICAidXNlcmluZm8iOiANCiAgICB7DQ ogICAgICJnaXZlbl9uYW1lIjogeyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAgICAgIm5p Y2tuYW1lIjogbnVsbCwNCiAgICAgImVtYWlsIjogeyJlc3NlbnRpYWwiOiB0cnVlfS wNCiAgICAgImVtYWlsX3ZlcmlmaWVkIjogeyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAg ICAgInBpY3R1cmUiOiBudWxsDQogICAgfSwNCiAgICJpZF90b2tlbiI6IA0KICAgIH sNCiAgICAgImdlbmRlciI6IG51bGwsDQogICAgICJiaXJ0aGRhdGUiOiB7ImVzc2Vu dGlhbCI6IHRydWV9LA0KICAgICAiYWNyIjogeyJ2YWx1ZXMiOiBbInVybjptYWNlOm luY29tbW9uOmlhcDpzaWx2ZXIiXX0NCiAgICB9DQogIH0NCn0.nwwnNsk1-Zkbmnvs F6zTHm8CHERFMGQPhos-EJcaH4Hh-sMgk8ePrGhw_trPYs8KQxsn6R9Emo_wHwajyF KzuMXZFSZ3p6Mb8dkxtVyjoy2GIzvuJT_u7PkY2t8QU9hjBcHs68PkgjDVTrG1uRTx 0GxFbuPbj96tVuj11pTnmFCUR6IEOXKYr7iGOCRB3btfJhM0_AKQUfqKnRlrRscc8K ol-cSLWoYE9l5QqholImzjT_cMnNIznW9E7CDyWXTsO70xnB4SkG6pXfLSjLLlxmPG iyon_-Te111V8uE83IlzCYIb_NMXvtTIVc1jpspnTSD7xMbpL-2QgwUsAlMGzw\n| TOC |\nThe Client stores the Request Object resource either locally or remotely at a URL the Server can access. This URL is the Request URI, request_uri.\nIf the Request Object includes requested values for Claims, it MUST NOT be revealed to anybody but the Authorization Server. As such, the request_uri MUST have appropriate entropy for its lifetime. It is RECOMMENDED that it be removed if it is known that it will not be used again or after a reasonable timeout unless access control measures are taken.\nThe following is a non-normative example of a Request URI value (with line wraps within values for display purposes only):\nhttps://client.example.org/request.jwt# GkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM\n| TOC |\nThe Client sends the Authorization Request to the Authorization Endpoint.\nThe following is a non-normative example of an Authorization Request using the request_uri parameter (with line wraps within values for display purposes only):\nhttps://server.example.com/authorize? response_type=code%20id_token &client_id=s6BhdRkqt3 &request_uri=https%3A%2F%2Fclient.example.org%2Frequest.jwt %23GkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM &state=af0ifjsldkj&nonce=n-0S6_WzA2Mj &scope=openid\n| TOC |\nUpon receipt of the Request, the Authorization Server MUST send an HTTP GET request to the request_uri to retrieve the referenced Request Object, unless it is already cached, and parse it to recreate the Authorization Request parameters.\nNote that the RP SHOULD use a unique URI for each request utilizing distinct parameters, or otherwise prevent the Authorization Server from caching the request_uri.\nThe following is a non-normative example of this fetch process:\nGET /request.jwt HTTP/1.1 Host: client.example.org\n| TOC |\nThere are several reasons that one might choose to use the request_uri parameter:\n| TOC |\nWhen the request or request_uri Authorization Request parameters are used, additional steps must be performed to validate the Authentication Request beyond those specified in Sections 3.1.2.2 (Authentication Request Validation), 3.2.2.2 (Authentication Request Validation), or 3.3.2.2 (Authentication Request Validation). These steps are to validate the JWT containing the Request Object and to validate the Request Object itself.\n| TOC |\nIf the Authorization Server has advertised JWE encryption algorithms in the request_object_encryption_alg_values_supported and request_object_encryption_enc_values_supported elements of its Discovery document [OpenID.Discovery] (Sakimura, N., Bradley, J., Jones, M., and E. Jay, \u201cOpenID Connect Discovery 1.0,\u201d December 2023.), or has supplied encryption algorithms by other means, these are used by the Client to encrypt the JWT.\nThe Authorization Server MUST decrypt the JWT in accordance with the JSON Web Encryption (Jones, M. and J. Hildebrand, \u201cJSON Web Encryption (JWE),\u201d May 2015.) [JWE] specification. The result MAY be either a signed or unsigned (unsecured) Request Object. In the former case, signature validation MUST be performed as defined in Section 6.3.2 (Signed Request Object).\nThe Authorization Server MUST return an error if decryption fails.\n| TOC |\nTo perform Signature Validation, the alg Header Parameter in the JOSE Header MUST match the value of the request_object_signing_alg set during Client Registration [OpenID.Registration] (Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023.) or a value that was pre-registered by other means. The signature MUST be validated against the appropriate key for that client_id and algorithm.\nThe Authorization Server MUST return an error if signature validation fails.\n| TOC |\nThe Authorization Server MUST assemble the set of Authorization Request parameters to be used from the Request Object value and the OAuth 2.0 Authorization Request parameters (minus the request or request_uri parameters). If the same parameter exists both in the Request Object and the OAuth Authorization Request parameters, the parameter in the Request Object is used. Using the assembled set of Authorization Request parameters, the Authorization Server then validates the request the normal manner for the flow being used, as specified in Sections 3.1.2.2 (Authentication Request Validation), 3.2.2.2 (Authentication Request Validation), or 3.3.2.2 (Authentication Request Validation).\n| TOC |\nOpenID Connect supports Self-Issued OpenID Providers - personal, self-hosted OPs that issue self-signed ID Tokens. Self-Issued OPs use the special Issuer Identifier https://self-issued.me.\nThe messages used to communicate with Self-Issued OPs are mostly the same as those used to communicate with other OPs. Specifications for the few additional parameters used and for the values of some parameters in the Self-Issued case are defined in this section.\n| TOC |\nIf the input identifier for the discovery process contains the domain self-issued.me, dynamic discovery is not performed. Instead, then the following static configuration values are used:\n{ \"authorization_endpoint\": \"openid:\", \"issuer\": \"https://self-issued.me\", \"scopes_supported\": [\"openid\", \"profile\", \"email\", \"address\", \"phone\"], \"response_types_supported\": [\"id_token\"], \"subject_types_supported\": [\"pairwise\"], \"id_token_signing_alg_values_supported\": [\"RS256\"], \"request_object_signing_alg_values_supported\": [\"none\", \"RS256\"] }\nNOTE: The OpenID Foundation plans to host the OpenID Provider site https://self-issued.me/, including its WebFinger service, so that performing discovery on it returns the above static discovery information, enabling RPs to not need any special processing for discovery of the Self-Issued OP. This site will be hosted on an experimental basis. Production implementations should not take a dependency upon it without a subsequent commitment by the OpenID Foundation to host the site in a manner intended for production use.\n| TOC |\nWhen using a Self-Issued OP, registration is not required. The Client can proceed without registration as if it had registered with the OP and obtained the following Client Registration Response:\n- client_id\n- redirect_uri value of the Client.\n- client_secret_expires_at\n- 0\nNOTE: The OpenID Foundation plans to host the (stateless) endpoint https://self-issued.me/registration/1.0/ that returns the response above, enabling RPs to not need any special processing for registration with the Self-Issued OP. This site will be hosted on an experimental basis. Production implementations should not take a dependency upon it without a subsequent commitment by the OpenID Foundation to host the site in a manner intended for production use.\n| TOC |\nOpenID Connect defines the following Authorization Request parameter to enable Clients to provide additional registration information to Self-Issued OpenID Providers:\n- registration\n- OPTIONAL. This parameter is used by the Client to provide information about itself to a Self-Issued OP that would normally be provided to an OP during Dynamic Client Registration. The value is a JSON object containing Client metadata values, as defined in Section 2.1 of the OpenID Connect Dynamic Client Registration 1.0 (Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023.) [OpenID.Registration] specification. The registration parameter SHOULD NOT be used when the OP is not a Self-Issued OP.\nNone of this information is REQUIRED by Self-Issued OPs, so the use of this parameter is OPTIONAL.\nThe registration parameter value is represented in an OAuth 2.0 request as a UTF-8 encoded JSON object (which ends up being form-urlencoded when passed as an OAuth parameter). When used in a Request Object value, per Section 6.1 (Passing a Request Object by Value), the JSON object is used as the value of the registration member.\nThe Registration parameters that would typically be used in requests to Self-Issued OPs are policy_uri, tos_uri, and logo_uri. If the Client uses more than one Redirection URI, the redirect_uris parameter would be used to register them. Finally, if the Client is requesting encrypted responses, it would typically use the jwks_uri, id_token_encrypted_response_alg and id_token_encrypted_response_enc parameters.\n| TOC |\nThe self-issued OP's Authorization Endpoint is the URI openid:.\nThe Client sends the Authentication Request to the Authorization Endpoint with the following parameters:\n- scope\n- REQUIRED. scope parameter value, as specified in Section 3.1.2 (Authorization Endpoint).\n- response_type\n- REQUIRED. Constant string value id_token.\n- client_id\n- REQUIRED. Client ID value for the Client, which in this case contains the redirect_uri value of the Client. Since the Client's redirect_uri URI value is communicated as the Client ID, a redirect_uri parameter is NOT REQUIRED to also be included in the request.\n- id_token_hint\n- OPTIONAL. id_token_hint parameter value, as specified in Section 3.1.2 (Authorization Endpoint). Encrypting content to Self-Issued OPs is not supported.\n- claims\n- OPTIONAL. claims parameter value, as specified in Section 5.5 (Requesting Claims using the \"claims\" Request Parameter).\n- registration\n- OPTIONAL. This parameter is used by the Client to provide information about itself to a Self-Issued OP that would normally be provided to an OP during Dynamic Client Registration, as specified in Section 7.2.1 (Providing Information with the \"registration\" Request Parameter).\n- request\n- OPTIONAL. Request Object value, as specified in Section 6.1 (Passing a Request Object by Value). Encrypting content to Self-Issued OPs is not supported.\nOther parameters MAY be sent. Note that all Claims are returned in the ID Token.\nThe entire URL MUST NOT exceed 2048 ASCII characters.\nThe following is a non-normative example HTTP 302 redirect response by the Client, which triggers the User Agent to make an Authentication Request to the Self-Issued OpenID Provider (with line wraps within values for display purposes only):\nHTTP/1.1 302 Found Location: openid://? response_type=id_token &client_id=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile &state=af0ifjsldkj &nonce=n-0S6_WzA2Mj \u00aeistration=%7B%22logo_uri%22%3A%22https%3A%2F%2F client.example.org%2Flogo.png%22%7D\n| TOC |\nOpenID Connect defines the following Claim for use in Self-Issued OpenID Provider Responses:\n- sub_jwk\n- REQUIRED. Public key used to check the signature of an ID Token issued by a Self-Issued OpenID Provider, as specified in Section 7 (Self-Issued OpenID Provider). The key is a bare key in JWK [JWK] (Jones, M., \u201cJSON Web Key (JWK),\u201d May 2015.) format (not an X.509 certificate value). The sub_jwk value is a JSON object. Use of the sub_jwk Claim is NOT RECOMMENDED when the OP is not Self-Issued.\nThe Self-Issued OpenID Provider response is the same as the normal Implicit Flow response with the following refinements. Since it is an Implicit Flow response, the response parameters will be returned in the URL fragment component, unless a different Response Mode was specified.\n| TOC |\nTo validate the ID Token received, the Client MUST do the following:\nThe following is a non-normative example of a base64url-decoded Self-Issued ID Token (with line wraps within values for display purposes only):\n{ \"iss\": \"https://self-issued.me\", \"sub\": \"NzbLsXh8uDCcd-6MNwXF4W_7noWXFZAfHkxZsRGC9Xs\", \"aud\": \"https://client.example.org/cb\", \"nonce\": \"n-0S6_WzA2Mj\", \"exp\": 1311281970, \"iat\": 1311280970, \"sub_jwk\": { \"kty\":\"RSA\", \"n\": \"0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx 4cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCiFV4n3oknjhMs tn64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65YGjQR0_FDW2 QvzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n91CbOpbI SD08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqb w0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw\", \"e\":\"AQAB\" } }\n| TOC |\nA Subject Identifier is a locally unique and never reassigned identifier within the Issuer for the End-User, which is intended to be consumed by the Client. Two Subject Identifier types are defined by this specification:\n- public\n- This provides the same sub (subject) value to all Clients. It is the default if the provider has no subject_types_supported element in its discovery document.\n- pairwise\n- This provides a different sub value to each Client, so as not to enable Clients to correlate the End-User's activities without permission.\nThe OpenID Provider's Discovery document MUST list its supported Subject Identifier types in the subject_types_supported element. If there is more than one type listed in the array, the Client MAY elect to provide its preferred identifier type using the subject_type parameter during Registration.\n| TOC |\nWhen pairwise Subject Identifiers are used, the OpenID Provider MUST calculate a unique sub (subject) value for each Sector Identifier. The Subject Identifier value MUST NOT be reversible by any party other than the OpenID Provider.\nProviders that use pairwise sub values and support Dynamic Client Registration (Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023.) [OpenID.Registration] SHOULD use the sector_identifier_uri parameter. It provides a way for a group of websites under common administrative control to have consistent pairwise sub values independent of the individual domain names. It also provides a way for Clients to change redirect_uri domains without having to re-register all of their users.\nIf the Client has not provided a value for sector_identifier_uri in Dynamic Client Registration (Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023.) [OpenID.Registration], the Sector Identifier used for pairwise identifier calculation is the host component of the registered redirect_uri. If there are multiple hostnames in the registered redirect_uris, the Client MUST register a sector_identifier_uri.\nWhen a sector_identifier_uri is provided, the host component of that URL is used as the Sector Identifier for the pairwise identifier calculation. The value of the sector_identifier_uri MUST be a URL using the https scheme that points to a JSON file containing an array of redirect_uri values. The values of the registered redirect_uris MUST be included in the elements of the array.\nAny algorithm with the following properties can be used by OpenID Providers to calculate pairwise Subject Identifiers:\nThree example methods are:\n| TOC |\nThis section defines a set of Client Authentication methods that are used by Clients to authenticate to the Authorization Server when using the Token Endpoint. During Client Registration, the RP (Client) MAY register a Client Authentication method. If no method is registered, the default method is client_secret_basic.\nThese Client Authentication methods are:\n- client_secret_basic\n- Clients that have received a client_secret value from the Authorization Server authenticate with the Authorization Server in accordance with Section 2.3.1 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749] using the HTTP Basic authentication scheme.\n- client_secret_post\n- Clients that have received a client_secret value from the Authorization Server, authenticate with the Authorization Server in accordance with Section 2.3.1 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749] by including the Client Credentials in the request body.\n- client_secret_jwt\n- Clients that have received a client_secret value from the Authorization Server create a JWT using an HMAC SHA algorithm, such as HMAC SHA-256. The HMAC (Hash-based Message Authentication Code) is calculated using the octets of the UTF-8 representation of the client_secret as the shared key.\n- The Client authenticates in accordance with JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants (Jones, M., Campbell, B., and C. Mortimore, \u201cJSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants,\u201d May 2015.) [OAuth.JWT] and Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants (Campbell, B., Mortimore, C., Jones, M., and Y. Goland, \u201cAssertion Framework for OAuth 2.0 Client Authentication and Authorization Grants,\u201d May 2015.) [OAuth.Assertions]. The JWT MUST contain the following REQUIRED Claim Values and MAY contain the following OPTIONAL Claim Values:\n- iss\n- REQUIRED. Issuer. This MUST contain the client_id of the OAuth Client.\n- sub\n- REQUIRED. Subject. This MUST contain the client_id of the OAuth Client.\n- aud\n- REQUIRED. Audience. The aud (audience) Claim. Value that identifies the Authorization Server as an intended audience. The Authorization Server MUST verify that it is an intended audience for the token. The Audience SHOULD be the URL of the Authorization Server's Token Endpoint.\n- jti\n- REQUIRED. JWT ID. A unique identifier for the token, which can be used to prevent reuse of the token. These tokens MUST only be used once, unless conditions for reuse were negotiated between the parties; any such negotiation is beyond the scope of this specification.\n- exp\n- REQUIRED. Expiration time on or after which the JWT MUST NOT be accepted for processing.\n- iat\n- OPTIONAL. Time at which the JWT was issued.\n- The JWT MAY contain other Claims. Any Claims used that are not understood MUST be ignored.\n- The authentication token MUST be sent as the value of the [OAuth.Assertions] (Campbell, B., Mortimore, C., Jones, M., and Y. Goland, \u201cAssertion Framework for OAuth 2.0 Client Authentication and Authorization Grants,\u201d May 2015.) client_assertion parameter.\n- The value of the [OAuth.Assertions] (Campbell, B., Mortimore, C., Jones, M., and Y. Goland, \u201cAssertion Framework for OAuth 2.0 Client Authentication and Authorization Grants,\u201d May 2015.) client_assertion_type parameter MUST be \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\", per [OAuth.JWT] (Jones, M., Campbell, B., and C. Mortimore, \u201cJSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants,\u201d May 2015.).\n- private_key_jwt\n- Clients that have registered a public key sign a JWT using that key. The Client authenticates in accordance with JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants (Jones, M., Campbell, B., and C. Mortimore, \u201cJSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants,\u201d May 2015.) [OAuth.JWT] and Assertion Framework for OAuth 2.0 Client Authentication and Authorization Grants (Campbell, B., Mortimore, C., Jones, M., and Y. Goland, \u201cAssertion Framework for OAuth 2.0 Client Authentication and Authorization Grants,\u201d May 2015.) [OAuth.Assertions]. The JWT MUST contain the following REQUIRED Claim Values and MAY contain the following OPTIONAL Claim Values:\n- iss\n- REQUIRED. Issuer. This MUST contain the client_id of the OAuth Client.\n- sub\n- REQUIRED. Subject. This MUST contain the client_id of the OAuth Client.\n- aud\n- REQUIRED. Audience. The aud (audience) Claim. Value that identifies the Authorization Server as an intended audience. The Authorization Server MUST verify that it is an intended audience for the token. The Audience SHOULD be the URL of the Authorization Server's Token Endpoint.\n- jti\n- REQUIRED. JWT ID. A unique identifier for the token, which can be used to prevent reuse of the token. These tokens MUST only be used once, unless conditions for reuse were negotiated between the parties; any such negotiation is beyond the scope of this specification.\n- exp\n- REQUIRED. Expiration time on or after which the JWT MUST NOT be accepted for processing.\n- iat\n- OPTIONAL. Time at which the JWT was issued.\n- The JWT MAY contain other Claims. Any Claims used that are not understood MUST be ignored.\n- The authentication token MUST be sent as the value of the [OAuth.Assertions] (Campbell, B., Mortimore, C., Jones, M., and Y. Goland, \u201cAssertion Framework for OAuth 2.0 Client Authentication and Authorization Grants,\u201d May 2015.) client_assertion parameter.\n- The value of the [OAuth.Assertions] (Campbell, B., Mortimore, C., Jones, M., and Y. Goland, \u201cAssertion Framework for OAuth 2.0 Client Authentication and Authorization Grants,\u201d May 2015.) client_assertion_type parameter MUST be \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\", per [OAuth.JWT] (Jones, M., Campbell, B., and C. Mortimore, \u201cJSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants,\u201d May 2015.).\nFor example (with line wraps within values for display purposes only):\nPOST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded grant_type=authorization_code& code=i1WsRn1uB1& client_id=s6BhdRkqt3& client_assertion_type= urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer& client_assertion=PHNhbWxwOl ... ZT- none\n- The Client does not authenticate itself at the Token Endpoint, either because it uses only the Implicit Flow (and so does not use the Token Endpoint) or because it is a Public Client with no Client Secret or other authentication mechanism.\n| TOC |\nDepending on the transport through which the messages are sent, the integrity of the message might not be guaranteed and the originator of the message might not be authenticated. To mitigate these risks, ID Token, UserInfo Response, Request Object, and Client Authentication JWT values can utilize JSON Web Signature (JWS) (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Signature (JWS),\u201d May 2015.) [JWS] to sign their contents. To achieve message confidentiality, these values can also use JSON Web Encryption (JWE) (Jones, M. and J. Hildebrand, \u201cJSON Web Encryption (JWE),\u201d May 2015.) [JWE] to encrypt their contents.\nWhen the message is both signed and encrypted, it MUST be signed first and then encrypted, per Section 16.14 (Signing and Encryption Order), with the result being a Nested JWT, as specified in [JWT] (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.). Note that all JWE encryption methods perform integrity checking.\nThe OP advertises its supported signing and encryption algorithms in its Discovery document or may supply this information by other means. The RP declares its required signing and encryption algorithms in its Dynamic Registration request or may communicate this information by other means.\nThe OP advertises its public keys via its Discovery document or may supply this information by other means. The RP declares its public keys via its Dynamic Registration request or may communicate this information by other means.\n| TOC |\nThe signing party MUST select a signature algorithm based on the algorithms supported by the recipient.\n- Asymmetric Signatures\n- When using RSA or ECDSA Signatures, the alg Header Parameter value of the JOSE Header MUST be set to an appropriate algorithm as defined in JSON Web Algorithms (Jones, M., \u201cJSON Web Algorithms (JWA),\u201d May 2015.) [JWA]. The private key used to sign the content MUST be associated with a public key used for signature verification published by the sender in its JWK Set document. If there are multiple keys in the referenced JWK Set document, a kid value MUST be provided in the JOSE Header. The key usage of the respective keys MUST support signing.\n- Symmetric Signatures\n- When using MAC-based signatures, the alg Header Parameter value of the JOSE Header MUST be set to a MAC algorithm, as defined in JSON Web Algorithms (Jones, M., \u201cJSON Web Algorithms (JWA),\u201d May 2015.) [JWA]. The MAC key used is the octets of the UTF-8 representation of the client_secret value. See Section 16.19 (Symmetric Key Entropy) for a discussion of entropy requirements for client_secret values. Symmetric signatures MUST NOT be used by public (non-confidential) Clients because of their inability to keep secrets.\nSee Section 16.20 (Need for Signed Requests) for Security Considerations about the need for signed requests.\n| TOC |\nRotation of signing keys can be accomplished with the following approach. The signer publishes its keys in a JWK Set at its jwks_uri location and includes the kid of the signing key in the JOSE Header of each message to indicate to the verifier which key is to be used to validate the signature. Keys can be rolled over by periodically adding new keys to the JWK Set at the jwks_uri location. The signer can begin using a new key at its discretion and signals the change to the verifier using the kid value. The verifier knows to go back to the jwks_uri location to re-retrieve the keys when it sees an unfamiliar kid value. The JWK Set document at the jwks_uri SHOULD retain recently decommissioned signing keys for a reasonable period of time to facilitate a smooth transition.\n| TOC |\nThe encrypting party MUST select an encryption algorithm based on the algorithms supported by the recipient.\n- Asymmetric Encryption: RSA\n- The public key to which the content was encrypted MUST be a public key used for encryption published by the recipient in its JWK Set document. If there are multiple keys in the referenced JWK Set document, a kid value MUST be provided in the JOSE Header. Use the supported RSA encryption algorithm to encrypt a random Content Encryption Key to be used for encrypting the signed JWT. The key usage of the respective keys MUST include encryption.\n- Asymmetric Encryption: Elliptic Curve\n- Create an ephemeral Elliptic Curve public key for the epk element of the JOSE Header. The other public key used for the key agreement computation MUST be a public key published by the recipient in its JWK Set document. If there are multiple keys in the referenced JWK Set document, a kid value MUST be provided in the JOSE Header. Use the ECDH-ES algorithm to agree upon a Content Encryption Key to be used for encrypting the signed JWT. The key usage of the respective keys MUST support encryption.\n- Symmetric Encryption\n- The symmetric encryption key is derived from the client_secret value by using the left-most bits of a truncated SHA-2 hash of the octets of the UTF-8 representation of the client_secret. For keys of 256 or fewer bits, SHA-256 is used; for keys of 257-384 bits, SHA-384 is used; for keys of 385-512 bits, SHA-512 is used. The hash value MUST be truncated retaining the left-most bits to the appropriate bit length for the AES key wrapping or direct encryption algorithm used, for instance, truncating the SHA-256 hash to 128 bits for A128KW. If a symmetric key with greater than 512 bits is needed, a different method of deriving the key from the client_secret would have to be defined by an extension. Symmetric encryption MUST NOT be used by public (non-confidential) Clients because of their inability to keep secrets.\nSee Section 16.21 (Need for Encrypted Requests) for Security Considerations about the need for encrypted requests.\n| TOC |\nRotating encryption keys necessarily uses a different process than the one for signing keys because the encrypting party starts the process and thus cannot rely on a change in kid as a signal that keys need to change. The encrypting party still uses the kid Header Parameter in the JWE to tell the decrypting party which private key to use to decrypt, however, the encrypting party needs to first select the most appropriate key from those provided in the JWK Set at the recipient's jwks_uri location.\nTo rotate keys, the decrypting party can publish new keys at its jwks_uri location and remove from the JWK Set those that are being decommissioned. The jwks_uri SHOULD include a Cache-Control header in the response that contains a max-age directive, as defined in RFC 7234 (Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \u201cHypertext Transfer Protocol (HTTP/1.1): Caching,\u201d June 2014.) [RFC7234], which enables the encrypting party to safely cache the JWK Set and not have to re-retrieve the document for every encryption event. The decrypting party SHOULD remove decommissioned keys from the JWK Set referenced by jwks_uri but retain them internally for some reasonable period of time, coordinated with the cache duration, to facilitate a smooth transition between keys by allowing the encrypting party some time to obtain the new keys. The cache duration SHOULD also be coordinated with the issuance of new signing keys, as described in Section 10.1.1 (Rotation of Asymmetric Signing Keys).\n| TOC |\nOpenID Connect defines the following scope value to request offline access:\n- offline_access\n- OPTIONAL. This scope value requests that an OAuth 2.0 Refresh Token be issued that can be used to obtain an Access Token that grants access to the End-User's UserInfo Endpoint even when the End-User is not present (not logged in).\nWhen offline access is requested, a prompt parameter value of consent MUST be used unless other conditions for processing the request permitting offline access to the requested resources are in place. The OP MUST always obtain consent to returning a Refresh Token that enables offline access to the requested resources. A previously saved user consent is not always sufficient to grant offline access.\nUpon receipt of a scope parameter containing the offline_access value, the Authorization Server:\nThe use of Refresh Tokens is not exclusive to the offline_access use case. The Authorization Server MAY grant Refresh Tokens in other contexts that are beyond the scope of this specification.\n| TOC |\nA request to the Token Endpoint can also use a Refresh Token by using the grant_type value refresh_token, as described in Section 6 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749]. This section defines the behaviors for OpenID Connect Authorization Servers when Refresh Tokens are used.\n| TOC |\nTo refresh an Access Token, the Client MUST authenticate to the Token Endpoint using the authentication method registered for its client_id, as documented in Section 9 (Client Authentication). The Client sends the parameters via HTTP POST to the Token Endpoint using Form Serialization, per Section 13.2 (Form Serialization).\nThe following is a non-normative example of a Refresh Request (with line wraps within values for display purposes only):\nPOST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded client_id=s6BhdRkqt3 &client_secret=some_secret12345 &grant_type=refresh_token &refresh_token=8xLOxBtZp8 &scope=openid%20profile\nThe Authorization Server MUST validate the Refresh Token, MUST verify that it was issued to the Client, and must verify that the Client successfully authenticated it has a Client Authentication method.\n| TOC |\nUpon successful validation of the Refresh Token, the response body is the Token Response of Section 3.1.3.3 (Successful Token Response) except that it might not contain an id_token.\nIf an ID Token is returned as a result of a token refresh request, the following requirements apply:\nThe following is a non-normative example of a Refresh Response:\nHTTP/1.1 200 OK Content-Type: application/json Cache-Control: no-store { \"access_token\": \"TlBN45jURg\", \"token_type\": \"Bearer\", \"refresh_token\": \"9yNOxJtZa5\", \"expires_in\": 3600 }\n| TOC |\nIf the Refresh Request is invalid or unauthorized, the Authorization Server returns the Token Error Response as defined in Section 5.2 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749].\n| TOC |\nMessages are serialized using one of the following methods:\nThis section describes the syntax of these serialization methods; other sections describe when they can and must be used. Note that not all methods can be used for all messages.\n| TOC |\nIn order to serialize the parameters using the Query String Serialization, the Client constructs the string by adding the parameters and values to the query component of a URL using the application/x-www-form-urlencoded format as defined by [W3C.SPSD\u2011html401\u201120180327] (, \u201cHTML 4.01 Specification,\u201d March 2018.). Query String Serialization is typically used in HTTP GET requests. The same serialization method is also used when adding parameters to the fragment component of a URL.\nThe following is a non-normative example of this serialization (with line wraps within values for display purposes only):\nGET /authorize? response_type=code &scope=openid &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1 Host: server.example.com\n| TOC |\nParameters and their values are Form Serialized by adding the parameter names and values to the entity body of the HTTP request using the application/x-www-form-urlencoded format as defined by [W3C.SPSD\u2011html401\u201120180327] (, \u201cHTML 4.01 Specification,\u201d March 2018.). Form Serialization is typically used in HTTP POST requests.\nThe following is a non-normative example of this serialization (with line wraps within values for display purposes only):\nPOST /authorize HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded response_type=code &scope=openid &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb\n| TOC |\nThe parameters are serialized into a JSON object structure by adding each parameter at the highest structure level. Parameter names and string values are represented as JSON strings. Numerical values are represented as JSON numbers. Boolean values are represented as JSON booleans. Omitted parameters and parameters with no value SHOULD be omitted from the object and not represented by a JSON null value, unless otherwise specified. A parameter MAY have a JSON object or a JSON array as its value.\nThe following is a non-normative example of this serialization:\n{ \"access_token\": \"SlAV32hkKG\", \"token_type\": \"Bearer\", \"expires_in\": 3600, \"refresh_token\": \"8xLOxBtZp8\" }\n| TOC |\nProcessing some OpenID Connect messages requires comparing values in the messages to known values. For example, the Claim Names returned by the UserInfo Endpoint might be compared to specific Claim Names such as sub. Comparing Unicode [UNICODE] (The Unicode Consortium, \u201cThe Unicode Standard,\u201d .) strings, however, has significant security implications.\nTherefore, comparisons between JSON strings and other Unicode strings MUST be performed as specified below:\nIn several places, this specification uses space-delimited lists of strings. In all such cases, a single ASCII space character (0x20) MUST be used as the delimiter.\n| TOC |\nThis specification defines features used by both Relying Parties and OpenID Providers. It is expected that some OpenID Providers will require static, out-of-band configuration of RPs using them, whereas others will support dynamic usage by RPs without a pre-established relationship between them. For that reason, the mandatory-to-implement features for OPs are listed below in two groups: the first for all OPs and the second for \"Dynamic\" OpenID Providers.\n| TOC |\nAll OpenID Providers MUST implement the following features defined in this specification. This list augments the set of features that are already listed elsewhere as being \"REQUIRED\" or are described with a \"MUST\", and so is not, by itself, a comprehensive set of implementation requirements for OPs.\n- Signing ID Tokens with RSA SHA-256\n- OPs MUST support signing ID Tokens with the RSA SHA-256 algorithm (an alg value of RS256), unless the OP only supports returning ID Tokens from the Token Endpoint (as is the case for the Authorization Code Flow) and only allows Clients to register specifying none as the requested ID Token signing algorithm.\n- Prompt Parameter\n- OPs MUST support the prompt parameter, as defined in Section 3.1.2 (Authorization Endpoint), including the specified user interface behaviors such as none and login.\n- Display Parameter\n- OPs MUST support the display parameter, as defined in Section 3.1.2 (Authorization Endpoint). (Note that the minimum level of support required for this parameter is simply that its use must not result in an error.)\n- Preferred Locales\n- OPs MUST support requests for preferred languages and scripts for the user interface and for Claims via the ui_locales and claims_locales request parameters, as defined in Section 3.1.2 (Authorization Endpoint). (Note that the minimum level of support required for these parameters is simply to have their use not result in errors.)\n- Authentication Time\n- OPs MUST support returning the time at which the End-User authenticated via the auth_time Claim, when requested, as defined in Section 2 (ID Token).\n- Maximum Authentication Age\n- OPs MUST support enforcing a maximum authentication age via the max_age parameter, as defined in Section 3.1.2 (Authorization Endpoint).\n- Authentication Context Class Reference\n- OPs MUST support requests for specific Authentication Context Class Reference values via the acr_values parameter, as defined in Section 3.1.2 (Authorization Endpoint). (Note that the minimum level of support required for this parameter is simply to have its use not result in an error.)\n| TOC |\nIn addition to the features listed above, OpenID Providers supporting dynamic establishment of relationships with RPs that they do not have a pre-configured relationship with MUST also implement the following features defined in this and related specifications.\n- Response Types\n- These OpenID Providers MUST support the id_token Response Type and all that are not Self-Issued OPs MUST also support the code and id_token token Response Types.\n- Discovery\n- These OPs MUST support Discovery, as defined in OpenID Connect Discovery 1.0 (Sakimura, N., Bradley, J., Jones, M., and E. Jay, \u201cOpenID Connect Discovery 1.0,\u201d December 2023.) [OpenID.Discovery].\n- Dynamic Registration\n- These OPs MUST support Dynamic Client Registration, as defined in OpenID Connect Dynamic Client Registration 1.0 (Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023.) [OpenID.Registration].\n- UserInfo Endpoint\n- All dynamic OPs that issue Access Tokens MUST support the UserInfo Endpoint, as defined in Section 5.3 (UserInfo Endpoint). (Self-Issued OPs do not issue Access Tokens.)\n- Public Keys Published as Bare Keys\n- These OPs MUST publish their public keys as bare JWK keys (which MAY also be accompanied by X.509 representations of those keys).\n- Request URI\n- These OPs MUST support requests made using a Request Object value that is retrieved from a Request URI that is provided with the request_uri parameter, as defined in Section 6.2 (Passing a Request Object by Reference).\n| TOC |\nSome OpenID Connect installations can use a pre-configured set of OpenID Providers and/or Relying Parties. In those cases, it might not be necessary to support dynamic discovery of information about identities or services or dynamic registration of Clients.\nHowever, if installations choose to support unanticipated interactions between Relying Parties and OpenID Providers that do not have pre-configured relationships, they SHOULD accomplish this by implementing the facilities defined in the OpenID Connect Discovery 1.0 (Sakimura, N., Bradley, J., Jones, M., and E. Jay, \u201cOpenID Connect Discovery 1.0,\u201d December 2023.) [OpenID.Discovery] and OpenID Connect Dynamic Client Registration 1.0 (Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023.) [OpenID.Registration] specifications.\n| TOC |\nIn general, it is up to Relying Parties which features they use when interacting with OpenID Providers. However, some choices are dictated by the nature of their OAuth Client, such as whether it is a Confidential Client, capable of keeping secrets, in which case the Authorization Code Flow may be appropriate, or whether it is a Public Client, for instance, a User Agent Based Application or a statically registered Native Application, in which case the Implicit Flow may be appropriate.\nWhen using OpenID Connect features, those listed as being \"REQUIRED\" or are described with a \"MUST\" are mandatory to implement, when used by a Relying Party. Likewise, those features that are described as \"OPTIONAL\" need not be used or supported unless they provide value in the particular application context. Finally, when interacting with OpenID Providers that support Discovery, the OP's Discovery document can be used to dynamically determine which OP features are available for use by the RP.\n| TOC |\n| TOC |\nWhen using the Authorization Code or Hybrid flows, an ID Token is returned from the Token Endpoint in response to a Token Request using an Authorization Code. Some implementations may choose to encode state about the ID Token to be returned in the Authorization Code value. Others may use the Authorization Code value as an index into a database storing this state.\n| TOC |\nThe nonce parameter value needs to include per-session state and be unguessable to attackers. One method to achieve this for Web Server Clients is to store a cryptographically random value as an HttpOnly session cookie and use a cryptographic hash of the value as the nonce parameter. In that case, the nonce in the returned ID Token is compared to the hash of the session cookie to detect ID Token replay by third parties. A related method applicable to JavaScript Clients and other Browser-Based Clients is to store the cryptographically random value in HTML5 local storage and use a cryptographic hash of this value.\n| TOC |\nWhen response parameters are returned in the Redirection URI fragment value, the Client needs to have the User Agent parse the fragment encoded values and pass them to on to the Client's processing logic for consumption. User Agents that have direct access to cryptographic APIs may be able to be self-contained, for instance, with all Client code being written in JavaScript.\nHowever, if the Client does not run entirely in the User Agent, one way to achieve this is to post them to a Web Server Client for validation.\nThe following is an example of a JavaScript file that a Client might host at its redirect_uri. This is loaded by the redirect from the Authorization Server. The fragment component is parsed and then sent by POST to a URI that will validate and use the information received.\nFollowing is a non-normative example of a Redirect URI response:\nGET /cb HTTP/1.1 Host: client.example.org HTTP/1.1 200 OK Content-Type: text/html <script type=\"text/javascript\"> // First, parse the query string var params = {}, postBody = location.hash.substring(1), regex = /([^&=]+)=([^&]*)/g, m; while (m = regex.exec(postBody)) { params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]); } // And send the token over to the server var req = new XMLHttpRequest(); // using POST so query isn't logged req.open('POST', 'https://' + window.location.host + '/catch_response', true); req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); req.onreadystatechange = function (e) { if (req.readyState == 4) { if (req.status == 200) { // If the response from the POST is 200 OK, perform a redirect window.location = 'https://' + window.location.host + '/redirect_after_login' } // if the OAuth response is invalid, generate an error message else if (req.status == 400) { alert('There was an error processing the token') } else { alert('Something other than 200 was returned') } } }; req.send(postBody);\n| TOC |\nNOTE: Potential compatibility issues that were previously described in the original version of this specification have since been addressed.\n| TOC |\nThese related OPTIONAL specifications MAY be used in combination with this specification to provide additional functionality:\nThese implementer's guides are intended to serve as self-contained references for implementers of basic Web-based Relying Parties:\n| TOC |\nThis specification references the security considerations defined in Section 10 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749], and Section 5 of OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, \u201cThe OAuth 2.0 Authorization Framework: Bearer Token Usage,\u201d October 2012.) [RFC6750]. Furthermore, the OAuth 2.0 Threat Model and Security Considerations (Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \u201cOAuth 2.0 Threat Model and Security Considerations,\u201d January 2013.) [RFC6819] specification provides an extensive list of threats and controls that apply to this specification as well, given that it is based upon OAuth 2.0. ISO/IEC 29115 (International Organization for Standardization, \u201cISO/IEC 29115:2013. Information technology - Security techniques - Entity authentication assurance framework,\u201d April 2013.) [ISO29115] also provides threats and controls that implementers need to take into account. Implementers are highly advised to read these references in detail and apply the countermeasures described therein.\nIn addition, the following list of attack vectors and remedies are also considered.\n| TOC |\nIf appropriate measures are not taken, a request might be disclosed to an attacker, posing security and privacy threats.\nIn addition to what is stated in Section 5.1.1 of [RFC6819] (Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \u201cOAuth 2.0 Threat Model and Security Considerations,\u201d January 2013.), this standard provides a way to provide the confidentiality of the request end to end through the use of request or request_uri parameters, where the content of the request is an encrypted JWT with the appropriate key and cipher. This protects even against a compromised User Agent in the case of indirect request.\n| TOC |\nA malicious Server might masquerade as the legitimate server using various means. To detect such an attack, the Client needs to authenticate the server.\nIn addition to what is stated in Section 5.1.2 of [RFC6819] (Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \u201cOAuth 2.0 Threat Model and Security Considerations,\u201d January 2013.), this standard provides a way to authenticate the Server through either the use of Signed or Encrypted JWTs with an appropriate key and cipher.\n| TOC |\nAn Attacker might generate a bogus token or modify the token contents (such as Claims values or the signature) of an existing parseable token, causing the RP to grant inappropriate access to the Client. For example, an Attacker might modify the parseable token to extend the validity period; a Client might modify the parseable token to have access to information that they should not be able to view.\nThere are two ways to mitigate this attack:\n| TOC |\nAccess Tokens are credentials used to access Protected Resources, as defined in Section 1.4 of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749]. Access Tokens represent an End-User's authorization and MUST NOT be exposed to unauthorized parties.\n| TOC |\nThe server response might contain authentication data and Claims that include sensitive Client information. Disclosure of the response contents can make the Client vulnerable to other types of attacks.\nThe server response disclosure can be mitigated in the following two ways:\n| TOC |\nA response might be repudiated by the server if the proper mechanisms are not in place. For example, if a Server does not digitally sign a response, the Server can claim that it was not generated through the services of the Server.\nTo mitigate this threat, the response MAY be digitally signed by the Server using a key that supports non-repudiation. The Client SHOULD validate the digital signature to verify that it was issued by a legitimate Server and its integrity is intact.\n| TOC |\nSince it is possible for a compromised or malicious Client to send a request to the wrong party, a Client that was authenticated using only a bearer token can repudiate any transaction.\nTo mitigate this threat, the Server MAY require that the request be digitally signed by the Client using a key that supports non-repudiation. The Server SHOULD validate the digital signature to verify that it was issued by a legitimate Client and its integrity is intact.\n| TOC |\nAn Attacker uses the Access Token generated for one resource to obtain access to a second resource.\nTo mitigate this threat, the Access Token SHOULD be audience and scope restricted. One way of implementing it is to include the identifier of the resource for whom it was generated as audience. The resource verifies that incoming tokens include its identifier as the audience of the token.\n| TOC |\nAn Attacker attempts to use a one-time use token such as an Authorization Code that has already been used once with the intended Resource. To mitigate this threat, the token SHOULD include a timestamp and a short validity lifetime. The Relying Party then checks the timestamp and lifetime values to ensure that the token is currently valid.\nAlternatively, the server MAY record the state of the use of the token and check the status for each request.\n| TOC |\nIn addition to the attack patterns described in Section 4.4.1.1 of [RFC6819] (Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \u201cOAuth 2.0 Threat Model and Security Considerations,\u201d January 2013.), an Authorization Code can be captured in the User Agent where the TLS session is terminated if the User Agent is infected by malware. However, capturing it is not useful as long as either Client Authentication or an encrypted response is used.\n| TOC |\nToken Substitution is a class of attacks in which a malicious user swaps various tokens, including swapping an Authorization Code for a legitimate user with another token that the attacker has. One means of accomplishing this is for the attacker to copy a token out one session and use it in an HTTP message for a different session, which is easy to do when the token is available to the browser; this is known as the \"cut and paste\" attack.\nThe Implicit Flow of OAuth 2.0 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749] is not designed to mitigate this risk. In Section 10.16, it normatively requires that any use of the authorization process as a form of delegated End-User authentication to the Client MUST NOT use the Implicit Flow without employing additional security mechanisms that enable the Client to determine whether the ID Token and Access Token were issued for its use.\nIn OpenID Connect, this is mitigated through mechanisms provided through the ID Token. The ID Token is a signed security token that provides Claims such as iss (issuer), sub (subject), aud (audience), at_hash (access token hash), and c_hash (code hash). Using the ID Token, the Client is capable of detecting the Token Substitution Attack.\nThe c_hash in the ID Token enables Clients to prevent Authorization Code substitution. The at_hash in the ID Token enables Clients to prevent Access Token substitution.\nAlso, a malicious user may attempt to impersonate a more privileged user by subverting the communication channel between the Authorization Endpoint and Client, or the Token Endpoint and Client, for example by swapping the Authorization Code or reordering the messages, to convince the Token Endpoint that the attacker's authorization grant corresponds to a grant sent on behalf of a more privileged user.\nFor the HTTP binding defined by this specification, the responses to Token Requests are bound to the corresponding requests by message order in HTTP, as both the response containing the token and requests are protected by TLS, which will detect and prevent packet reordering.\nWhen designing another binding of this specification to a protocol incapable of strongly binding Token Endpoint requests to responses, additional mechanisms to address this issue MUST be utilized. One such mechanism could be to include an ID Token with a c_hash Claim in the token request and response.\n| TOC |\nA timing attack enables the attacker to obtain an unnecessary large amount of information through the elapsed time differences in the code paths taken by successful and unsuccessful decryption operations or successful and unsuccessful signature validation of a message. It can be used to reduce the effective key length of the cipher used.\nImplementations SHOULD NOT terminate the validation process at the instant of the finding an error but SHOULD continue running until all the octets have been processed to avoid this attack.\n| TOC |\nThere are various crypto related attacks possible depending on the method used for encryption and signature / integrity checking. Implementers need to consult the Security Considerations for the JWT (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.) [JWT] specification and specifications that it references to avoid the vulnerabilities identified in these specifications.\n| TOC |\nSignatures over encrypted text are not considered valid in many jurisdictions. Therefore, for integrity and non-repudiation, this specification requires signing the plain text JSON Claims, when signing is performed. If both signing and encryption are desired, it is performed on the JWS containing the signed Claims, with the result being a Nested JWT, as specified in [JWT] (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.). Note that since all JWE encryption algorithms provide integrity protection, there is no need to separately sign the encrypted content.\n| TOC |\nOpenID Connect supports multiple Issuers per Host and Port combination. The issuer returned by discovery MUST exactly match the value of iss in the ID Token.\nOpenID Connect treats the path component of any Issuer URI as being part of the Issuer Identifier. For instance, the subject \"1234\" with an Issuer Identifier of \"https://example.com\" is not equivalent to the subject \"1234\" with an Issuer Identifier of \"https://example.com/sales\".\nIt is RECOMMENDED that only a single Issuer per host be used. However, if a host supports multiple tenants, multiple Issuers for that host may be needed.\n| TOC |\nIn the Implicit Flow, the Access Token is returned in the fragment component of the Client's redirect_uri through HTTPS, thus it is protected between the OP and the User Agent, and between the User Agent and the RP. The only place it can be captured is the User Agent where the TLS session is terminated, which is possible if the User Agent is infected by malware or under the control of a malicious party.\n| TOC |\nImplementations MUST support TLS. Which version(s) ought to be implemented will vary over time and depend on the widespread deployment and known security vulnerabilities at the time of implementation. Implementations SHOULD follow the guidance in BCP 195 [RFC8996] (Moriarty, K. and S. Farrell, \u201cDeprecating TLS 1.0 and TLS 1.1,\u201d March 2021.) [RFC9325] (Sheffer, Y., Saint-Andre, P., and T. Fossati, \u201cRecommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS),\u201d November 2022.), which provides recommendations and requirements for improving the security of deployed services that use TLS.\nTo protect against information disclosure and tampering, confidentiality protection MUST be applied using TLS with a ciphersuite that provides confidentiality and integrity protection.\nWhenever TLS is used, a TLS server certificate check MUST be performed, per RFC 6125 (Saint-Andre, P. and J. Hodges, \u201cRepresentation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS),\u201d March 2011.) [RFC6125].\n| TOC |\nAccess Tokens might not be revocable by the Authorization Server. Access Token lifetimes SHOULD therefore be kept to single use or very short lifetimes.\nIf ongoing access to the UserInfo Endpoint or other Protected Resources is required, a Refresh Token can be used. The Client can then exchange the Refresh Token at the Token Endpoint for a fresh short-lived Access Token that can be used to access the resource.\nThe Authorization Server SHOULD clearly identify long-term grants to the User during Authorization. The Authorization Server SHOULD provide a mechanism for the End-User to revoke Access Tokens and Refresh Tokens granted to a Client.\n| TOC |\nIn Section 10.1 (Signing) and Section 10.2 (Encryption), keys are derived from the client_secret value. Thus, when used with symmetric signing or encryption operations, client_secret values MUST contain sufficient entropy to generate cryptographically strong keys. Also, client_secret values MUST also contain at least the minimum of number of octets required for MAC keys for the particular algorithm used. So for instance, for HS256, the client_secret value MUST contain at least 32 octets (and almost certainly SHOULD contain more, since client_secret values are likely to use a restricted alphabet).\n| TOC |\nIn some situations, Clients might need to use signed requests to ensure that the desired request parameters are delivered to the OP without having been tampered with. For instance, the max_age and acr_values provide more assurance about the nature of the authentication performed when delivered in signed requests.\n| TOC |\nIn some situations, knowing the contents of an OpenID Connect request can, in and of itself, reveal sensitive information about the End-User. For instance, knowing that the Client is requesting a particular Claim or that it is requesting that a particular authentication method be used can reveal sensitive information about the End-User. OpenID Connect enables requests to be encrypted to the OpenID Provider to prevent such potentially sensitive information from being revealed.\n| TOC |\nHTTP 307 redirects send a POST request to the party being redirected to that contains all the form data from the previous request. This can leak credentials intended for the OpenID Provider to the Relying Party. Therefore, HTTP 307 redirects MUST NOT be used when redirecting to the Redirection URI. Likewise, while HTTP 302 redirects are typically implemented in a way that does not do this, the use of HTTP 303 redirect is preferable, as it is defined not to do this.\n| TOC |\nNote that on iOS, multiple applications can register as handlers for a custom URI scheme, therefore it is not deterministic that the calling application will receive the Authentication Reply from the Self-Issued OpenID Provider. Use of a claimed URI is an alternative to using the openid: custom URI scheme.\nWhile it is possible to assign handlers to custom URI schemes and it is possible that the operating system could help the End-User select the correct handler, it is not possible to guarantee that the handler for a given custom URI scheme has not been replaced by a subsequently installed native application. At the time of this writing, there appears to be no fool-proof mitigation for this vulnerability.\n| TOC |\n| TOC |\nThe UserInfo Response typically contains Personally Identifiable Information (PII). As such, End-User consent for the release of the information for the specified purpose should be obtained at or prior to the authorization time in accordance with relevant regulations. The purpose of use is typically registered in association with the redirect_uris.\nOnly necessary UserInfo data should be stored at the Client and the Client SHOULD associate the received data with the purpose of use statement.\n| TOC |\nThe Resource Server SHOULD make End-Users' UserInfo access logs available to them so that they can monitor who accessed their data.\n| TOC |\nTo protect the End-User from possible correlation among Clients, the use of a Pairwise Pseudonymous Identifier (PPID) as the sub (subject) SHOULD be considered.\n| TOC |\nOffline access enables access to Claims when the user is not present, posing greater privacy risk than the Claims transfer when the user is present. Therefore, it is prudent to obtain explicit consent for offline access to resources. This specification mandates the use of the prompt parameter to obtain consent unless it is already known that the request complies with the conditions for processing the request in each jurisdiction.\nWhen an Access Token is returned via the User Agent using the Implicit Flow or Hybrid Flow, there is a greater risk of it being exposed to an attacker, who could later use it to access the UserInfo endpoint. If the Access Token does not enable offline access and the server can differentiate whether the Client request has been made offline or online, the risk will be substantially reduced. Therefore, this specification mandates ignoring the offline access request when the Access Token is transmitted through the User Agent. Note that differentiating between online and offline access from the server can be difficult especially for native clients. The server may well have to rely on heuristics. Also, the risk of exposure for the Access Token delivered through the User Agent for the Response Types of code token and token is the same. Thus, the implementations should be prepared to detect whether the Access Token was issued through the User Agent or directly from the Token Endpoint and deny offline access if the token was issued through the User Agent.\nNote that although these provisions require an explicit consent dialogue through the prompt parameter, the mere fact that the user pressed an \"accept\" button etc., might not constitute a valid consent. Developers should be aware that for the act of consent to be valid, typically, the impact of the terms have to be understood by the End-User, the consent must be freely given and not forced (i.e., other options have to be available), and the terms must fair and equitable. In general, it is advisable for the service to follow the required privacy principles in each jurisdiction and rely on other conditions for processing the request than simply explicit consent, as online self-service \"explicit consent\" often does not form a valid consent in some jurisdictions.\n| TOC |\n| TOC |\nThis specification registers the following Claims in the IANA \"JSON Web Token Claims\" registry [IANA.JWT.Claims] (IANA, \u201cJSON Web Token Claims,\u201d .) established by [JWT] (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d May 2015.).\n| TOC |\n| TOC |\nThis specification registers the following parameters in the IANA \"OAuth Parameters\" registry [IANA.OAuth.Parameters] (IANA, \u201cOAuth Parameters,\u201d .) established by RFC 6749 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749].\n| TOC |\n| TOC |\nThis specification registers the following errors in the IANA \"OAuth Extensions Error\" registry [IANA.OAuth.Parameters] (IANA, \u201cOAuth Parameters,\u201d .) established by RFC 6749 (Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d October 2012.) [RFC6749].\n| TOC |\n| TOC |\nThis specification registers the following URI scheme in the IANA \"Uniform Resource Identifier (URI) Schemes\" registry [IANA.URISchemes] (IANA, \u201cUniform Resource Identifier (URI) Schemes,\u201d .) established by RFC 7595 (Thaler, D., Ed., Hansen, T., and T. Hardie, \u201cGuidelines and Registration Procedures for URI Schemes,\u201d June 2015.) [RFC7595].\n| TOC |\n| TOC |\n| TOC |\n| [CORS] | Opera Software ASA, \u201cCross-Origin Resource Sharing,\u201d July 2010. |\n| [E.164] | International Telecommunication Union, \u201cE.164: The international public telecommunication numbering plan,\u201d 2010. |\n| [IANA.AMR] | IANA, \u201cAuthentication Method Reference Values.\u201d |\n| [IANA.JWT.Claims] | IANA, \u201cJSON Web Token Claims.\u201d |\n| [IANA.Language] | IANA, \u201cLanguage Subtag Registry.\u201d |\n| [IANA.OAuth.Parameters] | IANA, \u201cOAuth Parameters.\u201d |\n| [IANA.URISchemes] | IANA, \u201cUniform Resource Identifier (URI) Schemes.\u201d |\n| [IANA.time-zones] | IANA, \u201cTime Zone Database.\u201d |\n| [ISO29115] | International Organization for Standardization, \u201cISO/IEC 29115:2013. Information technology - Security techniques - Entity authentication assurance framework,\u201d ISO/IEC 29115:2013, April 2013. |\n| [ISO3166-1] | International Organization for Standardization, \u201cISO 3166-1:2020. Codes for the representation of names of countries and their subdivisions - Part 1: Country codes,\u201d August 2020. |\n| [ISO639] | International Organization for Standardization, \u201cISO 639:2023. Code for individual languages and language groups,\u201d November 2023. |\n| [ISO8601-1] | International Organization for Standardization, \u201cISO 8601-1:2019/Amd 1:2022. Date and time - Representations for information interchange - Part 1: Basic rules,\u201d October 2022. |\n| [JWA] | Jones, M., \u201cJSON Web Algorithms (JWA),\u201d RFC 7518, DOI 10.17487/RFC7518, May 2015. |\n| [JWE] | Jones, M. and J. Hildebrand, \u201cJSON Web Encryption (JWE),\u201d RFC 7516, DOI 10.17487/RFC7516, May 2015. |\n| [JWK] | Jones, M., \u201cJSON Web Key (JWK),\u201d RFC 7517, DOI 10.17487/RFC7517, May 2015. |\n| [JWS] | Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Signature (JWS),\u201d RFC 7515, DOI 10.17487/RFC7515, May 2015. |\n| [JWT] | Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Token (JWT),\u201d RFC 7519, DOI 10.17487/RFC7519, May 2015. |\n| [OAuth.Assertions] | Campbell, B., Mortimore, C., Jones, M., and Y. Goland, \u201cAssertion Framework for OAuth 2.0 Client Authentication and Authorization Grants,\u201d RFC 7521, DOI 10.17487/RFC7521, May 2015. |\n| [OAuth.JWT] | Jones, M., Campbell, B., and C. Mortimore, \u201cJSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants,\u201d RFC 7523, DOI 10.17487/RFC7523, May 2015. |\n| [OAuth.Responses] | de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, \u201cOAuth 2.0 Multiple Response Type Encoding Practices,\u201d February 2014. |\n| [OpenID.Discovery] | Sakimura, N., Bradley, J., Jones, M., and E. Jay, \u201cOpenID Connect Discovery 1.0,\u201d December 2023. |\n| [OpenID.Registration] | Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Dynamic Client Registration 1.0,\u201d December 2023. |\n| [RFC20] | Cerf, V., \u201cASCII format for Network Interchange,\u201d STD 80, RFC 20, DOI 10.17487/RFC0020, October 1969. |\n| [RFC2119] | Bradner, S., \u201cKey words for use in RFCs to Indicate Requirement Levels,\u201d BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997. |\n| [RFC3339] | Klyne, G. and C. Newman, \u201cDate and Time on the Internet: Timestamps,\u201d RFC 3339, DOI 10.17487/RFC3339, July 2002. |\n| [RFC3629] | Yergeau, F., \u201cUTF-8, a transformation format of ISO 10646,\u201d STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003. |\n| [RFC3966] | Schulzrinne, H., \u201cThe tel URI for Telephone Numbers,\u201d RFC 3966, DOI 10.17487/RFC3966, December 2004. |\n| [RFC3986] | Berners-Lee, T., Fielding, R., and L. Masinter, \u201cUniform Resource Identifier (URI): Generic Syntax,\u201d STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005. |\n| [RFC5322] | Resnick, P., Ed., \u201cInternet Message Format,\u201d RFC 5322, DOI 10.17487/RFC5322, October 2008. |\n| [RFC5646] | Phillips, A., Ed. and M. Davis, Ed., \u201cTags for Identifying Languages,\u201d BCP 47, RFC 5646, DOI 10.17487/RFC5646, September 2009. |\n| [RFC6125] | Saint-Andre, P. and J. Hodges, \u201cRepresentation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS),\u201d RFC 6125, DOI 10.17487/RFC6125, March 2011. |\n| [RFC6711] | Johansson, L., \u201cAn IANA Registry for Level of Assurance (LoA) Profiles,\u201d RFC 6711, DOI 10.17487/RFC6711, August 2012. |\n| [RFC6749] | Hardt, D., Ed., \u201cThe OAuth 2.0 Authorization Framework,\u201d RFC 6749, DOI 10.17487/RFC6749, October 2012. |\n| [RFC6750] | Jones, M. and D. Hardt, \u201cThe OAuth 2.0 Authorization Framework: Bearer Token Usage,\u201d RFC 6750, DOI 10.17487/RFC6750, October 2012. |\n| [RFC6819] | Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \u201cOAuth 2.0 Threat Model and Security Considerations,\u201d RFC 6819, DOI 10.17487/RFC6819, January 2013. |\n| [RFC7230] | Fielding, R., Ed. and J. Reschke, Ed., \u201cHypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing,\u201d RFC 7230, DOI 10.17487/RFC7230, June 2014. |\n| [RFC7231] | Fielding, R., Ed. and J. Reschke, Ed., \u201cHypertext Transfer Protocol (HTTP/1.1): Semantics and Content,\u201d RFC 7231, DOI 10.17487/RFC7231, June 2014. |\n| [RFC7234] | Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \u201cHypertext Transfer Protocol (HTTP/1.1): Caching,\u201d RFC 7234, DOI 10.17487/RFC7234, June 2014. |\n| [RFC8176] | Jones, M., Hunt, P., and A. Nadalin, \u201cAuthentication Method Reference Values,\u201d RFC 8176, DOI 10.17487/RFC8176, June 2017. |\n| [RFC8259] | Bray, T., Ed., \u201cThe JavaScript Object Notation (JSON) Data Interchange Format,\u201d STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017. |\n| [RFC8996] | Moriarty, K. and S. Farrell, \u201cDeprecating TLS 1.0 and TLS 1.1,\u201d BCP 195, RFC 8996, DOI 10.17487/RFC8996, March 2021. |\n| [RFC9325] | Sheffer, Y., Saint-Andre, P., and T. Fossati, \u201cRecommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS),\u201d BCP 195, RFC 9325, DOI 10.17487/RFC9325, November 2022. |\n| [UNICODE] | The Unicode Consortium, \u201cThe Unicode Standard.\u201d |\n| [USA15] | Whistler, K., \u201cUnicode Normalization Forms,\u201d Unicode Standard Annex 15, August 2023. |\n| [W3C.SPSD-html401-20180327] | \u201cHTML 4.01 Specification,\u201d W3C REC SPSD-html401-20180327, W3C SPSD-html401-20180327, March 2018. |\n| TOC |\n| [JWK.Thumbprint] | Jones, M. and N. Sakimura, \u201cJSON Web Key (JWK) Thumbprint,\u201d RFC 7638, DOI 10.17487/RFC7638, September 2015. |\n| [OAuth.Post] | Jones, M. and B. Campbell, \u201cOAuth 2.0 Form Post Response Mode,\u201d April 2015. |\n| [OpenID.2.0] | OpenID Foundation, \u201cOpenID Authentication 2.0,\u201d December 2007. |\n| [OpenID.BackChannel] | Jones, M. and J. Bradley, \u201cOpenID Connect Back-Channel Logout 1.0,\u201d December 2023. |\n| [OpenID.Basic] | Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, \u201cOpenID Connect Basic Client Implementer's Guide 1.0,\u201d December 2023. |\n| [OpenID.Core.Errata1] | Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, \u201cOpenID Connect Core 1.0 incorporating errata set 1,\u201d November 2014. |\n| [OpenID.Core.Final] | Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, \u201cOpenID Connect Core 1.0 (final),\u201d February 2014. |\n| [OpenID.FrontChannel] | Jones, M., \u201cOpenID Connect Front-Channel Logout 1.0,\u201d September 2022. |\n| [OpenID.Implicit] | Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, \u201cOpenID Connect Implicit Client Implementer's Guide 1.0,\u201d December 2023. |\n| [OpenID.PAPE] | Recordon, D., Jones, M., Bufu, J., Ed., Daugherty, J., Ed., and N. Sakimura, \u201cOpenID Provider Authentication Policy Extension 1.0,\u201d December 2008. |\n| [OpenID.RPInitiated] | Jones, M., de Medeiros, B., Agarwal, N., Sakimura, N., and J. Bradley, \u201cOpenID Connect RP-Initiated Logout 1.0,\u201d September 2022. |\n| [OpenID.Session] | de Medeiros, B., Agarwal, N., Sakimura, N., Bradley, J., and M. Jones, \u201cOpenID Connect Session Management 1.0,\u201d September 2022. |\n| [RFC4949] | Shirey, R., \u201cInternet Security Glossary, Version 2,\u201d FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007. |\n| [RFC7595] | Thaler, D., Ed., Hansen, T., and T. Hardie, \u201cGuidelines and Registration Procedures for URI Schemes,\u201d BCP 35, RFC 7595, DOI 10.17487/RFC7595, June 2015. |\n| [RFC9101] | Sakimura, N., Bradley, J., and M. Jones, \u201cThe OAuth 2.0 Authorization Framework: JWT-Secured Authorization Request (JAR),\u201d RFC 9101, DOI 10.17487/RFC9101, August 2021. |\n| [X.1252] | International Telecommunication Union, \u201cITU-T Recommendation X.1252 - Cyberspace security - Identity management - Baseline identity management terms and definitions,\u201d ITU-T X.1252, April 2010. |\n| TOC |\nThe following are non-normative examples of Authorization Requests with different response_type values and their responses (with line wraps within values for display purposes only):\n| TOC |\nGET /authorize? response_type=code &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile%20email &nonce=n-0S6_WzA2Mj &state=af0ifjsldkj HTTP/1.1 Host: server.example.com HTTP/1.1 302 Found Location: https://client.example.org/cb? code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk &state=af0ifjsldkj\n| TOC |\nGET /authorize? response_type=id_token &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile%20email &nonce=n-0S6_WzA2Mj &state=af0ifjsldkj HTTP/1.1 Host: server.example.com HTTP/1.1 302 Found Location: https://client.example.org/cb# id_token=eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ. ewogImlzcyI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsCiAic3ViIjog IjI0ODI4OTc2MTAwMSIsCiAiYXVkIjogInM2QmhkUmtxdDMiLAogIm5vbmNlIjog Im4tMFM2X1d6QTJNaiIsCiAiZXhwIjogMTMxMTI4MTk3MCwKICJpYXQiOiAxMzEx MjgwOTcwLAogIm5hbWUiOiAiSmFuZSBEb2UiLAogImdpdmVuX25hbWUiOiAiSmFu ZSIsCiAiZmFtaWx5X25hbWUiOiAiRG9lIiwKICJnZW5kZXIiOiAiZmVtYWxlIiwK ICJiaXJ0aGRhdGUiOiAiMDAwMC0xMC0zMSIsCiAiZW1haWwiOiAiamFuZWRvZUBl eGFtcGxlLmNvbSIsCiAicGljdHVyZSI6ICJodHRwOi8vZXhhbXBsZS5jb20vamFu ZWRvZS9tZS5qcGciCn0. NTibBYW_ZoNHGm4ZrWCqYA9oJaxr1AVrJCze6FEcac4t_EOQiJFbD2nVEPkUXPuM shKjjTn7ESLIFUnfHq8UKTGibIC8uqrBgQAcUQFMeWeg-PkLvDTHk43Dn4_aNrxh mWwMNQfkjqx3wd2Fvta9j8yG2Qn790Gwb5psGcmBhqMJUUnFrGpyxQDhFIzzodmP okM7tnUxBNj-JuES_4CE-BvZICH4jKLp0TMu-WQsVst0ss-vY2RPdU1MzL59mq_e Kk8Rv9XhxIr3WteA2ZlrgVyT0cwH3hlCnRUsLfHtIEb8k1Y_WaqKUu3DaKPxqRi6 u0rN7RO2uZYPzC454xe-mg &state=af0ifjsldkj\nThe value of the id_token parameter is the ID Token, which is a signed JWT, containing three base64url-encoded segments separated by period ('.') characters. The first segment represents the JOSE Header. Base64url decoding it will result in the following set of Header Parameters:\n{\"kid\":\"1e9gdk7\",\"alg\":\"RS256\"}\nThe alg value represents the algorithm that was used to sign the JWT, in this case RS256, representing RSASSA-PKCS1-v1_5 using SHA-256. The kid value is a key identifier used in identifying the key to be used to verify the signature. If the kid value is unknown to the RP, it needs to retrieve the contents of the OP's JWK Set again to obtain the OP's current set of keys.\nThe second segment represents the Claims in the ID Token. Verifying and decoding the ID Token will yield the following Claims:\n{ \"iss\": \"https://server.example.com\", \"sub\": \"248289761001\", \"aud\": \"s6BhdRkqt3\", \"nonce\": \"n-0S6_WzA2Mj\", \"exp\": 1311281970, \"iat\": 1311280970, \"name\": \"Jane Doe\", \"given_name\": \"Jane\", \"family_name\": \"Doe\", \"gender\": \"female\", \"birthdate\": \"0000-10-31\", \"email\": \"janedoe@example.com\", \"picture\": \"http://example.com/janedoe/me.jpg\" }\nThe third segment represents the ID Token signature, which is verified as described in [JWS] (Jones, M., Bradley, J., and N. Sakimura, \u201cJSON Web Signature (JWS),\u201d May 2015.).\n| TOC |\nGET /authorize? response_type=id_token%20token &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile%20email &nonce=n-0S6_WzA2Mj &state=af0ifjsldkj HTTP/1.1 Host: server.example.com HTTP/1.1 302 Found Location: https://client.example.org/cb# access_token=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y &token_type=Bearer &id_token=eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ. ewogImlzcyI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsCiAic3ViIjog IjI0ODI4OTc2MTAwMSIsCiAiYXVkIjogInM2QmhkUmtxdDMiLAogIm5vbmNlIjog Im4tMFM2X1d6QTJNaiIsCiAiZXhwIjogMTMxMTI4MTk3MCwKICJpYXQiOiAxMzEx MjgwOTcwLAogImF0X2hhc2giOiAiNzdRbVVQdGpQZnpXdEYyQW5wSzlSUSIKfQ. kdqTmftlaXg5WBYBr1wkxhkqCGZPc0k8vTiV5g2jj67jQ7XkrDamYx2bOkZLdZrp MPIzkdYB1nZI_G8vQGQuamRhJcEIt21kblGPZ-yhEhdkAiZIZLu38rChalDS2Mh0 glE_rke5XXRhmqqoEFFdziFdnO3p61-7y51co84OEAZvARSINQaOWIzvioRfs4zw IFOaT33Vpxfqr8HDyh31zo9eBW2dSQuCa071z0ENWChWoPliK1JCo_Bk9eDg2uwo 2ZwhsvHzj6TMQ0lYOTzufSlSmXIKfjlOsb3nftQeR697_hA-nMZyAdL8_NRfaC37 XnAbW8WB9wCfECp7cuNuOg &state=af0ifjsldkj\nVerifying and decoding the ID Token will yield the following Claims:\n{ \"iss\": \"https://server.example.com\", \"sub\": \"248289761001\", \"aud\": \"s6BhdRkqt3\", \"nonce\": \"n-0S6_WzA2Mj\", \"exp\": 1311281970, \"iat\": 1311280970, \"at_hash\": \"77QmUPtjPfzWtF2AnpK9RQ\" }\n| TOC |\nGET /authorize? response_type=code%20id_token &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile%20email &nonce=n-0S6_WzA2Mj &state=af0ifjsldkj HTTP/1.1 Host: server.example.com HTTP/1.1 302 Found Location: https://client.example.org/cb# code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk &id_token=eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ. ewogImlzcyI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsCiAic3ViIjog IjI0ODI4OTc2MTAwMSIsCiAiYXVkIjogInM2QmhkUmtxdDMiLAogIm5vbmNlIjog Im4tMFM2X1d6QTJNaiIsCiAiZXhwIjogMTMxMTI4MTk3MCwKICJpYXQiOiAxMzEx MjgwOTcwLAogImNfaGFzaCI6ICJMRGt0S2RvUWFrM1BrMGNuWHhDbHRBIgp9. MRPihYtNIcwKTZ_mcMSPfreVytGR4jfl1Tzbv4tH5Jr4WqONs2lUWrIEpZ2joKbZ fAGlouAqwqSYpfR3FQYKYvdgnZ3kjIJ_5M4fAARXHVSciGyhfqB-OhDUMXSHzFHi GKNY9TKSgRfiXf_314WRujpqaDtj2uoXbppobYXvAZIxWtsOein0-t91LDS39EW4 frNWAopKTBBi_XJPlpLVynWTDvNleEBP6UxIMgYJBKlqsP7RGfHTGk3ReXDacR7R GZlIVGa-0qRyDzvNqD7xfu9aYufUP0oBGqdBGgFVNmwJ7rmB0gdPtC2eJsXq9svC gBBfhRQZxhx1iLJjNc9nSw &state=af0ifjsldkj\nVerifying and decoding the ID Token will yield the following Claims:\n{ \"iss\": \"https://server.example.com\", \"sub\": \"248289761001\", \"aud\": \"s6BhdRkqt3\", \"nonce\": \"n-0S6_WzA2Mj\", \"exp\": 1311281970, \"iat\": 1311280970, \"c_hash\": \"LDktKdoQak3Pk0cnXxCltA\" }\n| TOC |\nGET /authorize? response_type=code%20token &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile%20email &nonce=n-0S6_WzA2Mj &state=af0ifjsldkj HTTP/1.1 Host: server.example.com HTTP/1.1 302 Found Location: https://client.example.org/cb# code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk &access_token=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y &token_type=Bearer &state=af0ifjsldkj\n| TOC |\nGET /authorize? response_type=code%20id_token%20token &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile%20email &nonce=n-0S6_WzA2Mj &state=af0ifjsldkj HTTP/1.1 Host: server.example.com HTTP/1.1 302 Found Location: https://client.example.org/cb# code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk &access_token=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y &token_type=Bearer &id_token=eyJraWQiOiIxZTlnZGs3IiwiYWxnIjoiUlMyNTYifQ. ewogImlzcyI6ICJodHRwczovL3NlcnZlci5leGFtcGxlLmNvbSIsCiAic3ViIjog IjI0ODI4OTc2MTAwMSIsCiAiYXVkIjogInM2QmhkUmtxdDMiLAogIm5vbmNlIjog Im4tMFM2X1d6QTJNaiIsCiAiZXhwIjogMTMxMTI4MTk3MCwKICJpYXQiOiAxMzEx MjgwOTcwLAogImF0X2hhc2giOiAiNzdRbVVQdGpQZnpXdEYyQW5wSzlSUSIsCiAi Y19oYXNoIjogIkxEa3RLZG9RYWszUGswY25YeENsdEEiCn0. A2OhhJzbUNaCbNLqNaqetGLJoxB3ujVbq_HLYSOWgWCJ3-B__YxlqIg8gpeL0Vhv rWX0mwz7w_pGTRN4JdgsI0xAlT5fob1ZPnrazgonSyzaXcg2bgD896SsBSlG_8JX 6JKaztXifn8k2gy65Me-sMyQrRF8xv_q1CeC871sZpMjJzy5nx65BTI17vcXjntZ HADv6o2CrHrEdHp8xSlnTLiiIqgDOmKlpkeqqOBK6dqa4rXZlSqMAUm1LYZmtb2D 8sHvQsxTbWlBkX7VZaTSqMJ487s4ZIEea8Bw4KGVOntQue4VhBjBnQ4bQKhB_47D xlWpSyOWdy3cer_zxKrfvw &state=af0ifjsldkj\nVerifying and decoding the ID Token will yield the following Claims:\n{ \"iss\": \"https://server.example.com\", \"sub\": \"248289761001\", \"aud\": \"s6BhdRkqt3\", \"nonce\": \"n-0S6_WzA2Mj\", \"exp\": 1311281970, \"iat\": 1311280970, \"at_hash\": \"77QmUPtjPfzWtF2AnpK9RQ\", \"c_hash\": \"LDktKdoQak3Pk0cnXxCltA\" }\n| TOC |\nThe following RSA public key, represented in JWK format, can be used to validate the ID Token signatures in the above examples (with line wraps within values for display purposes only):\n{ \"kty\":\"RSA\", \"kid\":\"1e9gdk7\", \"n\":\"w7Zdfmece8iaB0kiTY8pCtiBtzbptJmP28nSWwtdjRu0f2GFpajvWE4VhfJA jEsOcwYzay7XGN0b-X84BfC8hmCTOj2b2eHT7NsZegFPKRUQzJ9wW8ipn_aD JWMGDuB1XyqT1E7DYqjUCEOD1b4FLpy_xPn6oV_TYOfQ9fZdbE5HGxJUzeku GcOKqOQ8M7wfYHhHHLxGpQVgL0apWuP2gDDOdTtpuld4D2LK1MZK99s9gaSj RHE8JDb1Z4IGhEcEyzkxswVdPndUWzfvWBBWXWxtSUvQGBRkuy1BHOa4sP6F KjWEeeF7gm7UMs2Nm2QUgNZw6xvEDGaLk4KASdIxRQ\", \"e\":\"AQAB\" }\n| TOC |\nAs a successor version of OpenID, this specification heavily relies on ideas explored in OpenID Authentication 2.0 (OpenID Foundation, \u201cOpenID Authentication 2.0,\u201d December 2007.) [OpenID.2.0]. Please refer to Appendix C of OpenID Authentication 2.0 for the full list of the contributors for that specification.\nIn addition, the OpenID Community would like to thank the following people for their contributions to this specification:\nNaveen Agarwal (Naveen.Agarwal@microsoft.com), Microsoft (was at Google)\nAmanda Anganes (aanganes@mitre.org), MITRE\nCasper Biering (cb@peercraft.com), Peercraft\nJohn Bradley (ve7jtb@ve7jtb.com), Yubico (was at Ping Identity)\nTim Bray (tbray@textuality.com), independent (was at Google)\nJohnny Bufu (johnny.bufu@gmail.com), independent (was at Janrain)\nBrian Campbell (bcampbell@pingidentity.com), Ping Identity\nBlaine Cook (romeda@gmail.com), independent\nBreno de Medeiros (breno@google.com), Google\nPamela Dingle (Pamela.Dingle@microsoft.com), Microsoft (was at Ping Identity)\nVladimir Dzhuvinov (vladimir@connect2id.com), Connect2id (was at Nimbus Directory Services)\nGeorge Fletcher (gffletch@aol.com), Capital One (was at AOL)\nRoland Hedberg (roland@catalogix.se), independent (was at University of Ume\u00e5)\nRyo Ito (ryo.ito@mixi.co.jp), mixi, Inc.\nEdmund Jay (ejay@mgi1.com), Illumila\nMichael B. Jones (michael_b_jones@hotmail.com), Self-Issued Consulting (was at Microsoft)\nTorsten Lodderstedt (torsten@lodderstedt.net), independent (was at Deutsche Telekom)\nJames Manger (James.H.Manger@team.telstra.com), Telstra\nNov Matake (nov@matake.jp), independent\nChuck Mortimore (charliemortimore@gmail.com), Disney (was at Salesforce)\nAnthony Nadalin (nadalin@prodigy.net), independent (was at Microsoft)\nHideki Nara (hdknr@ic-tact.co.jp), Tact Communications\nAxel Nennker (axel.nennker@telekom.de), Deutsche Telekom\nDavid Recordon (recordond@gmail.com), independent (was at Facebook)\nJustin Richer (justin@bspk.io), Bespoke Engineering (was at MITRE)\nNat Sakimura (nat@nat.consulting), NAT.Consulting (was at NRI)\nLuke Shepard (luke@lukeshepard.com), Facebook\nAndreas \u00c5kre Solberg (Andreas.Solberg@sikt.no), Sikt (was at UNINET)\nPaul Tarjan (paul@paultarjan.com), Facebook\n| TOC |\nCopyright (c) 2023 The OpenID Foundation.\nThe OpenID Foundation (OIDF) grants to any Contributor, developer, implementer, or other interested party a non-exclusive, royalty free, worldwide copyright license to reproduce, prepare derivative works from, distribute, perform and display, this Implementers Draft or Final Specification solely for the purposes of (i) developing specifications, and (ii) implementing Implementers Drafts and Final Specifications based on such documents, provided that attribution be made to the OIDF as the source of the material, but that such attribution does not indicate an endorsement by the OIDF.\nThe technology described in this specification was made available from contributions from various sources, including members of the OpenID Foundation and others. Although the OpenID Foundation has taken steps to help ensure that the technology is available for distribution, it takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this specification or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any independent effort to identify any such rights. The OpenID Foundation and the contributors to this specification make no (and hereby expressly disclaim any) warranties (express, implied, or otherwise), including implied warranties of merchantability, non-infringement, fitness for a particular purpose, or title, related to this specification, and the entire risk as to implementing this specification is assumed by the implementer. The OpenID Intellectual Property Rights policy requires contributors to offer a patent promise not to assert certain patent claims against other contributors and against implementers. The OpenID Foundation invites any interested party to bring to its attention any copyrights, patents, patent applications, or other proprietary rights that may cover technology that may be required to practice this specification.\n| TOC |\n| Nat Sakimura | |\n| NAT.Consulting | |\n| Email: | nat@nat.consulting |\n| URI: | https://nat.sakimura.org/ |\n| John Bradley | |\n| Yubico | |\n| Email: | ve7jtb@ve7jtb.com |\n| URI: | http://www.thread-safe.com/ |\n| Michael B. Jones | |\n| Self-Issued Consulting | |\n| Email: | michael_b_jones@hotmail.com |\n| URI: | https://self-issued.info/ |\n| Breno de Medeiros | |\n| Email: | breno@google.com |\n| URI: | https://stackoverflow.com/users/311376/breno |\n| Chuck Mortimore | |\n| Disney | |\n| Email: | charliemortimore@gmail.com |\n| URI: | https://twitter.com/cmort |"
    }
  ],
  "argos_summary": "The article discusses the increasing adoption of cloud-first strategies and Zero Trust Architecture by organizations, highlighting the significance of Microsoft's Web Account Manager (WAM) in providing secure access across Windows platforms. WAM, introduced with Windows 10, enhances user authentication experiences by centralizing identity management and enabling seamless Single Sign-On (SSO) for applications like Microsoft 365 and Teams. It addresses challenges posed by traditional authentication methods, such as fragmented user experiences and security vulnerabilities, by simplifying integration for developers and supporting advanced security features, thus playing a crucial role in modern identity and access management.",
  "argos_id": "UKQVCBL6K"
}