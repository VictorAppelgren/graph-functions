{
  "url": "https://www.howtogeek.com/why-youll-never-stop-breaking-your-linux-install-and-thats-fine/",
  "authorsByline": "Sydney Butler",
  "articleId": "76c3df437dc042deae3faf6b1c50c8ce",
  "source": {
    "domain": "howtogeek.com",
    "location": {
      "country": "us",
      "state": "VA",
      "county": "Fairfax County",
      "city": "McNair",
      "coordinates": {
        "lat": 38.9695316,
        "lon": -77.3859479
      }
    }
  },
  "imageUrl": "https://static1.howtogeekimages.com/wordpress/wp-content/uploads/2025/08/dead-linux-penguin.png",
  "country": "us",
  "language": "en",
  "pubDate": "2025-08-13T14:00:16+00:00",
  "addDate": "2025-08-13T14:13:53.876282+00:00",
  "refreshDate": "2025-08-13T14:13:53.876284+00:00",
  "score": 1.0,
  "title": "Why Breaking Your Linux Install Is a Rite of Passage",
  "description": "Linux users embrace the power and flexibility of their OS, even if it means occasionally breaking things. Here's why that's not only OK, but expected.",
  "content": "Linux is wonderful, and like you I have fond memories of spending a whole weekend compiling Red Hat's kernel in the 2000s and then just giving up with nothing to show for it. These days, Linux is more user friendly than ever, so getting it all up and running is a breeze in comparison.\n\nHowever, unless you're using your computer as a glorified iPad, chances are you're going to break your Linux install at some point. That's not a read on Linux, that's just the life of a Linux user that's always flying just a little too close to the sun. Let me explain.\n\nYou Have Too Much Power\n\nLinux doesn\u2019t treat you like a toddler with safety scissors\u2014it hands you a sharpened katana and says, \u201cGood luck!\u201d\n\nLike Peter Parker's uncle reminds us, with great power comes great responsibility, but who RTFMs anyway? Linux isn't here to ask you why you want to overwrite core file systems, recompile your kernel, or why you'd like to \"rm -rf\", it just lets you. OK, to be fair, that last one has a failsafe these days.\n\nThe point is that when Linux says you're the administrator, it really means it and the buck stops with you. Naturally, since absolute power corrupts absolutely, you'll inevitably screw it all up as you explore the limits of your newfound powers.\n\nIf you just wanted a computer that does a handful of things the same way it does them for everyone in the world, you'd buy an iPad or something. No, if you've deliberately chosen to run some flavor of Linux, you're probably not the type of person that likes \"stock\" anything, and the more stickers covering your laptop, the more likely that you're always poking at every component of your Linux install.\n\nWhether it's extreme personalization or just a drive to make something more efficient, or add or modify features, you just can't leave something that's working well enough alone. Right up until it's not working at all.\n\nPoint release cycles? Software versioning? Yuck. Long-term stable versions of an OS? Get out of here. You want to keep rollin' with Arch or another distro that keeps the updates constant, raw, and fresh. This is the bleeding edge, and bleed you will, my friend.\n\nFragmentation Is Both a Feature and a Bug\n\nThis software works perfectly on every distro of Linux except the one you're using, where it corrupts everything and makes you seriously consider Debian. No, it's the normies who are wrong!\n\nYou Learn More From Breakage Than From Stability\n\nWhile most popular desktop distros of Linux these days don't require any special knowledge for day-to-day use, digging just a little under the surface can still reveal a pretty steep learning curve. Eventually, blindly copying terminal commands will mess something up, and it's during your attempts to fix what you broke that you'll learn what any of it actually meant.\n\nBreaking Linux is just a normal part of learning how to use Linux and understanding how the different parts go together. Now, this can also be true for other operating systems. Goodness knows I had to fix our Windows 95 PC numerous times before my dad came home and found out I broke it, but I really think for Linux it's just a core part of the experience at this point. I still can't figure out how to get Plex on Linux to see USB drives though.\n\nLinux gives you plenty of safety nets\u2014if you set them up. With tools like Timeshift, Btrfs snapshots, and containerized apps, you can break things without fear of permanent loss. The more you experiment with these, the more comfortable you become with pushing your system to its limits\u2026 and occasionally off a cliff.\n\nMaybe that's why most of us test the waters with a live installation or a virtual machine. At least with a VM you can rewind the clock if you really mess things up.\n\nEven the Pros Break It\n\nYou might think that the real Linux pros\u2014the guys who can remember every terminal command and do anything using the terminal\u2014never break their computers. The truth is that the pros have probably broken Linux more than anyone else, and it still happens from time to time. The real difference is that these guys can usually recover from a terminal mistake (ha!) faster than the novices, or at least have more sensible recovery methods set up in advance, because they like to live on the edge. I'll never be more than a casual Linux dabbler myself, but I can respect the pros!\n\nUltimately, for some folks, Linux itself is the point rather than a means to an end. People might think of it as an operating system meant to enable a computer to run applications, but if that was all it is, there's no particular reason to roll with Linux over its alternatives\u2014including the open-source ones. No, the Cult of Linux is as much a philosophy and an approach to computing as it is lines of code that make hardware whirr to life\u2014and part of that is breaking the machine to see how it ticks.",
  "medium": "Article",
  "links": [
    "https://www.howtogeek.com/open-source-operating-systems-that-arent-linux/",
    "https://www.howtogeek.com/learn-these-linux-commands-to-go-from-beginner-to-badass/",
    "https://www.howtogeek.com/how-i-use-the-linux-terminal-without-destroying-my-os/",
    "https://www.howtogeek.com/filesystems-on-linux-when-should-you-not-use-ext4/",
    "https://www.shutterstock.com/image-photo/screwdriver-being-held-by-computer-technician-1720688932",
    "https://www.howtogeek.com/i-tested-10-popular-linux-distros-heres-how-i-rank-them/",
    "https://developer.apple.com/wwdc20/",
    "https://www.howtogeek.com/easily-use-linux-usb-drives-with-plex/"
  ],
  "labels": [
    {
      "name": "Opinion"
    }
  ],
  "claim": "",
  "verdict": "",
  "keywords": [
    {
      "name": "Linux",
      "weight": 0.110066995
    },
    {
      "name": "the real Linux pros",
      "weight": 0.061739285
    },
    {
      "name": "a casual Linux dabbler",
      "weight": 0.05931109
    },
    {
      "name": "Your Linux Install",
      "weight": 0.058072772
    },
    {
      "name": "your Linux install",
      "weight": 0.058072772
    },
    {
      "name": "a Linux user",
      "weight": 0.057870388
    },
    {
      "name": "core file systems",
      "weight": 0.057838973
    },
    {
      "name": "other operating systems",
      "weight": 0.057377867
    },
    {
      "name": "great power",
      "weight": 0.05504847
    },
    {
      "name": "absolute power",
      "weight": 0.04880389
    }
  ],
  "topics": [],
  "categories": [
    {
      "name": "Tech"
    }
  ],
  "taxonomies": [
    {
      "name": "/Reference/General Reference/How-To, DIY & Expert Content",
      "score": 0.389892578125
    },
    {
      "name": "/Computers & Electronics/Software/Operating Systems",
      "score": 0.322021484375
    }
  ],
  "sentiment": {
    "positive": 0.076725334,
    "negative": 0.57417107,
    "neutral": 0.34910363
  },
  "summary": "The article discusses the reasons why breaking your Linux install is a rite of passage for a Linux user, with the author suggesting that it's a given that the software is more user friendly than ever. Despite being more user-friendly than ever, chances are high chances of someone breaking their Linux install at some point. The author argues that Linux gives users too much power and that with great power, with great responsibility, with absolute power corrupting the system, you inevitably break it. While most popular desktop distros of Linux don't require any special knowledge, a steep learning curve can reveal a significant learning curve. However, breaking Linux is a crucial part of learning how to use Linux and understanding how the different parts go together. The article also notes that while some people mistakenly believe Linux is an operating system that enables applications to run on the edge of the operating system, it teaches more from broken than from stability.",
  "shortSummary": "Linux is a wonderful, user-friendly operating system with extensive user-focused features, but risks of accidental breakups like this often occur because of its user-centric nature.",
  "translation": "",
  "translatedTitle": "",
  "translatedDescription": "",
  "translatedSummary": "",
  "reprint": false,
  "reprintGroupId": "9d99c26511c34c6087031352a58b7a60",
  "places": [],
  "scraped_sources": [
    {
      "url": "https://www.howtogeek.com/open-source-operating-systems-that-arent-linux/",
      "text": "If you hear the term \"open-source,\" you might think of Linux. However, Linux distros aren't the only open-source operating systems. There are plenty in use today besides Linux. Some date back to even before Linux existed.\n9 Plan 9 From Bell Labs\nPlan 9 From Bell Labs, named after the sci-fi B-movie Plan 9 From Outer Space, was an attempt to reimagine what an OS could be. Headed by Rob Pike and other members of the original Unix team, Plan 9 took Unix's \"everything is a file\" concept and went beyond it. Network servers could be explored by navigating the file system as you could on a local machine.\nOne of Plan 9's biggest goals was to build a distributed operating system. PCs and workstations served as terminals to access compute servers and file servers. You can read all about it in the original paper describing the system from the early '90s. Attempts to commercialize it faltered because Unix, Windows, and later Linux machines were too entrenched, but it has influenced a lot of modern OSes, including Linux. It was later open-sourced, and you can still run it today.\n8 Haiku\nHaiku is an open-source recreation of BeOS. BeOS, created by Be, headed by Jean-Louis Gass\u00e9e, formerly at Apple, was a radical reinvention of the operating system. BeOS was notable for its affinity with multimedia and its support for multiple processors when PCs generally only had one CPU. The only multicore machines were typically behemoth servers. Despite attracting a cult following, BeOS eventually disappeared when Be was acquired by Palm.\nAn open-source community has taken to resurrecting BeOS in the form of Haiku. If BeOS was like the original Unix, Haiku could be like Linux.\n7 Minix\nMinix was created by computer scientist Andrew Tanenbaum to accompany a textbook he'd written on operating systems. The system was originally created to illustrate microkernels, or kernels that move a lot of functionality out into separate servers. While Minix built up a small community around it because it came with the book with complete source code for a relatively low cost, it also became known when a Finnish computer science student named Linus Torvalds was inspired to create his own kernel after reading the book, in between rounds of Prince of Persia. This effort grew into Linux.\nTanenbaum later retooled Minix into an attempt to create a super-reliable system and fully open-sourced Minix.\n6 HelenOS\nSimilar to Minix, HelenOS is primarily a research project for building a microkernel-based OS. But what you'll likely notice is the retro user interface that's inspired by Windows 3.1 and 95.\nHelenOS is fun to play with, but it's probably not ready for use as a daily driver. It's got some interesting ideas about how to implement processes, but this will mainly be of interest to serious geeks who are aware of how things normally work on Unix-like systems.\n5 AROS\nAROS stands for \"AROS Research Operating System.\" The name may be a recursive acronym, but it's an attempt to recreate the famed Amiga operating system, AmigaOS. AROS aims for broad compatibility with AmigaOS, but it's a complete reimplementation. One advantage it has over AmigaOS is that it runs on different types of computers, including regular PCs.\nAs with Linux, there are several versions of AROS available. One of them is AROS One. Other versions include Icaros, AROS Vision, and AspireOS.\n4 ReactOS\nIf AROS is dedicated to reinventing AmigaOS, ReactOS tries to reimplement Windows in an open-source fashion. It also tries to mimic the classic Windows 9.x look-and-feel. Under the hood, it's implementing the Windows NT strain, so it aims for compatibility with modern Windows versions.\nIn practice, development is slowed by the need for reverse clean room engineering to stave off lawsuits from Microsoft. Microsoft's APIs are also a moving target, so developers often find themselves having to start from scratch.\nStill, you can download and run images of ReactOS. I found it to be quite usable. It even includes a Solitaire game, which is something that has been omitted from more recent Windows versions, at least in an ad-free version.\n3 FreeDOS\nWhile ReactOS aims to recreate Windows NT, see if you can guess what FreeDOS is trying to reimplement. FreeDOS is an obvious clone of MS-DOS. The single-tasking, single-user MS-DOS. The DOS with the 640k barrier, unless you run a memory manager (which it does include).\nWhy would you want to run such an operating system in 2025? The most obvious reason is nostalgia. I grew up on MS-DOS, so it's a fun trip down memory lane. You can run old business software and, more importantly, games on modern or even vintage PC hardware if you don't mind scrounging for new CMOS batteries. One practical use for me was reflashing the BIOS on a Linux-only netbook. Many BIOS utilities only work with DOS. You could also use it as a platform for embedded systems due to its simplicity compared to even minimal Linux distros.\n2 GNU Hurd\nBefore the Linux kernel existed, Hurd was the GNU Project's first attempt to build a kernel for a free software operating system that gave anyone the ability to read and change the source code. Based on Carnegie Mellon University's famed Mach kernel, Hurd is another attempt to build a microkernel-based kernel.\nUnfortunately, the development of the kernel has been much slower than the developers originally intended. The Linux kernel leapfrogged Hurd, but it's still an active project. Debian has made images of a Debian/Hurd distribution available, but it's not yet stable for production work. The biggest hurdle appears to be the shortage of drivers, as most of the energy has shifted to Linux. I've only managed to make it to the installation screen in a VirtualBox VM. If you want to tinker with an OS in a virtual or spare machine, Hurd might be worth a look if you can get it to work.\n1 The BSDs\nOf the non-Linux open source OSes, the most prominent might be the BSDs. The BSDs collectively can trace their heritage to the Berkeley Software Distribution, created at UC Berkeley starting in the late 1970s. They modified the original Unix in ways that appealed to other universities. BSD was also popular on workstations because it was among the first major OSes to implement TCP/IP. This made it easy for these workstations to be networked and laid the groundwork for the modern internet.\nOf the BSDs, FreeBSD is perhaps the best-known. It grew out of the 386BSD project to port BSD to PC-based hardware. When that project ground to a halt, a number of developers used the source code to create their own version. FreeBSD aimed to continue 386BSD's attempt to primarily focus on PC and Intel hardware at the expense of other architectures. These days, FreeBSD runs on a variety of architectures. It's best known for its file server abilities, with native support for ZFS. FreeBSD powers Netflix's Open Connect content delivery network as well as the FlightAware flight tracking site.\nNetBSD is another offshoot of the 386BSD project. Where FreeBSD initially focused on x86 computers, NetBSD aimed for portability, creating versions for nearly any computer architecture in existence. Want to run it on your PC? Sure, you can do that. Do you have some old machines, maybe even a Motorola 68000-based machine like an old Mac or Amiga? You can run NetBSD on that, too.\nMaybe you even have a Digital Equipment Corporation VAX minicomputer? Yes, you can get NetBSD for that, too. NetBSD's slogan is \"Of Course It Runs NetBSD.\" It's even run on a toaster, as seen on Laughing Squid.\nOpenBSD is the result of a dispute that NetBSD developer Theo de Raadt had with other members of the project. He split off and started his own system. OpenBSD is renowned for its focus on security. They claim to have only had a few remote holes in the system throughout its development. This is an impressive claim for any system, even an open-source one. Parts of OpenBSD have become popular in other places, like OpenSSH and the tmux terminal multiplexer.\nDragonFlyBSD is a system that has made some radical changes to the standard BSD codebase. The system features the HAMMER2 filesystem with deduplication and snapshots for reliability. It also offers virtual kernels, where a kernel can run in user space rather than in the usual privileged mode. This makes it easier for developers to debug kernels.\nLinux isn't the only open-source OS. There will likely be more to come as developers want to try new ideas. If you want something different, there's still plenty to explore right now."
    },
    {
      "url": "https://www.howtogeek.com/filesystems-on-linux-when-should-you-not-use-ext4/",
      "text": "Summary\n- Ext4 is essentially the default Linux filesystem, offering simplicity and compatibility, making it a solid choice for most users.\n- Btrfs supports snapshots and is self-repairing, while XFS excels with large file storage due to its parallel read and write operations.\n- exFAT is best used for removable drives that you'll use with other computers.\nAs with many things, a typical Linux install offers a choice of filesystems, though the Ext4 filesystem is typically the default for most distros. What are the advantages of those other filesystems, and when should you choose them instead?\nWhy the Ext4 Filesystem Is So Common on Linux\nExt4 is the most recent iteration of the filesystem, but it\u2019s far from the first, as the number in the name implies. The earliest versions of Linux used the filesystem from Minix, another Unix-like operating system, before beginning work on a more capable replacement.\nThe original Ext filesystem was released in 1992, with the improved Ext2 following quickly in 1993. Compared to the original Ext filesystem, Ext2 offered improved performance, and was the default for most Linux installs at least until the introduction of Ext3 in 1999.\nExt3 was an important step forward as it added support for journaling, which helps prevent data loss during sudden crashes. This adds a slight performance overhead, but the tradeoffs are such that nearly every modern filesystem uses journaling.\nExt4 was released in 2008, so which it\u2019s the relative new kid on the block, it\u2019s still been around for quite a while. This version of the filesystem is backward compatible with the two prior versions (the original extfs driver was removed as of Linux kernel version 6.9), but also adds performance and features. For example, there is no limit in the Ext4 filesystem on the number of subdirectories, while Ext3 was limited to 32,000.\nDue to its compatibility, simplicity, and relatively lightweight nature, Ext4 has been the default filesystem on most Linux distributions for quite some time now. It\u2019s far from the only option, but if you\u2019re not sure which filesystem is right for you, Ext4 is likely your best bet.\nBtrfs: A Filesystem With Extra Features\nWhile Ext4 has added plenty of features, one it doesn\u2019t currently support is any kind of snapshot or checksum functionality. This allows a filesystem to automatically repair itself, capturing and restoring data as necessary to recover from crashes or to prevent data corruption.\nBtrfs is far from the only filesystem with this type of functionality, but it is currently the second most popular option on Linux, at least when it comes to finding it preinstalled. Depending on the distribution, Btrfs may be relatively tightly integrated, like in the case of the OpenSuSE linux distributions, which use Btrfs for snapshots.\nThis does add some performance overhead, as does the Copy-on-write (CoW) support in Btrfs. Using this approach, the changes to a file are written to a new location rather than directly over the old file, helping prevent data loss. Using this alongside its checksum and snapshot features, Btrfs is self-healing, compared to older-style filesystems, but again, this does come with an overhead.\nFor pure performance, Ext4 will be faster than Btrfs in most cases. That said, the differences will often be negligible if you\u2019re talking about the typical workload of a home PC.\nXFS: Best For Large File Storage\nBoth Ext4 and Btrfs are equally at home on your personal PC or running on a server, though as we\u2019ve looked at, there are performance differences between the two. While both of these filesystems work well for certain types of server workloads, if you\u2019re dealing with large files, you may want to consider the XFS filesystem.\nXFS has multiple advantages for dealing with large files, including the ability to store files up to 500TB in size, compared to 16TB for Ext4. While Btrfs has a limit in the exabytes (and it isn\u2019t alone), XFS also performs read and write operations in parallel, which can have major performance benefits in server situations.\nIf this sounds like it could be useful for your Ubuntu-powered Plex server, you might be right. XFS is also a great option for running on a NAS if you\u2019re frequently backing up large video files for video editing, for example.\nWhile you could argue that it\u2019s slightly overkill, there are plenty of reports all over the internet of happy NAS users running XFS, so you wouldn\u2019t be alone.\nWhat About Other Filesystems on Linux?\nIf you spend any time researching filesystems available on Linux, you\u2019ll end up stumbling upon ZFS. Similar to XFS, servers are the main target for ZFS. Similar to Btrfs, the maximum file size supported is 16EB (that\u2019s exabytes), which currently isn\u2019t even possible on Linux. It also uses LZ4, a faster compression algorithm than Btrfs, which uses zlib.\nThe main downside of ZFS is that you won\u2019t find it as a preinstalled option on many distributions. It\u2019s not difficult to install, as our guide to installing ZFS on Ubuntu shows, but it\u2019s a further step that not everyone may want to take once they already have a system up and running.\nWhile we won\u2019t touch on every filesystem available on Linux, exFAT briefly deserves a mention. This is a version of the Windows FAT filesystem meant for flash drives, and is likely your best bet for removable drives if you want to use them with other operating systems."
    },
    {
      "url": "https://www.howtogeek.com/easily-use-linux-usb-drives-with-plex/",
      "text": "Quick Links\nSummary\n- For Plex to be able to access media on external USB drives, you need to create a dedicated mount point.\n- Use chown to give the 'plex' user ownership of the mount point.\n- Add a line to the /etc/fstab file to mount your USB drive on the mount point.\nPlex is simple to install and use, and it performs marvelously. One thing that drives new users crazy though, is trying to access media on external USB drives. Here\u2019s the easy way.\nThe Plex Media Server and Libraries\nThe well-known Plex media server organizes your media in libraries. These are collections of different media types, such as movies, TV shows, photographs, and so on. You add directories containing your media to your libraries. The directories can be on local hard drives, external mounted USB drives, or some other network-accessible location. These directories are called sources.\nOn Linux, USB drives must be mounted before they can be accessed. That\u2019s fine, we can use standard Linux techniques to do this. But plex has a further requirement.\nPlex creates a Linux user called plex. This user must have access to the media. Time and again I\u2019ve heard how this stumbling block drives people to give up. After floundering in stormy seas of permissions and file and directory ownership, they abandon ship.\nThe reality is, it\u2019s easier to accomplish than you might think.\nInstalling Plex\nThe installation of Plex plays a major part in whether you succeed. I recommend you use the official Plex install files. Snaps, Flatpaks, and the versions in distribution repositories didn\u2019t work for me. Your mileage may vary but, very often, the plex user wasn\u2019t created. Without the plex user, you\u2019re bound to fail.\nThe only exception was the Manjaro and Arch version in the Arch User Repository, or AUR. That worked perfectly. You\u2019ll need an AUR helper tool like yay to use the AUR.\nOnce you have yay, you can use this command:\nyay -S plex-media-server\nFor Ubuntu and Fedora, you\u2019ll get the best results using the official RPM and DEB files. On Fedora, this command retrieves the latest RPM at the time of writing.\nwget https://downloads.plex.tv/plex-media-server-new/1.41.0.8994-f2c27da23/redhat/plexmediaserver-1.41.0.8994-f2c27da23.x86_64.rpm\nsudo dnf install plexmediaserver-1.41.0.8994-f2c27da23.x86_64.rpm -y\nOn Ubuntu, you need to issue a sequence of commands. It might look a lot, but it\u2019s just a case of cut and paste. If you\u2019ve just installed Ubuntu, make sure you update and upgrade first, with:\nsudo apt update\nsudo apt upgrade\nYou might already have cURL installed, but I\u2019ve included the command in case you don\u2019t. Don\u2019t skip the update command before you perform the final apt install command.\nsudo apt install apt-transport-https\nsudo apt install curl\ncurl https://downloads.plex.tv/plex-keys/PlexSign.key | gpg --dearmor | sudo tee /usr/share/keyrings/plex-archive-keyring.gpg >/dev/null\necho deb [signed-by=/usr/share/keyrings/plex-archive-keyring.gpg] https://downloads.plex.tv/repo/deb public main | sudo tee /etc/apt/sources.list.d/plexmediaserver.list\nsudo apt update\nsudo apt install plexmediaserver\nOK, that\u2019s Plex installed. On all distributions, we have to enable and start the plexmediaserver daemon:\nsudo systemctl enable plexmediaserver\nsudo systemctl start plexmediaserver\nCreating the Mount Point\nWe need to create a mount point that\u2019s owned by the plex user. I named my mount point \u2018plex-usb\u2019, and it\u2019s in the root directory. Don\u2019t create it in your home directory.\nsudo mkdir /plex-usb\nsudo chown plex:plex /plex-usb\nls -ld /plex-usb/\nThe chown command changes the user and group ownership of the directory to \u2018plex.\u2019 We use ls to confirm those changes.\nMounting the USB\nMy USB drive was named Silver when it was formatted. It shows up with that name when I plug it in. It holds two directories called Movies and Shows.\nWe need to find its Universally Unique Identifier, or UUID. We\u2019ll pipe the blkid command into grep and look for /dev/sd devices. These are identified as sda for the first drive, sdb for the second, and so on.\nsudo blkid | grep /dev/sd\nIn my case, the USB drive is /dev/sdb. We need to take note of the UUID and the Type. The UUID of my drive is \u2018b7ea748e-2df0-450e-922b-bf9d81e534c3\u2019 and its Type is \u2018ext4.\u2019\nIf you have difficulty spotting your drive, remove it, then run the blkid command, as above. Open another terminal window, insert your USB drive, and run the blkid command again. You can then look for differences between the two sets of output.\nWe need to edit the /etc/fstab file to mount our USB drive on the /plex-usb mount point whenever the Plex computer boots.\nUse your favorite editor, and open the /etc/fstab file.\nsudo gedit /etc/fstab\nAdd this line at the bottom of your fstab file. Use the UUID and Type from your own drive, of course, and the name and path of your own mount point.\n/dev/disk/by-uuid/b7ea748e-2df0-450e-922b-bf9d81e534c3 /plex-usb ext4 defaults 0 0\nYou can separate the fields with spaces or tabs.\nSave your changes and reboot your computer. When you log in, you should be able to navigate to your mount point and see your media.\nCounterintuitively, ls now reports the mount point belongs to user dave-mckay.\nls -ld /plex-usb/\nls -l /plex-usb/\nThis is because the root of the USB drive has been overlaid on the mount point. But, beneath the surface, the underlying mount point is actually owned by the plex user, which we verified earlier. This \"dual ownership\" is how the plex user can access the USB drive.\nUse the USB Libraries in Plex\nIn your web browser, navigate to localhost:32400/web and go through the usual Plex start-up screens. When you get to the Server Setup, Organize Your Media page, click the \"Add Library\" button.\nWe\u2019re going to add a source of movies, so click the Movies button.\nYou can edit the name, and choose a language.\nI\u2019m happy with the defaults, so I clicked the Next button. On the next page, click the \"Browse For Media Folder\" button.\nOn the Add Folder page, click / for the root directory.\nScroll through the list of directories on the right, until you see your mount point.\nClick it when you see it.\nScroll back up, and you\u2019ll see the directories on your mounted USB drive. Click the Movies directory.\nYou\u2019ll see the contents of the directory. Click the Add button.\nYou\u2019ll get a chance to review your choices. I\u2019m adding a directory called /plex-usb/Movies to this library, which is correct. Click the Add Library button.\nThe new library is listed as a configured source.\nTo add the TV Shows, we follow the same procedure. Click Add Library > TV Shows > Next > Browse For Media Folder > root directory '/' > plex-usb, Shows > Add, Add Library.\nNow we\u2019ve got two libraries listed. Click Next.\nClick Done.\nYour media will be scanned, identified, and added to the Plex database, and found under the name of your Plex server.\nA Word About Jellyfin\nJellyfin functions similarly to Plex. To add external USB drives to Jellyfin, use the same overall process.\nInstall Jellyfin, and create the mount point, say /jellyfin-usb.\nsudo mkdir /jellyfin-usb\nMake the jellyfin user the owner of the mount point.\nsudo chown jellyfin:jellyfin /jellyfin-usb\nAdd an entry to /etc/fstab to mount the USB drive to the mount point.\nShowtime!\nYou\u2019re all set to watch media stored on your external drive.\nRemember to unmount your USB drive before removing it. The easiest way to use it on another computer and then reattach it to your Plex server, is to shutdown your Plex server, use your drive elsewhere, plug it back in, then boot up your Plex server."
    },
    {
      "url": "https://www.howtogeek.com/how-i-use-the-linux-terminal-without-destroying-my-os/",
      "text": "Summary\n- Be cautious in the Linux terminal to avoid system damage.\n- Dangerous commands to watch out for include rm and dd.\n- Running as a regular user, double-checking operations, and having backups are important.\nWhile the Linux terminal is still a part of Linux, you can break your system with it if you're not careful. Here's how I stay safe in the terminal, and I show you how you can fix things if you do make mistakes.\nWhy You Need to Be Careful in Linux\nLinux has inherited much of its design philosophy from Unix, which was first developed at Bell Labs starting in the late 1960s. Back then, there were no personal computers. Computing was done on large mainframes or minicomputers. Computer operating systems were designed for professional, experienced users. Unix, especially, was considered \"by programmers, for programmers.\"\nWhile there have been great strides to broaden the accessibility of Unix-like systems with friendlier user interfaces, the Linux terminal reflects its technical roots. Unlike in modern GUI environments, Linux shells don't try to protect you from yourself. If you want to delete a file or modify it, even an important file, if you have the correct permissions, it will let you go straight ahead, even if it would damage the system.\nIf you delete a file in the terminal, you can't get it back. It's gone forever, unless you have a backup.\nIt's also possible to make it so that you can't log in, launch a terminal, or even boot the machine if you aren't careful. You might be able to restore your system from backups if you made them. Or you might be able to fix it by booting into a USB stick. At the worst, you might have to reinstall your OS. A lot of things are fixable in Linux, but it's better to spend time doing things you really want to do instead of fixing your machine.\nWhat Commands Are Dangerous?\nYou should be wary of running commands that can cause data loss.\nThe command you should be most careful with is rm, the command that deletes files in the terminal. As I mentioned earlier, when you delete something with rm, it's gone forever. There's no recycle bin or trash can, so you can't undelete something you deleted by mistake, even if you made a typo.\nEven worse, the OS can overwrite the physical location of the file on the drive, making recovery impossible. You could shell out for a data recovery service or try to recover it yourself, but the process will likely take a lot more time and/or money than it's worth for a small file, so it's best to use other means when you can.\nThe other command that can cause major data loss is dd. This command copies bits from one file to the other, but it's been nicknamed \"disk destroyer\" for a very good reason. One thing that a lot of people mess up is the source and destination locations. If you mix them up, you can say goodbye to whatever was on that device.\nYou should also be wary of modifying system files. Linux depends on these for a lot of things, like connecting to the internet and booting Linux itself. If you modify something without knowing what you're doing, or even make a typo, you can make it less secure, or worse, even unbootable.\nThe shell's startup files can also make it impossible to launch a shell if you mess them up. That's something that I learned the hard way.\nYou can really mess up your system if you don't know what you're doing.\nI Run as a Regular User Whenever Possible\nThe first line of defense against any erroneous commands or editing is running as a regular user. I only run as a regular user as much as I can. The only times I run as root are when I actually do need to make system-wide changes, such as installing new software or making changes to the configuration files. When I need to do that, I run sudo or su, depending on what kind of system I'm using.\nThe file and user protections will help prevent any undesirable changes. For one thing, having to type \"sudo\" forces me to think about what I'm doing. I try to avoid making major changes when I'm tired or in a hurry.\nI Double-Check Potentially Risky Operations\nWhen I know I'm doing something potentially risky, I slow down and try to think about what I'm doing. If I'm going to delete a file, I examine the command line to make sure it's the right one. If I'm editing a system file, I make sure that I haven't made any typos before I save in the editor and reboot.\nThese are things that I've learned from experience. I learned to be careful not on a Linux system, but on a DOS/Windows PC from my childhood. I was trying to get some old game that ran in CGA, with the yucky (RGB-based) magenta color scheme, to run in a different palette. I'd seen that I could go to the BIOS setup screen, and I could change system settings. I changed the video card settings. Somehow, I managed to clear all the BIOS settings and then save them. If you know anything about PCs, this is a bad thing. The system didn't know what hardware it had anymore, since this was the pre-plug-and-play era. There were no serious hardware issues, and the system was eventually fixed, but my dad was pretty mad, and I had to play outside!\nSince then, my approach to system management is a lot more conservative. I try to avoid making changes to the system unless I absolutely need to. I can understand the urge to customize if you're new to Linux, but a lot of users seem to take an approach of fixing things that aren't broken until they are, and then slump into some forum asking for help.\nI Have A Backup Terminal Handy\nWhen I make changes to the shell startup files, such as Bash's .bashrc or morely likely Zsh's .zshrc, I have another terminal handy. I'll test my changes in one terminal by running the source command to read in the changes:\nsource .zshrc\nI then monitor this terminal for any error messages or anything that makes the terminal not run. I'll use the other terminal as a \"known good\" terminal. I can undo any changes in this terminal window if I have to. This gives me peace of mind, since I use the terminal so frequently.\nI Back Up Important Files\nOne thing that you should do is back up important files, no matter what system you're running.\nWhen I make a change to a system file, I like to make a quick local backup of the known good state with a \".bak\" extension:\ncp example.conf example.conf.bak\nIf I make a mistake and I can still boot into the system, I can just copy it back over:\ncp example.conf.bak example.conf\nThis will overwrite the modified file with the copy of the original.\nBacking up anything you don't want to lose is also a good idea, especially to external media or a network drive.\nRescuing a Broken System\nIf you do make a mistake, all is not lost. There are some things you can do. If you have backups, you can just restore them and get rid of the offending mistake or put back files you deleted by mistake. The only problem is that you have to commit to making backups.\nYou can also have bootable media handy, such as a USB key with your Linux install media. A lot of them have tools to run hardware diagnostics. Much of the time, you can mount your Linux hard drive or SSD and make changes from your boot media to restore your system to working order.\nIf you really broke your system, you can wipe it and reinstall Linux as a last resort. Shown above is the Debian recovery menu in the installation program.\nWhile these are good cures, I've found that prevention is much better. These things are like making disaster plans. You want to avoid needing to use them in the first place, but you'll be glad you had the option.\nI've found the best prevention is the message that you get when you run sudo for the first time. One of its admonishments is that you should \"think before you type.\" This is the lesson you should take when using the command line in Linux\nIf you're new to the Linux terminal, it pays to be cautious in the commands you run. With a little foresight, you can avoid disasters that can force you to reinstall your OS."
    },
    {
      "url": "https://www.howtogeek.com/i-tested-10-popular-linux-distros-heres-how-i-rank-them/",
      "text": "Are you confused by the hundreds of Linux distributions out there? Do you want to know how they compare to and differ from one another so you can make a better decision? Well, I just tested 10 of the most popular Linux distros, and here's my personal ranking of all of them!\nI checked DistroWatch to find the 10 most popular Linux distros right now\u2014a list compiled based on how many page views each distro's official website gets. While this isn't the best metric to determine which distro is the most loved, it can certainly shed light on which distros have captured the most curiosity and attention.\nFor context, I prefer distros boasting modern aesthetics, powerful features, and quick access to new and cutting-edge tools. So with that in mind, here's my candid ranking of all 10 distros and why I prefer some over others!\n10 Debian\nAs one of the first Linux distros\u2014and the base for many modern distros, including Ubuntu\u2014Debian holds a legendary status in the community. It\u2019s known for its rock-solid stability and is often the preferred choice for server environments. However, as a desktop user, Debian is just a bit too serious for my tastes.\nFor instance, the packages in the official repository undergo thorough testing to ensure nothing ever breaks, but that also means they\u2019re generally lagging when it comes to delivering new packages or tools with the latest features. While this is excellent for people who prefer stability, I personally prefer access to cutting-edge features and experimenting with new tools.\nFurthermore, the distro offers a minimal base, giving us a high level of customizing freedom. While I do see the charm, I personally don't like being given a blank slate, especially when other distros are giving me ready-made systems with my preferred defaults. For these reasons, Debian ranks low on my list.\n9 Fedora\nFedora strikes an impressive balance between stability and cutting-edge updates, releasing new system upgrades every six months packed with thoroughly tested versions of the latest tools and packages. On paper, it feels like the perfect distro, and I have tried it multiple times over the years, but it never really clicked for me.\nI can break down my qualms into three parts: the bare-bones vanilla GNOME desktop environment, the slower DNF package manager, and the main dealbreaker: a lack of proprietary drivers or codecs. Granted, you can install those drivers and codecs using RPM Fusion, but again, why go through the extra chore when options like Nobara (unfortunately not in this list) already exist\u2014a Fedora-based distro with KDE Plasma as the main DE, bundling preinstalled proprietary NVIDIA drivers and media codecs.\n8 Zorin OS\nZorin OS is one of my top recommendations for anyone switching to Linux from Windows. It\u2019s incredibly user-friendly, with a highly customizable interface and plenty of graphical tools to help you configure your system. Out of the box, it offers seamless integration with Wine and Bottles, making it easy to run Windows applications.\nBut personally, after moving away from Windows, I was looking for a fresh experience. Zorin OS sticks so closely to the traditional Windows 7 or XP layout that it feels a bit too familiar\u2014almost as if I\u2019m trapped in the old paradigm I want to escape. Furthermore, the overall graphical interface, while approachable, feels a bit dated in terms of design and aesthetics, which, again, I'm not a big fan of. For these reasons, I personally don't use Zorin OS, but I still maintain that it's an excellent starting point for newcomers.\n7 Linux Mint\nLinux Mint set out to create a distribution that\u2019s welcoming to newcomers, easy to use, and especially familiar to anyone migrating from Windows. It delivers across the board with flying colors, all the while offering a stable, reliable, and functional base. No wonder it\u2019s consistently among the most popular Linux distributions\u2014even outpacing Ubuntu in recent years!\nHowever, personally, I just don\u2019t resonate with Mint. Much like with Zorin OS, I\u2019m actively looking to move away from Windows-like systems, yet Mint sticks closely to that aesthetic, which just looks and feels a bit old and dated to me. Furthermore, its Ubuntu LTS (Long Term Support) base also means software updates arrive later, which is another downside for me.\n6 Ubuntu\nMy relationship with Ubuntu has always been a bit of a love-hate story. It's my first distro, one that held my hand as I ventured into the world of Linux. I used it back when the Unity desktop was still a thing, and I loved the fresh feel, the unique workflow, and that signature glassy look. Using Ubuntu genuinely felt like stepping into something new and modern.\nBut over the years, my enthusiasm faded. Ubuntu dropped Unity for GNOME, introduced snap packages (which I\u2019m not a fan of), and made telemetry opt-out by default\u2014something that doesn\u2019t sit right with me in a Linux environment. On top of that, I\u2019ve run into hardware bugs and glitches more often than I\u2019d like, no matter how many times I return to give Ubuntu another shot.\nThat said, I wouldn\u2019t call Ubuntu a bad distro\u2014I still check out new releases from time to time. However, between the design changes, snap focus, and recurring bugs, I just think there are better options out there now.\n5 MX Linux\nMX Linux wasn\u2019t on my radar until I decided to try it specifically for this article. I had heard the name before, but never felt compelled to install it\u2014turns out, I was missing out! MX Linux is based on Debian but comes loaded with useful tools, Conky widgets, packages, and system defaults to minimize the work on your end. From hardware detection to essential drivers (including NVIDIA GPUs), everything just works, making it super convenient for newcomers.\nKDE Plasma is one of the official DE choices, which is great because it\u2019s my favorite DE. That said, for my testing I tried out its flagship Xfce edition, which is good if you like Xfce\u2014I'm just not a huge fan! For me, the main downside is its Debian base, which translates to a slower update cycle. But other than that, MX Linux is a solid distro!\n4 Pop!_OS\nPop!_OS, to me, is what Ubuntu should have evolved into! It\u2019s based on Ubuntu, but it manages to feel more intuitive, powerful, and cohesive thanks to its heavily customized take on GNOME, adding custom tools and extensions. It's also one of the first distros to offer NVIDIA drivers out of the box, making it a hassle-free option for NVIDIA GPU owners\u2014such as myself.\nAlso, it's one of the few Ubuntu-based distros with a corresponding version for both Ubuntu's LTS and non-LTS releases. As such, if you want stability, you can pick the LTS release, whereas if you want new feature updates quicker, you can get the non-LTS release. Honestly, I have nothing but nice things to say about Pop!_OS. The only reason it isn\u2019t higher on my list is that the current version is still based on Ubuntu 22.04 LTS, which, at the time of writing, is over three years old.\nThe reason behind this delay is that the Pop!_OS developers are focusing on developing the Cosmic desktop environment to eventually replace GNOME, and that project is still in alpha. Once it\u2019s released, I fully expect Pop!_OS to rock the Linux world and potentially become my next daily driver\u2014it\u2019s just that good!\n3 Manjaro\nI\u2019ve spent a lot of time criticizing other distros on this list for slow updates and outdated software\u2014but that\u2019s mostly because rolling-release distros like Arch have spoiled me! Manjaro was actually the first Arch-based distribution I ever used, and it really made Arch accessible\u2014and not just for me, but everyone! It's one of the first Arch-made-simple distros, offering a simplified installation process paired with a host of graphical tools for system maintenance.\nRoutine system maintenance, updates, and software management are all handled through user-friendly graphical tools, making Manjaro approachable even for those new to the Arch world. I genuinely have very few (if any) complaints about Manjaro. The only reason it sits at number three on my list is simply because the top two distros are just that much better in my experience.\n2 EndeavourOS\nIf Manjaro is about making Arch easy to use, EndeavourOS is all about making Arch accessible\u2014especially for folks who genuinely want to learn and understand Arch but are intimidated by all the technical jargon. EndeavourOS is designed to hold your hand as you learn Arch Linux and potentially become a more technically informed and skilled user.\nLike Manjaro, it offers helpful graphical tools to get you started, but it also encourages you to explore and configure things for yourself. What stands out most for me is the stellar community backing EndeavourOS. There's a welcoming EndeavourOS forum with helpful members ready to address your technical questions and guide you in the right direction. It's refreshingly free of elitism; no matter your skill level, you\u2019ll find support as long as you\u2019re willing to learn. That sense of empowerment and genuine community spirit is what keeps EndeavourOS so high in my ranking.\n1 CachyOS\nFinally, something both the community and I can agree on\u2014CachyOS is the best distro, at least among the 10 options on this list. It's a relatively new distro released in 2021 and designed specifically for new and modern hardware. It ships with system-level tweaks and custom kernels (like the CachyOS kernel) to extract maximum performance from recent Intel and AMD CPUs. There are even optimized packages in its official repository, fine-tuned for newer systems, making CachyOS one of the most performant and compatible choices for folks with new and powerful hardware.\nFurthermore, much like Manjaro and EndeavourOS, CachyOS is another Arch-made-simple distro. This means you get all the rolling-release and bleeding-edge benefits of Arch, topped off with easy-to-use graphical tools for system maintenance.\nI should also mention that it's a fantastic distro for Linux gaming, with features and optimizations aimed at gamers. There\u2019s even a dedicated version for handheld gaming PCs like the ROG Ally, Legion Go, and Steam Deck. If you want a powerful, modern Linux distro that\u2019s both fast and user-friendly, CachyOS is hard to beat.\nThere you have it\u2014my personal ranking of the current (at the time of writing) 10 most popular Linux distros. Of course, your priorities might be completely different from mine, which is why I've highlighted each distro's unique strengths, so you can focus on those to make your decisions. For example, if you value stability over flashiness, you might flip my rankings entirely with Debian taking the crown!"
    },
    {
      "url": "https://www.howtogeek.com/learn-these-linux-commands-to-go-from-beginner-to-badass/",
      "text": "Getting started with the Linux terminal doesn't have to be daunting, and it can even be fun. Here are six Linux terminal tools that are not only useful but can quickly make you feel like a badass having these in your toolbox.\n1 mc: File Manager\nLet's start things off with a terminal-based visual file manager. The command mc will launch the tool Midnight Commander which is a very powerful file manager for your terminal. You'll feel like a power-user quickly when using this because the interface is reminiscent of classic days of computing where functionality was the norm and form was yet to enter the equation.\nMidnight Commander gives you the ability to easily copy, move and delete files and whole directory trees, search for files and run commands in the subshell, and more. While mc won't be winning any awards for aesthetics, it will give you that feeling of being a terminal ninja, especially if you use it in front of friends and family because it is a file manager with that old classic tech style feel.\nOn a Debian or Ubuntu-based system, you can install it with this command:\nsudo apt install mc\nThen run the command:\nmc\n2 ncdu: Check Your Disk Usage\nThe next tool is a perfect companion of Midnight Commander because it helps you find files on your system based on how much space they take up on your disk. Maybe you're running out of storage space on your drive and you aren't sure why. Perhaps you downloaded a video or recorded a screencast that is taking up a lot of space but don't remember where those files are. This is where ncdu can help.\nNCDU stands for \"NCurses Disk Usage\" and is a disk usage analyzer with a text-mode user interface. Ncdu allows you to easily find storage hogs on your system by scanning your drives and organizing the results based on the largest files at the top of the list. It breaks it down by directory and then by file so you can easily find which files are taking up the most space. Then you can quickly delete them directly if you want to. Otherwise, you could switch to Midnight Commander to do other things with the files.\nI use ncdu often, and my favorite thing about it is the speed. Ncdu is by far the fastest way to analyze your disk usage.\nOn a Debian or Ubuntu-based system, you can install it with this command:\nsudo apt install ncdu\nThen run the command:\nncdu\n3 htop: System Monitor & Process Viewer\nNow that you know how to use the terminal to find files and how to manage them when you need to, let's move to managing your processes. htop is a tool that lets you monitor and manage your system's running processes. It shows a list of all the processes running on your computer and updates this list in real-time.\nWith this system monitor, you can see which processes are using the most amount of CPU usage. That's the default listing, but you can also adjust the sorting method. htop displays the data in a colorful way which offers that cool terminal ninja feeling. In addition to being a process viewer, it also provides information about your system's processor (CPU), swap status, and memory usage.\nOn a Debian or Ubuntu-based system, you can install it with this command:\nsudo apt install htop\nThen run the command:\nhtop\n4 fastfetch: System Info Displayer\nNow it's time to show off your system info to someone in the cool terminal way. There are many of these types of info fetch tools and depending on your Linux distro and version of your distro, you may have different options available to you. To use one of the system-fetch tools, all you need to do is install one and run the default command of the name of the app.\nThe first tool is called fastfetch and this is the current new hotness when it comes to fetch tools but it is also kind of too new so not all distros will have it in their repositories. If you use Ubuntu or something based on Ubuntu then you will need Ubuntu 24.10 or newer in order to install it, otherwise you can use the tool neofetch instead.\nOn a Debian or Ubuntu-based system, you can install it with this command:\nsudo apt install fastfetch\nThen run the command:\nfastfetch\nIf you are using Ubuntu 24.04, or older, or something based on that version of Ubuntu such as Linux Mint 22 then you'll replace fastfetch in the above instructions with neofetch.\n5 nano: Text Editor\nAt some point, you will want to edit a file on your system and what better way than in the terminal? Nano is the default terminal text editor that you will find in most Linux distros. You won't need to install anything here because nano is typically installed by default. You'll just need to launch it and tell it what file you want to run.\nA nice thing about nano for people getting started with the terminal is that it explains how to do certain tasks at the bottom of the interface with a small glossary of shortcut functions. You'll be surprised how quickly nano will come in handy as you explore the Linux terminal experience.\nSimply run the command:\nnano filename\n6 alias: Create Your Own Terminal Commands\nUsing the Linux terminal is a very powerful way to interact with your computer because sometimes it can be much faster to do something in the terminal than in a graphic app. Other times, the command you need to run can be very long. Repetitively typing it can become frustrating, and this is where alias comes in.\nAlias is a tool that lets you create custom commands effectively acting as shortcuts for longer much more complex commands or anything you want. For example, the process of updating your system with apt can be slightly annoying because you have to run two commands back to back each time. After a while, it just gets tedious. You may think to yourself, \"Why isn't this just a single command?\" You'd be joining the rest of the Linux community because we all think that at some point. Thanks to the alias command we can make it one command ourselves by creating an alias for the other two.\nYou can tell the system to first run apt update which refreshes the data about the package repositories so your computer is synced with the servers as to what packages are available. Then you have it run apt upgrade which will perform the updating process for the packages you have installed compared to what is in the repos at that time. You can do this by running the following command:\nalias update='sudo apt update && sudo apt upgrade'\nAfter you've done this you can run the command of simply \"update\" to perform this whole process. This will not only save you time but it also makes you feel like a badass because you're basically creating your own commands now.\nCreating an alias using the above method works but only on a temporary basis. To create an alias permanently, we'll need to edit the .bashrc file in our home folder. We'll edit the file with nano. See? I told you it was going to surprise you how quickly you'd do this.\nOpen your .bashrc file with nano, scroll to the bottom of the file, and then place the alias commands you want at the end of this file with each alias being on a separate line.\nnano ~/.bashrc\nThen place the alias command:\nalias update='sudo apt update && sudo apt upgrade\nThose are the 6 commands that will turn you from a beginner to a badass in the Linux terminal. From here you can interact with your system in a different way that only a true Linux ninja can appreciate.\nAs a quick bonus tip, when you are using a terminal in Linux you will notice that Ctrl+C for copy and Ctrl+V for paste don't work, which is pretty annoying. That's because this form of computer interaction was created prior to the invention of copy-and-paste desktop shortcuts and terminal emulators like to keep it that way. Thankfully, this is easily addressed in most terminal windows simply by adding a Shift to the shortcut, so you'll use Ctrl+Shift+C and Ctrl+Shift+V."
    }
  ],
  "argos_summary": "The article discusses the complexities and learning experiences associated with using Linux, emphasizing that breaking the system is often part of the learning process. It highlights the power and responsibility that comes with being a Linux administrator, as well as the importance of having safety nets like backups and snapshots. Additionally, it explores various Linux distributions and their unique features, ultimately ranking them based on personal preferences and usability.",
  "argos_id": "L45XSBFJ6"
}